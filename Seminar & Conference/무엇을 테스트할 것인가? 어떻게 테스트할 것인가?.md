## 무엇을 테스트할 것인가? 어떻게 테스트할 것인가?

- 발표 영상 : https://youtu.be/YdtknE_yPk4

### 테스트로부터 얻을 수 있는 것

- 안정감과 자신감을 얻을 수 있다!
- 누구에게 안정감과 자신감을 줄 수 있을까?
  - 현재와 미래의 나
  - 현재와 미래의 동료

### 무엇을 테스트할 것인가?

- 구현을 테스트? 설계를 테스트?
  - 구현은 미래의 누군가에 의해 언젠가 어떻게든 변할 수 있다
    - 테스트 코드가 있다면 바로 테스트가 깨지니까 버그를 빨리 알 수 있다
  - 구현을 테스트하는 게 아니고 설계를 테스트해야 한다.
    - private 메서드를 테스트하고 싶어진다면 구현테스트를 하고 있을 가능성이 높다

- 테스트 가능한 것, 불가능한 것
  - 테스트 할 수 없는것들 = 제어할 수 없는 영역
    - Random, Shuffle, LocalDate.now()
    - 외부세계 (HTTP, 외부 저장소)
  - 항상 성공할 수 있는 것, 항상 동일한 결과가 나올 수 있는 것을 테스트해야 한다.

### 어떻게 테스트할 것인가?

- 테스트 할 수 없는 메서드를 Boundary layer까지 끌어올려서 테스트 할 수 있도록 변경 
  - 테스트 할 수 없는 메서드가 테스트할 수 있는 메서드까지 오염을 시키니까 테스트 할 수 없는 메서드를 Boundary layer까지 끌어올려서 테스트 할 수 없는 부분을 최소화한다.
- 스프링에선?
  - @SpringBootTest를 지양하자
    - 스프링 컨테이너가 정말 필요할지 생각하자
    - @SpringBootTest는 느리다 -> 빠른 피드백을 받을 수 없다
  - 컨텍스트, 프레임워크 종속적이지 않은 테스트를 우선
    - @Autowired보단 생성자 주입
- Test Double
  - 테스트 할 수 없는 영역에 대한 외부 요인을 부여할 수 있도록 도와줌
  - Test Double을 사용한다는 것은 테스트가 구현을 알아야 한다는 것
  - Test Double의 남용은 구현 테스트로 유도할 수 있다
  - 편리하지만 사용을 의식하여 최소화
- 순수 자바 어플리케이션으로는 테스트 할 수 없는것
  - 저장소 입출력 검증
  - SPEC 검증
    - 내부 Controller
    - 외부 API
- 임베디드 시스템 활용
  - h2, kstyrc/embedded-redis, ...
  - 테스트와 임베디드 시스템은 동일한 라이프사이클을 갖도록 구성
- EndPoint Test
  - MockMvc, REST Assured, WebTestClient
- Spring Cloud Contract

### Tip & Rule

1. 테스트는 상호 독립적으로 작성
   - 모든 테스트의 순서와 관계를 생각하며 테스트를 작성하기 어렵기 때문.
     - 테스트의 순서를 갖도록 하고 싶다면 JUnit5의 DynamicTest 추천
   - 공유되는 자원은 초기화하여 다른 테스트에 영향을 받지 않도록 한다. (@After같은 걸로)
2. 테스트 안에 의도와 목적이 드러나도록 작성
   - given when then이 명확하게
3. 테스트 코드도 리팩토링 대상
   - 비즈니스 코드와 동일한 수준의 리팩토링이 함께 이루어져야 한다

  