> "객체지향이 뭐야?"

`객체지향 프로그래밍` 이라는 과목을 수강한다는 나의 말에 친구가 한 질문이다.

> "클래스 만들어서 어떻게 어떻게 코딩하는 걸껄?"

그리고 나의 대답이다. 아마 객체지향에 대해 잘 아는 사람이 옆에 있었다면 코웃음을 쳤을 것이다.

그래도 저 당시의 내가 이해가 되지 않는건 아니다. 

왜냐하면 `객체지향 프로그래밍`이라는 과목에서 변수, for문, while문 같이 쌩기초를 살짝 보고 바로 클래스에 대해 배우기 시작했으니까.

그래서 그 당시에 가지고 있던  *"객체지향 프로그래밍 = 클래스 써서 코딩하는것 "*  라는 인식은 어쩌면 당연할 지도 모른다.

하지만 이제는 안다. 객체지향 프로그래밍은 클래스가 아니라 객체를 지향하는 것이고, 클래스는 단지 객체의 구현 매커니즘이라는 것을.

사실 위와 같은 오해를 몇 년간 가지고 있다가 깨기 시작한 건 얼마 되지 않았다. [우아한테크코스](https://woowacourse.github.io/)에서 필독서로 지정한 `객체지향의 사실과 오해`라는 책을 읽으면서 객체지향이 뭔지에 대해 점점 개념을 잡아갔다.  



> ​    [객체지향의 오해들]
>
> - 객체지향은 현실 세계에 존재하는 사물에 대한 추상화이다?
>
> - 객체지향은 클래스를 지향하는 것이다?
> - 객체지향의 중심은 클래스와 상속이다?  



이 책을 읽으면서 위에 나열한 오해들이 하나하나 깨부숴졌다. 그럴 때마다 왠지 모를 희열이 느껴졌다.  



## 1. 협력하는 객체들의 공동체

이 장에서는 객체지향에서 가장 중요한 개념 3가지,

`역할`, `책임`, `협력`에 대해 간단히 소개하고 있다. 



> 일반적으로 사람들은 스스로 해결하지 못하는 문제와 마주치면 다른 사람에게 도움을 요청한다. 
>
> 한 사람에 대한 요청은 보통 다른 요청을 유발하는 게 일반적이기 때문에 요청은 주로 연쇄적으로 발생한다.
>
> 또 요청을 받으면 사람들은 응답한다. 이처럼 사람들은 요청과 응답을 주고받는데, 이를 `협력`이라고 한다.
>
> 사람들은 다른 사람들과 `협력`을 하는 과정 속에서 `역할`을 부여받는다. 
>
> `역할`은 `협력`에 참여하는 사람이 차지하는 `책임`이다. 즉, `역할`이라는 단어는 `책임`이라는 개념을 내포한다.

위의 글에서 '사람'이라는 단어를 '객체'로,

'요청'을 '메시지'로, 요청을 처리하는 방법을 메서드라고 생각해도 어색하지 않다.





객체의 역할은 다음과 같은 특징을 지닌다

- 여러 객체가 동일한 역할을 수행할 수 있다.
- 역할은 대체 가능성을 의미한다.
- 각 객체는 책임을 수행하는 방법을 자율적으로 선택할 수 있다.
- 하나의 객체가 동시에 여러 역할을 수행할 수 있다.





협력 공동체로서의 일원으로서의 객체는 다음과 같은 두가지 덕목을 갖춰야 한다.

1. 객체는 충분히 `협력적`이어야 한다.
2. 객체는 충분히 `자율적`이어야 한다.

두가지는 동시에 달성할 수 없는 상충관계인 것처럼 보인다. 

객체는 다른 객체의 명령에 따라 행동하는 수동적인 존재가 아니라 다른 객체의 요청에 응답하는 `협력적`인 존재이고, 

또 외부의 도움을 무시한 채 스스로 해결하려는 전지전능한 존재가 아니라 다른 객체의 요청에 응답하지만 어떻게 처리해야 할 지에 대한 결정은 `자율적`으로 처리한다는 뜻이다.





객체는 다른 객체와 협력하기 위해 `메시지`를 전송하고, 수신자는 수신된 `메시지`를 본인만의 방법을 통해 처리한다.

이처럼 객체가 수신된 `메시지`를 처리하는 방법을 `메서드`라고 한다.

외부의 요청이 무엇인지를 표현하는 `메시지`와 요청을 처리하기 위한 구체적인 방법인 `메서드`를 분리하는 것이 객체의 `자율성`을 높이는 핵심 메커니즘이다.

이것은 `캡슐화`와 깊이 관련돼 있다.





결국,

- 객체지향이란 시스템을 상호작용하는 `자율적인 객체들의 공동체`로 바라보고 객체를 이용해 시스템을 분할하는 방법이다.
- 자율적인 객체란 `상태와 행위`를 함께 지니며 스스로 자기 자신을 책임지는 객체를 의미한다.
- 각 객체는 `협력` 내에서 정해진 `역할`을 수행하며 `역할`은 관련된 `책임`의 집합이다.
- 객체는 `메시지`를 전송하고, `메시지`를 수신한 객체는 적합한 `메서드`를 `자율적`으로 선택한다.





> 객체지향은 클래스를 지향하는 것이다?

클래스가 객체지향 프로그래밍 언어 관점에서 중요한 것은 맞지만 중심 개념은 아니다. 중요한 것은 어떤 객체가 어떤 메시지를 주고받으며 협력하는가이다. 클래스는 협력에 참여하는 객체를 만드는 데 필요한 구현 메커니즘일 뿐이다. 





즉, 클래스가 아니라 객체의 역할, 책임, 협력에 집중하자! 

객체지향은 객체를 지향하는 것이지 클래스를 지향하는 게 아니다. 





## 2. 이상한 나라의 객체

그럼 대체 객체란 무엇인가?

> 객체란 `상태`, `행동`, `식별자`를 가진 실체다 !





#### - 상태

우리 일상생활 속에서 일어나는 모든 행동의 결과는 과거에 어떤 행동들이 일어났었으냐에 의존한다.

그럼 과거의 모든 행동에 대한 이력을 전부 기억해야 하는가? 그럴 필요 없다.

`상태`를 이용한다면 과거에 얽매이지 않고 현재를 기반으로 객체의 행동 방식을 이해할 수 있다.





> 키가 130cm인 앨리스가 집에서 0.5L짜리 음료를 마시고 있다고 생각하자.
>
> `상태`는 특정 시점에 객체가 가지고 있는 정보의 집합이다.
>
> `프로퍼티`는 `상태`를 구성하는 모든 특징이다. (정적이다. 위의 예에선 키, 위치, 음료 등)
>
> `프로퍼티 값`은 말 그대로 프로퍼티가 가지고 있는 값이다.  (동적이다. 위의 예에선 130cm, 집 등)
>
> `속성`은 객체를 구성하는 단순한 값이다. (위의 예에선 키, 위치)
>
> `링크`는 객체와 객체 사이의 의미있는 연결이다. (위의 예에선 앨리스와 음료 사이의 연결)
>
> `상태` = `프로퍼티` + `프로퍼티 값`
>
> `프로퍼티` = `속성` + `링크`





객체는 자율적인 존재다. 객체 개개인은 본인의 상태를 책임져야 한다. 다른 객체의 상태를 주무를 수 없다.

하지만 `행동`을 통해서 간접적으로 다른 객체의 상태를 변경하거나 조회할 수 있다.





#### - 행동

객체가 취하는 `행동`은 다음의 부수효과(side effect)를 초래한다. 

- 객체 자신의 `상태` 변경
- 행동 내에서 협력하는 다른 객체에 대한 메시지 전송





`행동`이란 외부의 요청 또는 수신된 메시지에 응답하기 위해 동작하고 반응하는 활동이다. 객체는 `행동`을 통해 다른 객체와의 `협력`에 참여하므로 `행동`은 외부에 가시적이어야 한다.





> 객체지향 프로그래밍은 현실 세계에 대한 모방이다?

아니다. 물론 위의 말이 객체지향을 이해하는데 도움을 주는 건 사실이다.

하지만 음료수, 연필같은 현실의 객체는 스스로는 아무것도 할 수 없는 수동적인 존재다.

객체지향의 세계에서는 모든 객체는 자신의 상태를 스스로 관리하는 자율적인 존재다.

현실 세계에서는 사람이 음료수를 마신다면 사람이 음료수의 양을 직접적으로 줄이지만

객체지향의 세계에서는 사람 객체가 ''마셨다''라는 메시지를 음료수 객체에게 전달하면

음료의 양을 줄이는 건 그 메시지를 수신한 음료수 객체 스스로의 몫이다.

사람 객체는 음료수 객체에게 메시지를 보낼 뿐, 음료수의 상태 변경에 대해서는 전혀 알지 못한다.

이는 `캡슐화`를 의미한다.





#### - 식별자

종이 위에 1이라는 숫자가 두 개 쓰여있다고 상상해보자.

그럼 두 1은 같다라고 말할 수 있는가?

이번에는 나 자신과 세포 하나하나까지 똑같은 복제 인간이 있다고 상상해보자.

그럼 나와 그 복제인간은 같다고 말할 수 있는가?

그렇다면 나와 10년전 과거의 나는 현재의 나와 같다고 말할 수 있는가?





종이 위의 두 1은 같다. 왜냐하면 값(value)의 상태는 변하지 않는 `불변 상태(immutable state)`를 가지기 때문이다.

"불변이라니? 1에 1을 더하면 2로 변하지 않는가?" 라고 생각할 수 있다. 하지만 1에서 2로 변한 것이 아니고 서로 다른 인스턴스인 것이다.

값의 경우 두 인스턴스의 상태가 같으면 같은 것으로 판단하는 `동등성(equality)`을 갖는다.

값은 오직 상태만을 이용해 인스턴스를 구별하기 때문에 `식별자`가 필요하지 않다.

반면, 객체는 상태가 완전히 똑같더라도 ''같다''라고 말할 수 없다. 왜냐하면 객체는 `가변 상태(mutable state)` 가지기 때문에 시시각각 상태가 변하기 때문이다.

즉, 나와 복제인간은 "같다"라고 말할 수 없다. 그래서 객체는 상태가 아니라 `식별자`로 구분한다.

이처럼 두 객체의 상태가 다르더라도 식별자가 같으면 같은 객체라고 판단할 수 있다. (이를 `동일성(identical)`이라고 한다.)

같은 맥락으로, 나 자신 객체와 10년전 과거의 나 객체는 `식별자`가 같다면 같은 객체이다.





즉, 두 `값`은 `동등성 검사`를 통해 비교할 수 있다. 두 `객체`는 `동일성 검사`를 통해 비교할 수 있다.



----







> 객체지향에 갓 입문한 사람들이 가장 쉽게 빠지는 함정은 상태를 중심으로 객체를 바라본다는 점이다.
>
> 객체에 필요한 상태가 뭔지 결정하고 그 상태에 필요한 행동을 결정하지 말고,
>
> 행동에 초점을 맞춰라!
>
> 행동은 객체가 협력에 참여하기 위한 유일한 방법이다.
>
> 행동이 상태를 결정한다.





위에서도 얘기했듯, 소프트웨어 안에 구축되는 객체지향 세계는 현실을 모방한 것이 아니다. 현실의 모습을 조금 참고할 뿐 궁극적인 목표는 현실과 전혀 다른 새로운 세계를 창조하는 것이다.

현실의 객체보다 더 많은 일을 할 수 있는 소프트웨어 객체의 특징을 `의인화`라고 한다.

우리는 `의인화`를 사용하여 객체 스스로 자율성을 갖는 이상한 나라를 창조할 수 있다.

이 책에서 객체지향을 이상한 나라의 앨리스를 이용하여 설명하는 이유는 여기에 있다.







## 3. 타입과 추상화

현실은 너무나도 복잡하고 예측 불가능하다. 하지만 `추상화`를 통해 현실의 복잡성을 극복할 수 있다.





> 추상화란?
>
> 어떤 양상, 세부사항, 구조를 좀 더 명확하게 이해하기 위해 특정 절차나 물체를 의도적으로 생략하거나 감춤으로써 복잡도를 극복하는 방법이다.
>
> 1. 구체적인 사물들 간의 공통점을 취하고 차이점을 버리는 일반화
> 2. 중요한 부분을 강조하기 위해 불필요한 세부사항을 제거
>
> 추상화는 두 차원에서 이뤄진다.





이상한 나라의 앨리스에 등장하는 트럼프 모양의 정원사, 병사, 신하, 왕자와 공주, 왕과 왕비와 흰 토끼를 상상해보자. 

우리는 트럼프 모양의 정원사, 병사, 신하, 왕자와 공주, 왕과 왕비를 '트럼프'라는 한 단어로 지칭할 수 있다.

왜냐하면 일반적인 외형과 행동 방식이 트럼프와 같기 때문이다.

이처럼 공통점을 기반으로 객체들을 묶기 위한 그릇 또는 객체를 분류할 수 있는 일종의 체를 `개념`이라고 한다.

우리는 `개념`을 이용하여 상황을 단순화하여 `추상화`하려는 노력을 기울인다.

`개념`을 이용하면 객체를 여러 그룹으로 `분류`할 수 있다.

> 객체란 특정한 `개념`을 적용할 수 있는 구체적인 사물을 의미한다. `개념`이 객체에 적용됐을 때 객체를 `개념`의 `인스턴스`라고 한다.





일반적으로 객체의 분류 장치로서 개념을 이야기 할때는 아래의 세가지 관점이 있다. 세가지 관점은 분류 방식에 대한 지침을 제공한다.

1. 심볼 : 개념을 가리키는 이름, 위의 예에선 '트럼프'
2. 내연 : 개념의 완전한 정의, 위의 예에선 '트럼프에 대한 설명'. 즉, 몸이 납작하고 두 발은 네모 귀퉁이에 있다 등
3. 외연 : 개념에 속하는 모든 객체의 집합, 위의 예에선 정원사, 병사, 신하 등





`개념`은 객체들의 복잡성을 극복하기 위한 추상화 도구다. (추상화의 두가지 차원을 모두 이용한다.)

`분류`는 객체에 특정한 개념을 적용하는 작업이다. 추상화를 위한 도구이다.



`개념`은 컴퓨터에서의 `타입`과 유사하다.



`타입`은 데이터가 아니라 `행동`에 의해 결정된다.



## 4. 역할, 책임, 협력





## 5. 책임과 메시지





## 6. 객체 지도





## 7. 함께 모으기



