# 초보 웹 개발자를 위한 스프링5 프로그래밍 입문

## Chapter 2 스프링 시작하기

### 메이븐 의존 설정

메이븐에서는 `pom.xml` 파일을 이용해 프로젝트 설정을 한다.

의존 설정은 다음과 같이 할 수 있다. (`pom.xml` 의 일부)

```markdown
<dependency>
	<groupId>org.springframework</groupId>
	<artifactId>spring-context</artifactId>
	<version>5.0.2.RELEASE</version>
</dependency>
```

메이븐은 한 개의 모듈을 `artifact`라는 단위로 관리한다.

위 설정의 의미는

- `spring-context`라는 식별자를 가진 `5.0.2.RELEASE` 버전의 아티팩트에 대한 의존을 추가한다.
- 자바 어플리케이션에서 클래스패스에 `spring-context` 모듈을 추가한다.
- 소스코드를 컴파일하고 실행할 때 사용할 클래스 패스에 `spring-context-5.0.2.RELEASE.jar`파일을 추가한다.

이다.

### 메이븐 리포지토리

메이븐 리포지토리는 `원격 리포지토리`와 `로컬 리포지토리`가 있다

위의 예에서 `spring-context-5.0.2.RELEASE.jar` 를 `로컬 리포지토리`에서 찾을 수 없다면 `원격 리포지토리`에서 해당 파일을 다운로드하여 그 파일을 사용한다.

### 의존 전이

메이븐은 의존하는 대상뿐만 아니라 의존 대상이 다시 의존하는 대상을 함께 다운로드한다. 이렇게 의존 대상이 다시 의존하는 대상까지도 의존 대상에 포함하기 때문에 이를 의존 전이라고 한다.

### build.gradle

그레이들에서는 메이븐의 `pom.xml`대신에 `build.gradle`파일을 사용한다.

```xml
apply plugin: 'java' //그레이들 java 플러그인 적용

sourceCompatibility = 1.8
targetCompatibility = 1.8 //소스, 컴파일 결과를 1.8버전에 맞춤
compileJava.options.encoding = "UTF-8" //소스코드 인코딩으로 UTF-8 사용

repositories {
    mavenCentral() //의존 모듈을 메이븐 중앙 리포지토리에서 다운로드함
}

dependencies {
		//spring-context 모듈에 대한 의존 설정
    compile 'org.springframework:spring-context:5.0.2.RELEASE'
}

//래퍼설정 (그레이들 설치없이 그레이들을 실행할 수 있도록 해줌)
task wrapper(type: Wrapper) {
    gradleVersion = '4.4'
}
```

### 예제 코드

```java
public class Greeter {
	private String format;

	public String greet(String guest) {
		return String.format(format, guest);
	}

	public void setFormat(String format) {
		this.format = format;
	}
}
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;

@Configuration
public class AppContext {

	@Bean
	public Greeter greeter() {
		Greeter g = new Greeter();
		g.setFormat("%s, 안녕하세요!");
		return g;
	}
}
```

`@Configuration` : 스프링 설정 클래스로 지정한다.

`@Bean` : 이 애너테이션을 메서드에 붙이면 이 메서드가 생성한 객체를 빈 객체로 등록한다. 즉, 이 메서드가 생성한 객체를 "greeter"이라는 이름으로 빈으로 등록한다.

```java
import org.springframework.context.annotation.AnnotationConfigApplicationContext;

public class Main {

	public static void main(String[] args) {
		AnnotationConfigApplicationContext ctx = 
				new AnnotationConfigApplicationContext(AppContext.class);
		Greeter g = ctx.getBean("greeter", Greeter.class);
		String msg = g.greet("스프링");
		System.out.println(msg);
		ctx.close();
	}
}
```

`AnnotationConfigApplicationContext` 은 `Greeter`객체를 생성하고 초기화한다.

`AppContext` 에서 `greeter` 란 이름으로 빈 등록을 했으므로

`Greeter g = ctx.getBean("greeter", Greeter.class);` 와 같이 이름으로 꺼낼 수 있다.

### 스프링은 객체 컨테이너

스프링의 핵심 기능은 객체를 생성하고 초기화하는 것이다.

`ApplicationContext` (또는 `BeanFactory`)는 빈 객체의 생성, 초기화, 보관, 제거 등을 관리하고 있어서 이를 컨테이너라고도 부른다.

### 싱글톤 객체

별도의 설정을 하지 않을 경우, 스프링은 한 개의 빈 객체만을 생성한다. 즉, 한 개의 `@Bean` 애너테이션에 대해 한 개의 빈 객체를 생성한다.

```java
public static void main(String[] args) {
		AnnotationConfigApplicationContext ctx = 
				new AnnotationConfigApplicationContext(AppContext.class);
		Greeter g1 = ctx.getBean("greeter", Greeter.class);
		Greeter g2 = ctx.getBean("greeter", Greeter.class);
		System.out.println("(g1 == g2) = " + (g1 == g2)); //(g1 == g2) = true 가 출력된다
		ctx.close();
	}
```

이 때의 빈 객체는 '싱클톤 범위를 갖는다'라고 표현한다.

싱글톤 범위 위에도 프로토타입 범위도 존재하지만 추후에 다룬다.

## Chapter 3 스프링 DI

### 의존이란?

한 클래스가 다른 클래스의 메서드를 실행할 때 이를 '의존'한다고 표현한다.

A클래스가 B클래스를 의존하는 경우 B클래스의 변경에 의해 A클래스가 영향을 받는다.

의존하는 대상을 구하고 싶을 땐 의존 대상을 직접 생성하는 방법이 있지만, 유지보수 측면에서 더욱 권장되는 방법이 있다. 바로 DI(의존성 주입) 이다.

### DI 방식

생성자 방식과 세터 메서드 방식이 있다.

두 방식 중에서 더 좋은 방식이란 건 없다. 각자 장단점이 있다.

- 생성자 방식 : 빈 객체를 생성하는 시점에 모든 의존 개게가 주입된다.
- 세터 메서드 방식 : 세터 메서드 이름을 통해 어떤 의존 객체가 주입되는지 알 수 있다.

### @Configuration 설정 클래스의 @Bean 설정과 싱글톤

```java
@Configuration
public class AppCtx {

	@Bean
	public MemberDao memberDao() {
		return new MemberDao();
	}
	
	@Bean
	public MemberRegisterService memberRegSvc() {
		return new MemberRegisterService(memberDao());
	}
	
	@Bean
	public ChangePasswordService changePwdSvc() {
		ChangePasswordService pwdSvc = new ChangePasswordService();
		pwdSvc.setMemberDao(memberDao());
		return pwdSvc;
	}
}
```

스프링은 설정 클래스를 그대로 사용하지 않고 설정 클래스를 상속하는 새로운 설정 클래스를 만들어서 사용한다.

상속받는 설정 클래스에선 매번 새로운 객체를 생성하지 않고 한 번 생성한 객체를 보관했다가 이후에는 동일한 객체를 리턴한다.

그래서 `memberDao()` 메서드를 몇번 호출하더라도 반환되는 객체는 항상 같다.

### @Autowired 애노테이션

`@Autowired` 어노테이션은 스프링의 자동 주입 기능을 위한 것이다.

클래스 필드에 `@Autowired` 어노테이션을 붙이면 해당 타입의 빈을 찾아서 필드에 할당한다.

스프링 빈에 의존하는 다른 빈을 자동으로 주입하고 싶을 때 사용한다.

`@Autowired` 를 설정 클래스에서 사용해도 스프링 빈으로 등록하여 자동 주입을 수행한다.

### @Import 애노테이션

`@Import` 애노테이션은 함께 사용할 설정 클래스를 지정한다.

다음과 같이 배열을 이용해서 두 개 이상의 설정 클래스도 지정할 수 있다.

```java
@Configuration
@Import({AppConf1.class, AppConf2.class})
public class AppConfImport {
	...
}
```

### @GetBean() 메서드 사용

다음과 같이 `getBean()` 메서드를 이용하여 사용할 빈 객체를 구했다.

```java
VersionPrinter versionPrinter = ctx.getBean("versionPrinter", VersionPrinter.class);
```

- "versionPrinter"에 오타가 났다면? `NoSuchBeanDefinitionException`
- VersionPrinter.class에 잘못된 클래스를 넣었다면? `BeanNotOfRequiredException`
- 빈 이름 안쓰고 클래스만 넣는다면?
  - 해당 타입의 빈 객체가 한 개만 존재한다면 OK
  - 해당 타입의 빈 객체가 없으면 `NoSuchBeanDefinitionException`
  - 해당 타입의 빈 객체가 두 개 이상 존재하면 `NoUniqueBeanDefinitionException`

## Chaper 4 의존 자동 주입





