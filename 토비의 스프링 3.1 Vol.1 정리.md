# 토비의 스프링 3.1 Vol.1 정리

## 1장 오브젝트와 의존관계

스프링의 핵심 철학은?

> 자바 엔터프라이즈 기술의 혼란 속에서 잃어버렸던 객체지향 기술의 진정한 가치를 회복시키고, 객체지향의 혜택을 누릴 수 있도록 기본으로 돌아가자.

<br/>

### 1.1 초난감 DAO

사용자 정보를 저장할때는 자바빈 규약을 따르는 오브젝트를 이용하면 편리하다. User클래스와 UserDao를 만들어보자.

자바빈 : 디폴트 생성자와 프로퍼티(getter, setter로 수정 또는 조회 가능)를 가진 오브젝트

```java
@Getter @Setter
public class User {
	String id;
	String name;
	String password;
}
```

```java
public class UserDao {
	public void add(User user) throws ClassNotFoundException, SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook?characterEncoding=UTF-8", "spring", "book");

		PreparedStatement ps = c.prepareStatement(
			"insert into users(id, name, password) values(?,?,?)");
		ps.setString(1, user.getId());
		ps.setString(2, user.getName());
		ps.setString(3, user.getPassword());

		ps.executeUpdate();

		ps.close();
		c.close();
	}


	public User get(String id) throws ClassNotFoundException, SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook?characterEncoding=UTF-8", "spring", "book");
		PreparedStatement ps = c.prepareStatement("select * from users where id = ?");
		ps.setString(1, id);

		ResultSet rs = ps.executeQuery();
		rs.next();
		User user = new User();
		user.setId(rs.getString("id"));
		user.setName(rs.getString("name"));
		user.setPassword(rs.getString("password"));

		rs.close();
		ps.close();
		c.close();

		return user;
	}
}
```

위 코드는 굉장히 난감한 코드다. 천천히 개선해보자.

<br/>

### 1.2 DAO의 분리

오브젝트에 대한 설계와 이를 구현한 코드는 항상 바뀐다. 미래의 변화에 가장 좋은 대처는 한 가지 관심이 한 군데에 집중되게 하는 것이다.

UserDao는 사실 3가지 관심이 혼재되어 있다.

1. DB와의 연결을 위한 커넥션을 어떻게 가져올까?
2. SQL을 담을 Statement를 만들고 실행하기
3. Statement와 Connection 오브젝트를 닫기

일단, 중복된 코드를 getConnection()으로 추출해보자.

```java
public class UserDao {
	public void add(User user) throws ClassNotFoundException, SQLException {
		Connection c = getConnection();

		PreparedStatement ps = c.prepareStatement(
			"insert into users(id, name, password) values(?,?,?)");
		ps.setString(1, user.getId());
		ps.setString(2, user.getName());
		ps.setString(3, user.getPassword());

		ps.executeUpdate();

		ps.close();
		c.close();
	}


	public User get(String id) throws ClassNotFoundException, SQLException {
		Connection c = getConnection();
        
		PreparedStatement ps = c.prepareStatement("select * from users where id = ?");
		ps.setString(1, id);

		ResultSet rs = ps.executeQuery();
		rs.next();
		User user = new User();
		user.setId(rs.getString("id"));
		user.setName(rs.getString("name"));
		user.setPassword(rs.getString("password"));

		rs.close();
		ps.close();
		c.close();

		return user;
	}


	private Connection getConnection() throws ClassNotFoundException, SQLException {
		Class.forName("com.mysql.jdbc.Driver");
		Connection c = DriverManager.getConnection("jdbc:mysql://localhost/springbook?characterEncoding=UTF-8", "spring", "book");
		return c;
	}
}
```

이제 커넥션을 가져오는 부분에 대한 수정을 하려면 getConnection() 메서드만 수정하면 된다.

UserDao를 그대로 이용하되, getConnection() 메서드만 변경해서 사용하고 싶으면 상속을 이용할 수 있다.

getConnection()을 추상 메서드로 변경하고, 이 UserDao를 상속받으면 된다. (템플릿 메소드 패턴)

상속받은 하위 오브젝트는 커넥션 생성 방법을 스스로 결정한다. (팩토리 메소드 패턴)

```java
public class UserDao {
	public void add(User user) throws ClassNotFoundException, SQLException {
		Connection c = getConnection();
		...
	}


	public User get(String id) throws ClassNotFoundException, SQLException {
		Connection c = getConnection();
		...

	private abstract Connection getConnection() throws ClassNotFoundException, SQLException {
	}
}
```

```java
public class NUserDao extends UserDao {
    public Connection getConnection() throws ClassNotFoundException, SQLException {
        //N사 DB커넥션 생성코드
    }
}
```

```java
public class DUserDao extends UserDao {
    public Connection getConnection() throws ClassNotFoundException, SQLException {
        //D사 DB커넥션 생성코드
    }
}
```

- UserDao는 getConnection() 메소드에서 생성하는 오브젝트가 Connection인터페이스의 오브젝트라는 것 이외에는 관심이 없다.
- UserDao는 Connection 오브젝트가 만들어지는 방법, 내부 동작 방식에는 관심이 없고 사용할 뿐이다.
- NUserDao와 DUserDao는 어떤 식으로 Connection 오브젝트를 만들어내는지에만 관심을 가지고 있다.

하지만!

- 만약 이미 UserDao가 상속을 사용하고 있다면? 다음에 UserDao에 상속을 적용하기 힘들다
- 상속을 사용하면 상하위 클래스의 관계가 밀접해진다.
- 확장된 기능인 DB커넥션을 생성하는 코드를 다른 DAO에 적용할 수 없다.

<br/>

### 1.3 DAO의 확장

상속을 사용해서 분리하지 말고 아예 별개의 클래스를 만들어서 분리해보자.

```java
public class SimpleConnectionMaker {
    public Connection makeNewConnection() throws ClassNotFoundException, SQLException {
        ...
    }
}
```

```java
public class UserDao {
    private SimpleConnectionMaker simpleConnectionMaker;
    
    public UserDao() {
        simpleConnectionMaker = new SimpleConnectionMaker();
    }
    
    public void add(User user) throws ClassNotFoundException, SQLException {
		Connection c = simpleConnectionMaker.makeNewConnection();
		...
	}
    
    public User get(String id) throws ClassNotFoundException, SQLException {
		Connection c = simpleConnectionMaker.makeNewConnection();
		...
	}
}
```

- 하지만 UserDao클래스만 공급하고 상속을 통해 DB 커넥션 기능을 확장할 수 있었던 게 도로 못하게 됐다.
  - UserDao가 특정 클래스에 종속되어 있기 때문에 DB 커넥션 기능을 확장하려면 UserDao를 직접 수정해야 하기 때문에
- 이 코드의 문제점은?
  - D사의 DB커넥션 제공 클래스가 openConnection()이라는 메소드명을 사용한다면 UserDao.add(), UserDao.get()안의 makeNewConnection()을 모두 openConnection()으로 변경해야 한다.
  - DB커넥션을 제공하는 클래스가 어느것인지 UserDao가 구체적으로 알고 있어야 한다.
- 왜 그럴까?
  - UserDao가 DB커넥션을 가져오는 정보에 대해 너무 많이 알고 있기 때문이다.
  - UserDao가 SimpleConnectionMaker라는 특정 클래스에 종속적이기 때문이다.
  - 그래서 고객이 DB커넥션을 가져오는 방법을 자유롭게 확장하기가 힘들다.



그럼 ConnectionMaker라는 인터페이스를 만들어서 어떻게 구현했는지에 대한 관심을 두지 말자.

```java
public interface ConnectionMaker {
    public Connection makeConnection() throws ClassNotFoundException, SQLException;
}
```

```java
public class DConnectionMaker implements ConnectionMaker {
    public Connection makeConnection() throws ClassNotFoundException, SQLException {
        //D사의 커넥션 생성 코드
    }
}
```

```java
public class UserDao {
    private ConnectionMaker connectionMaker;
    
    public UserDao() {
        connectionMaker = new DConnectionMaker();
    }
    
    public void add(User user) throws ClassNotFoundException, SQLException {
		Connection c = connectionMaker.makeConnection();
		...
	}
    
    public User get(String id) throws ClassNotFoundException, SQLException {
		Connection c = connectionMaker.makeConnection();
		...
	}
}
```

- DConnectionMaker같은 친구를 많이 만들어도 UserDao는 전혀 변경되지 않을 것 같다.
- 하지만 DConnectionMaker라는 특정 오브젝트가 UserDao 코드 속에 존재한다. (구체적인 클래스를 알게 된다.)
- 이는 UserDao안에 또다른 관심사항이 존재하기 때문이다.(어떤 구현체를 사용할 것인가?에 대한 관심사항)
- 그럼 그 관심을 어디에 둘까? UserDao의 클라이언트가 적절하다.
  - 왜냐하면 클라이언트가 UserDao를 사용하는 입장이기 때문에 ConnectionMaker의 구현체를 선택해서 UserDao와 연결시켜줘야 하는 책임이 있다.
- UserDao의 클라이언트가 UserDao오브젝트와 ConnectionMaker오브젝트의 관계를 설정해준다(클래스와 클래스 관계를 설정해주는 게 아니다!)
- 클래스 사이의 관계와 오브젝트 사이의 관계를 잘 구분할 줄 알아야 한다.
  - 클래스 사이의 관계는 코드의 다른 클래스의 이름이 나타남으로써 생김
  - 오브젝트 사이의 관계는 런타임에 생김
  - 코드에서는 특정 클래스를 전혀 알고 있지 않더라도 해당 클래스가 구현한 인터페이스를 사용했다면 사용가능하다.
  - 다형성 덕분!

구현체 선택에 대한 관심을 클라이언트에 떠넘겨보자.

```java
public class UserDao {
    private ConnectionMaker connectionMaker;
    
    public UserDao(ConnectionMaker connectionMaker) {
        this.connectionMaker = connectionMaker; //DConnectionMaker가 사라졌다.
    }
    
    public void add(User user) throws ClassNotFoundException, SQLException {
		Connection c = connectionMaker.makeConnection();
		...
	}
    
    public User get(String id) throws ClassNotFoundException, SQLException {
		Connection c = connectionMaker.makeConnection();
		...
	}
}
```

```java
public static void main(String[] args) throws ClassNotFoundException, SQLException {
    ConnectionMaker connectionMaker = new DConnectionMaker();//클라이언트가 구현체 직접선택
    UserDao dao = new UserDao(connectionMaker);//오브젝트사이의 의존관계 설정
    ...
}
```

- 이제 DB커넥션을 가져오는 방법을 어떻게 변경하든 UserDao코드는 아무런 영향을 받지 않는다.
- DAO가 아무리 많아져도 DB접속방법에 대한 관심은 오직 한 군데에 집중되어 있다.

<br/>

### 1.4 제어의 역전(IoC)

IoC가 뭔지 살펴보기 위해 UserDao코드를 좀 더 개선해보자.

그동안 UserDao를 테스트하던 main메소드는 엉겁결에 UserDao가 어떤 ConnectionMaker 구현클래스를 사용할지에 대한 책임까지 떠맡고 있는 상황이다.

UserDao와 ConnectionMaker 구현 클래스의 오브젝트를 만드는 것과, 관계를 맺어주는 책임을 분리하자.

```java
public class DaoFactory {
    public UserDao userDao() {
        ConnectionMaker connectionMaker = new DConnectionMaker();
        UserDao userDao = new UserDao(connectionMaker);
        return userDao;
    }
}
```

```java
public static void main(String[] args) throws ClassNotFoundException, SQLException {
    UserDao dao = new DaoFactory.userDao();
    ...
}
```

- DaoFactory 같은 작업이 어플리케이션 전체에 걸쳐 일어난다면 컴포넌트 의존관계에 대한 설계도와 같은 역할을 한다.
- 어플리케이션의 컴포넌트 역할을 하는 오브젝트와 애플리케이션의 구조를 결정하는 오브젝트를 분리했다!
- 수정 전에는 UserDao나 main메서드가 본인이 사용할 오브젝트를 직접 생성하고, 사용하는 등 적극적으로 제어했다.
- 하지만 지금은 자신이 사용할 오브젝트를 직접 선택하지 않는다.
- 제어의 권한을 위임하므로써 수동적인 존재가 됐다. 이를 제어의 역전이라고 한다.
- IoC를 사용하면 설계가 깔끔해지고 유연성과 확장성이 좋아진다.

<br/>

### 1.5 스프링의 IoC

들어가기 전, 용어정리

- 빈/빈 오브젝트/스프링 빈
  - 스프링이 제어권을 가지고 직접 만들고 관계를 부여하는 오브젝트
  - 제어의 역전(스프링 컨테이너가 생성, 관계설정, 사용 등을 제어)이 적용된 오브젝트
  - 스프링 애플리케이션의 모든 오브젝트가 빈은 아니다.
- 빈 팩토리/어플리케이션 컨텍스트/Ioc 컨테이너/스프링 컨테이너
  - 동일하다고 생각하면 됨. (정확하게는 어플리케이션 컨텍스트가 빈 팩토리를 확장한 것)
  - 스프링의 핵심
  - 빈 팩토리 : 빈의 생성과 관계설정같은 제어를 담당하는 IoC오브젝트. (IoC의 기본 기능에 초점)
  - 어플리케이션 컨텍스트 : IoC방식을 따라 만들어진 일종의 빈 팩토리. (IoC 엔진이라는 의미에 더 초점), 빈 팩토리 + 스프링의 부가 서비스
- 설정정보/설정 메타정보
  - 애플리케이션 컨텍스트 또는 빈 팩토리가 IoC를 적용하기 위해 사용되는 메타정보
  - 청사진(blueprints)라고도 함

<br/>

DaoFactory를 스프링의 빈 팩토리가 사용할 수 있는 설정정보로 만들어보자.

```java
@Configuration
public class DaoFactory {
    @Bean
    public UserDao userDao() {
        return new UserDao(connectionMaker());
    }
    
    @Bean
    public ConnectionMaker connectionMaker() {
        return new DConnectionMaker();
    }
}
```

그럼, DaoFactory를 설정정보로 사용하는 애플리케이션 컨텍스트를 만들어보자.

```java
public static void main(String[] args) throws ClassNotFoundException, SQLException {
    ApplicationContext context = new AnnotationConfigApplicationContext(DaoFactory.class);
    UserDao dao = context.getBean("userDao", UserDao.class);
}
```

DaoFactory를 직접 만들어 사용하는 것보다 더 번거로워졌다. 그런데 굳이 스프링을 사용하는 이유가 뭘까?

어플리케이션 컨텍스트의 장점은?

- 구체적인 팩토리 클래스를 알 필요 없다.
  - 추후에 오브젝트 팩토리 클래스가 많아져도 이를 알아야 하거나 직접 사용할 필요가 없다. 
  - 자바코드 대신 XML로 설정정보를 만들 수 있다.
- 오브젝트 생성, 관계설정만 해주는게 아니다.
  -  자동생성, 오브젝트 후처리, 정보의 조합, 설정방식의 다변화, 인터셉팅 등 다양한 기능을 제공한다.
- 빈을 검색하는 다양한 방법을 제공한다.
  - 이름, 타입, 애노테이션 기반으로도 검색 가능

<br/>

어플리케이션 컨텍스트 동작 방식

1. DaoFactory클래스를 설정 정보로 등록
2. @Bean이 붙은 메소드의 이름을 가져와 빈 목록 만듦
3. 클라이언트가 getBean("userDao", UserDao.class)을 호출하면 빈 목록에서 찾아서 userDao()를 실행하여 UserDao 오브젝트를 제공

<br/>

### 1.6 싱글톤 레지스트리와 오브젝트 스코프

애플리케이션 컨텍스트는 싱글톤을 저장하고 관리하는 싱글톤 레지스트리이다.

왜 스프링은 싱글톤으로 빈을 만들까?

- 스프링의 주요 적용 대상이 자바 엔터프라이즈 기술을 사용하는 서버 환경이기 때문.
- 매번 클라이언트에서 요청이 올 때마다 각 로직을 담당하는 오브젝트를 새로 만든다면 감당하기 힘들다
- 그래서 서블릿 클래스당 하나의 오브젝트만 만들어두고, 사용자의 요청을 담당하는 여러 스레드에서 하나의 오브젝트를 공유해 동시에 사용한다

하지만 싱글톤 패턴은 다음과 같은 한계점이 존재한다.

- private 생성자를 갖고 있기 때문에 상속할 수 없다. (다형성 적용 불가)
- 테스트하기 힘들다. (생성되는 방식이 제한적이기 때문에 목으로 대체하기 어렵다)
- 서버환경에서는 싱글톤을 보장하지 못한다. (클래스로더를 어떻게 구상하고 있는지에 따라 보장x, 여러개의 JVM에 분산되는 경우 등)
- 전역상태로 사용되기 쉽다. 객체지향적이지 않음

스프링의 싱글톤 레지스트리 덕분에

- 스태틱 메소드와 private 생성자를 사용하지 않고도 평범한 자바 클래스를 싱글톤으로 활용하게 해준다.
- 평범한 자바 클래스라도 제어권을 컨테이너에게 넘기면 손쉽게 싱글톤 방식으로 만들어져 관리된다.
- 싱글톤으로 사용되야 하는 환경이 아니라면 간단히 오브젝트를 생성해서 사용할 수 있다. -> 테스트 쉬움
- 싱글톤 패턴과 달리 객체지향, 디자인패턴 등을 적용하는데 아무런 제약이 없다.

하지만 조심해야함!

- 멀티스레드 환경에서 여러 스레드가 동시에 접근할 수 있다. 그래서 무상태(stateless)방식으로 만들어야 한다.
- 인스턴스 변수를 사용하더라도 읽기 전용으로 만들어야 한다.
- 파라미터와 로컬변수, 리턴 값 등을 이용하면 스레드에 안전하다(매번 독립적인 공간이 만들어져 저장되기 때문)

<br/>

빈의 스코프

- 빈이 생성되고, 존재하고, 적용되는 범위
- 빈의 기본 스코프는 싱글톤
- 스코프 종류
  - 싱글톤 스코프
  - 프로토타입 스코프(빈을 요청할때마다 새로운 오브젝트 생성함)
  - 요청 스코프, 세션 스코프 등..

<br/>

### 1.7 의존관계 주입(DI)

- 스프링 IoC 기능의 대표적인 동작원리는 주로 의존관계 주입(DI)이라고 불린다. 
- 스프링이 여타 프레임워크와 차별화돼서 제공해주는 기능은 DI라는 용어를 사용할 때 분명히 드러난다. 
- 그래서 지금은 스프링을 DI컨테이너라고 더 많이 불린다.

의존관계 주입(DI)이란?

- 구체적인 의존 오브젝트(DConnectionMaker)와 그것을 사용할 주체(클라이언트 오브젝트, UserDao)를 런타임 시에 연결해주는 작업
- 다음 3가지 조건을 충족해야 한다.
  1. 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않는다. 인터페이스에만 의존하고 있어야 한다.
  2. 런타임 시점의 의존관계는 컨테이너나 팩토리같은 제3의 존재가 결정한다.
  3. 의존관계를 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공(주입)해줌으로써 만들어진다.

스프링이 제공하는 IoC 방법에는 DI만 있는게 아니다. 의존관계 검색(DL)이라는 것도 있다.

UserDao의 생성자를 다음과 같이 만들었다고 하자.

```java
public UserDao() {
    DaoFactory daoFactory = new DaoFactory();
    this.connectionMaker = daoFactory.connectionMaker();
}
```

위와 같이 해도 IoC 개념을 잘 따르고 있다. 다만 DI방식이 아닌 DL방식을 사용했다.(어플리케이션 콘텍스트의 getBean()이 DL)

의존관계 주입(DI) vs 의존관계 검색(DL)

- DI쪽이 코드안에 오브젝트 팩토리 클래스나 스프링 API가 안나오므로 DI쪽이 더 깔끔하다.
- 하지만 애플리케이션 기동 시점에서 적어도 한 번은 DL을 사용해야 한다. (스프링이 제공하기 때문에 직접 구현할 필요 x)
- DL에선 검색을 수행하는 오브젝트는 스프링 빈일 필요가 없는 반면, DI에선 주입받을 오브젝트, 주입할 오브젝트 모두 빈 오브젝트여야 한다. (DI를 원하는 오브젝트는 먼저 자신이 컨테이너가 관리하는 빈이 돼야한다.)

> 단지 외부에서 파라미터로 오브젝트를 넘겨줬다 해서 다 DI가 아니다!
>
> 주입받는 메소드 파라미터가 이미 특정 클래스 타입으로 고정되어 있다면 DI가 일어날 수 없다. 인터페이스 타입이어야 한다.

DI의 장점

- 코드에는 런타임 클래스에 대한 의존관계가 나타나지 않고, 인터페이스를 통해 결합도가 낮은 코드를 만드므로, 의존관계에 있는 대상이 바뀌어도 영향을 받지 않는다.
- 다양한 확장에 자유롭다.

DI의 방법

- 생성자 이용
- 수정자 이용
- 일반 메소드 이용

<br/>

### 1.8 XML을 이용한 설정

스프링은 DaoFactory같은 자바 클래스 이외에도, XML으로도 DI 의존관계 설정정보를 만들 수 있다.

XML의 장점

- 텍스트 파일이라 다루기 쉽다
- 쉽게 이해할 수 있다
- 컴파일 같은 빌드작업이 필요 없다
- 오브젝트 관계가 바뀌는 경우에도 빠르게 변경사항을 반영할 수 있다.

DaoFactory를 XML로 전환해보자.

```java
@Configuration
public class DaoFactory {
    @Bean
    public UserDao userDao() {
        UserDao userDao = new UserDao();
    	userDao.serConnectionMaker(connectionMaker());
    	return userDao;
    }
    
    @Bean
    public ConnectionMaker connectionMaker() {
        return new DConnectionMaker();
    }
}
```

```xml
<beans>
    <bean id="connectionMaker" class="springbook.user.dao.DConnectionMaker" />
    <bean id="userDao" class="springbook.user.dao.UserDao">
    	<property name="connectionMaker" ref="connectionMaker" />
    </bean>
</beans>
```

- @Configuration은 <beans>와 대응
- @Bean은 <bean>과 대응
  - id 애트리뷰트엔 빈의 이름
  - class 애트리뷰트엔 빈의 클래스(메소드의 리턴타입이 아니고 오브젝트를 만들때 사용하는 클래스이름)
- <property>는 의존 오브젝트와의 관계 정의
  - name 애트리뷰트는 프로퍼티의 이름
  - ref 애트리뷰트 수정자 메소드를 통해 주입해줄 오브젝트의 빈 이름(id)
  - 빈 오브젝트가 아니라 값을 주입할 땐 value 애트리뷰트를 사용한다.

그럼 이제 애플리케이션 컨텍스트가 DaoFactory대신 XML 설정정보를 활용하도록 해보자.

```xml
// applicationContext.xml

<?xml version="1.0" encoding="UTF-8"?>
<beans xmlns="http://www.springframework.org/schema/beans"
	xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
	xsi:schemaLocation="http://www.springframework.org/schema/beans 
						http://www.springframework.org/schema/beans/spring-beans-3.0.xsd">
	<bean id="connectionMaker" class="springbook.user.dao.DConnectionMaker" />

	<bean id="userDao" class="springbook.user.dao.UserDao">
		<property name="connectionMaker" ref="connectionMaker" />
	</bean>
</beans>
```

```java
ApplicationContect context = new GenericXmlApplicationContext("applicationContext.xml");
```

- XML을 이용할때는 GenericXmlApplicationContext을 사용한다.
- 인자로는 XML파일의 클래스패스를 넣어준다
- 편리한 기능들이 추가된 ClassPathXmlApplicationContext을 이용할수도 있다.

<br/>

### 1.9 정리

> 스프링이란 '어떻게 오브젝트가 설계되고, 만들어지고, 어떻게 관계를 맺고 사용되는지에 관심을 갖는 프레임워크'이다. 어떤 의존관계를 가질지 결정하는 일은 개발자의 역할이다. 스프링은 단지 원칙을 잘 따르는 설계를 적용하려고 할 때 반복되는 작업을 도와주는 도구임을 잊지 말자.



### 새로 알게 된 부분

- 클래스와 클래스의 관계를 설정한다는 게 아니라 오브젝트와 오브젝트의 관계를 설정해준다는 것이 생각해보면 당연한건데, 읽으면서 뭔가 깨달은 듯한 띵함을 느꼈다.