# 소프트웨어 아키텍쳐 101 (Fundamentals of Software Architecture)

## Part 1 기초

### Chapter 1 서론

- 소프트웨어 아키텍처를 규정하는(바라보는) 데에는 여러가지 측면들이 있다

  - 구조 관점에서 볼수도 있고, 아키텍쳐 특성 관점으로도, 아키텍쳐 결정, 설계 원칙 관점에서 볼수도 있다

  - 구조
    - 시스템이 구현된 아키텍쳐 스타일의 종류
    - 예: 마이크로서비스, 레이어드, 마이크로커널 등등

  - 아키텍쳐 특성
    - 시스템의 기능과 직교하는 시스템의 성공 기준을 결정함
    - 예 : 가용성, 신뢰성, 확장성, 보안, 탄력성, 복구성, 성능 등등

  - 아키텍쳐 결정
    - 시스템 구축에 필요한 규칙들
    - 시스템의 제약조건을 형성하며, 개발자가 해도 되는 것과 하지 말아야 할 것을 알려준다
    - 예 : 레이어드 아키텍쳐에서는 프레젠테이션 레이어에서 데이터베이스를 직접 호출하면 안된다 등

  - 설계 원칙
    - 아키텍쳐 결정이 규칙이라면, 설계 원칙은 가이드라인
    - 예 : MSA에서 성능 향상을 위해 서비스 간 통신은 비동기 메시징을 활용해야 한다

- 아키텍트에게 바라는 핵심적인 요구사항

  - 아키텍쳐 결정을 내린다
    - 아키텍트는 프론트엔드를 리액트로 개발하라고 정해주는 사람이 아니고, 프레임워크중 하나를 선택할 수 있도록 가이드하는 사람이다
  - 아키텍쳐를 지속석으로 분석하고 이를 개선하기 위해 해결방안을 제시한다
  - 최신 트렌드를 계속 유지한다
  - 아키텍쳐 결정의 컴플라이언스를 보장한다
    - 컴플라이언스 보장 : 아키텍트가 정의하고 문서화한 아키텍쳐 결정과 설계 원칙들을 개발팀이 제대로 준수하고 있는지 지속적으로 확인한다는 뜻
  - 다양한 기술, 프레임워크, 플랫폼과 경험에 노출되어야 한다
  - 비즈니스 도메인 지식을 보유한다
  - 대인 관계 기술이 뛰어나다
  - 정치를 이해하고 처세를 잘한다

<br/>

### Chapter 2 아키텍쳐 사고

<br/>

### Chapter 3 모듈성

<br/>

### Chapter 4 아키텍쳐 특성 정의

- 아키텍쳐 특성 목록
  - 운영 아키텍쳐 특성
    - 가용성, 연속성, 성능, 복구성, 신뢰성/안전, 견고성, 확장성
  - 구조 아키텍쳐 특성
    - 설정성, 신장성, 설치성, 활용성/재사용, 지역성, 유지보수성, 이식성, 지원성, 업그레이드성
  - 아키텍쳐 공동 특성
    - 접근성, 보관성, 인증, 인가, 합법성, 프라이버시, 보안, 사용성/성취성
- 아키텍쳐 특성들을 모두 최상으로 반영하는 건 불가능에 가깝기 때문에 최고의 아키텍쳐보다는 나쁜 것중에 제일 나은 아키텍쳐를 선택하는 게 좋다

<br/>

### Chapter 5 아키텍쳐 특성 식별

- 아키텍트는 적어도 3가지 출처(도메인 관심사, 요구사항, 암묵적 도메인 지식)에서 아키텍쳐 특성을 밝혀낸다
- 도메인 관심사에서 아키텍처 특성 도출
  - 도메인 관심사를 올바르게 해석하여 정확한 아키텍쳐 특성을 식별해야 한다
  - 아키텍쳐 특성의 개수에 연연하지 말고 가급적 설계를 단순화하는게 좋다
- 요구사항에서 아키텍처 특성 도출
  - 서드파티의 시스템 안정성, 애플리케이션을 웹으로 할지, 네이티브로 할지 등등
- 암묵적 도메인 지식에서 아키텍처 특성 도출
  - 요구사항 정의서엔 없지만 고려해야 하는 특성들
  - 가용성, 신뢰성, 보안 등

<br/>

### Chapter 6 아키텍쳐 특성의 측정 및 거버넌스

- 아키텍쳐 특성을 정의할때 흔히 발생하는 문제들

  1. 아키텍쳐 특성은 대부분 의미가 모호하다.
  2. 정의가 너무 다양하다. 성능 같은 특성에 대한 정의도 부서마다 달라서 원활하게 소통하기 어렵다
  3. 너무 복합적이다. 예를들어 개발자는 민첩성을 모듈성, 배포성, 시험성 등의 특성으로 세분화할 수 있다

  -> 아키텍쳐 특성을 객관적으로 정의하고 측정 가능하도록 하면 해결된다. 아키텍쳐 특성을 명확하게 정의하고 조직 전체가 동의하면 공통의 아키텍쳐 언어를 확립할 수 있다

- 운영적 측정

  - 특정 요청에 대한 평균 응답시간을 측정할 때, 최대 응답시간도 함께 측정해야 특이점까지 잡아낼 수 있다
  - 성능 목표를 정할 때 아무 수치로 잡기보단, 시간에 따라 어떤 추이를 보이는지 측정하고 통계 모델을 수립 후 정하는 게 좋다. 그래야 통계 모델이 부정확한지, 성능이 안좋은건지 확인할 수 있다

- 구조적 측정

  - 코드의 복잡도는 순환복잡도(CC)라는 메트릭으로 측정할 수 있다

    - CC(순환복잡도) = E(간선) - N(노드) + 2P(연결된 컴포넌트 수)

    - ```c
      public void decision(int ci, int c2) {
        if (c1 < 100)
          return 0;
        else if (c1 + c2 > 500)
          return -1; 
        else
          return 1;
      }
      ```

    - CC = 5 - 4 + 2 = 3

      <img src="../images/순환복잡도.jpeg" alt="순환복잡도" style="zoom:35%;" />

    - 어느 정도의 코드 복잡도가 적당한지는 경우에 따라 다르다. 저자는 5이하로 나와야 짜임새 있는 코드라고 생각함

    - 자바 진영에선 Crap4J로 측정할 수 있고, TDD를 이용하면 CC값도 낮게 나올 수 있다

- 프로세스 측정

  - 민첩성은 시험성, 배포성 등으로 나눌 수 있다
    - 시험성 : 코드 커버리지 등으로 측정 가능
    - 배포성 : 실패 대비 성공률, 배포 소요시간, 배포 시 발생한 이슈/버그 등으로 측정 가능

- 거버넌스
  - 아키텍트가 아키텍쳐 특성을 확정 후 우선순위를 정하면 개발자들이 이 우선순위를 잘 지킬거라 어떻게 확신할까?
  - 아키텍쳐 거버넌스 : 아키텍트가 영향력을 행사하려는 모든 소프트웨어 개발 프로세스를 포괄함
  - 아키텍쳐 거버넌스의 여러 부분을 자동화하기 위해 피트니스 함수를 사용함
  
- 피트니스 함수
  - 피트니스 함수 : 결과가 목표에 얼마나 근접했는지 나타내는 목표 함수
  - 아키텍쳐 피트니스 함수 : 어떤 아키텍쳐 특성의 객관적인 무결성을 평가하는 모든 메커니즘
  - 사용하는 방법에 따라 메트릭, 모니터, 단위테스트 라이브러리, 카오스 엔지니어링 등 기존의 많은 검증 메커니즘과 중첩되는 부분이 있음
  - 모듈성의 다양한 측면을 테스트하는 피트니스 함수 예
    1. '순환 의존성' 피트니스 함수
       - 순환 의존성이 생기면 모듈성이 떨어진다
       - JDepend라는 메트릭 도구로 순환참조가 존재하면 테스트가 실패하도록 할 수 있다
    2. '메인 시퀀스로부터의 거리' 피트니스 함수
       - JDepend로 수용 가능한 임계치를 설정하고 클래스가 이 범위를 벗어나면 테스트가 실패하도록 할 수 있다
       - ArchUnit으로 개발자들이 레이어드 아키텍쳐를 잘 지키는지 확인할 수 있다
  - 또 다른 예 : 넷플릭스의 카오스 멍키, 시미안 아미

<br/>

### Chapter 7 아키텍쳐 특성 범위

<br/>

### Chapter 8 컴포넌트 기반 사고

- 최상위 아키텍쳐를 분할하는 두가지 방법
  1. 기술 분할 : 기술적인 능력으로 최상위 아키텍쳐를 분할
     - 장점
       - 커스텀 코드가 명확하게 분리된다
     - 단점
       - 전역 커플링이 높다
       - 일반적으로 데이터 레벨의 커플링이 높다
  2. 도메인 분할 : 도메인으로 최상위 아키텍쳐를 분할
     - 장점
       - 메시지 흐름이 문제 영역과 일치한다
       - 데이터와 컴포넌트를 분산 아키텍쳐로 옮기기 쉽다
     - 단점
       - 유저 정의 코드가 여기저기 널려 있다
- 컴포넌트 식별 흐름
  - <img src="../images/컴포넌트 식별 주기.jpg" alt="컴포넌트 식별 주기" style="zoom:30%;" />
  - 초기 컴포넌트 식별
  - 요구사항을 컴포넌트에 할당
    - 컴포넌트에 요구사항(또는 유저스토리)을 대입해서 잘 맞는지 확인한다
  - 역할 및 책임 분석
    - 세분도(얼마나 쪼개야 할지)가 적합한지 확인
  - 아키텍쳐 특성 분석
    - 컴포넌트에 요구사항을 대입할 때 아키텍트는 앞서 식별한 아키텍쳐 특성들이 컴포넌트 분할 및 세분도에 어떤 영향을 미치는지 확인한다
  - 컴포넌트 재구성
    - 개발자들과 함께 컴포넌트 설계를 반복하면서 수정



<br/>

## Part 2 아키텍쳐 스타일

### Chapter 9 기초

<br/>

### Chapter 10 레이어드 아키텍쳐 스타일

- 레이어드 아키텍쳐는 가장 흔한 아키텍쳐 스타일 중 하나
  - 단순, 대중적, 비용도 적어서 모든 애플리케이션의 사실상 표준 아키텍쳐다
  - 처음 코딩을 시작하기에 좋은 선택지
- 일반적으로 4개의 (프레젠테이션, 비즈니스, 퍼시스턴스, 데이터베이스) 표준 레이어로 구성
  - 상황에 따라 레이어를 추가할수도, 통합할수도 있다
    - <img src="../images/물리적 토폴로지의 변형들.jpeg" alt="물리적 토폴로지의 변형들" style="zoom: 25%;" />
  - 프레젠테이션 레이어 : 유저 인터페이스와 브라우저 통신 로직 담당
  - 비즈니스 레이어 : 요청을 받아 알맞은 비즈니스 규칙을 실행하는 역할
  - 퍼시스턴스 레이어
  - 데이터베이스 레이어
- 레이어 격리
  - 중간 레이어를 뛰어넘을 수 있으면 그 레이어는 개방 레이어, 반드시 거쳐야 한다면 폐쇄 레이어
  - 개방, 폐쇄 어떤 게 나은가?
  - 폐쇄하면 레이어 격리를 지원할 수 있다 -> 다른 레이어에 영향을 주지 않고 다른 벤더로 교체할 수 있다
  - 하지만 개방하는게 합리적인 경우도 있다
- 아키텍쳐 싱크홀 안티패턴을 조심해야 한다
  - 요청이 한 레이어에서 다른 레이어로 이동할때 각 레이어가 아무 비즈니스 로직도 처리하지 않고 그냥 통과시키는 안티패턴
  - 전체 요청의 80%가 싱크홀이라면 레이어드 아키텍쳐가 적합하지 않을 수 있다
  - 이 경우 모든 레이어를 개방하여 해결할 수 있지만 변경 관리의 어려움이 가중되는 트레이드오프가 있음을 인식해야 한다
- 레이어드 아키텍쳐의 아키텍쳐 특성 등급
  - 전체 비용, 단순성 :+1: 단, 레이어드 아케텍쳐가 점점 커질수록 이 장점은 빛을 바랜다
  - 배포성, 시험성 :-1: : 간단한 변경에도 전체적으로 다시 배포해야함
  - 신뢰성 😐 : 분산 아키텍쳐에 비해 네트워크 트래픽, 대역폭, 레이턴시 문제는 덜함
  - 탄력성, 확장성 :-1:
  - 성능 😐 : 병렬처리가 거의 안되고, 고성능 시스템에 어울리지 않음
  - 내고장성 :-1: : 모놀리식 배포 때문, 또 부족한 모듈성 때문. 어느 파트에 메모리 부족이 발생하면 어플리케이션 전체적으로 영향을 받음

<br/>

### Chapter 11 파이프라인 아키텍쳐 스타일

<img src="../images/파이프라인 아키텍쳐.jpeg" alt="파이프라인 아키텍쳐" style="zoom:40;" />

- 파이프

  - 한 소스에서 입력을 받아 다른 소스로 출력을 내는, 필터간 통신 채널
  - 성능 상 이유로 보통 단방향, 점대점 방식

- 필터

  - 자기 완비형(다른 서비스 호출x), 다른 필터와 독립적, 일반적으로 무상태성(상태를 보관x)
  - 한 가지 태스크만 수행한다. 복합 태스크는 여러 필터를 붙여서 처리함
  - 필터의 종류
    1. 프로듀서
       - 프로세스의 시작점
       - 아웃바운드만 있어서 소스라고도 함 (들어오는 트래픽은 없고 나가는 트래픽만 있기 때문)
    2. 변환기
       - 입력을 받아 변환 후 아웃바운드 파이프로 전달
       - 함수형 프로그래밍에서의 `map`
    3. 테스터
       - 입력을 받아 하나 이상의 기준에 대해 테스트를 하고 필요시 결과 생산
       - 함수형 프로그래밍에서의 `reduce`
    4. 컨슈머
       - 프로세스의 끝
       - 파이프라인 최종 결과를 데이터베이스에 저장하거나 유저 인터페이스 화면에 표시

- 예시

  - 전자 데이터 교환 도구, ETL(추출, 변환, 적재)도구, 아파치 카멜 등에서 쓰임

  - 다양한 서비스의 원격 계측 정보를 카프카에 스트리밍하는 예제

    <img src="../images/파이프라인 아키텍쳐 예.jpeg" alt="파이프라인 아키텍쳐 예" style="zoom:40%;" />

    - 이 예제는 파이프라인 아키텍쳐의 확장성을 잘 보여줌
    - 데이터베이스 접속 대기시간을 데이터베이스에 전달해야 할 경우 가동시간 필터 다음에 테스트 필터를 하나 추가하면 된다

- 파이프라인 아키텍쳐의 아키텍쳐 특성 등급

  - 전체 비용, 단순성 :+1: : 모놀리식에 가깝고 필터간에 독립적이기 때문에 분산 아키텍쳐에 비해 단순하고, 유지보수 비용도 적게 든다.
  - 배포성, 시험성 😐 : 간단한 변경에도 전체적으로 다시 배포해야함. 하지만 필터를 통한 모듈성이 더 우수하므로 레이어드 아키텍쳐보다는 조금 나음
  - 신뢰성 😐 : 분산 아키텍쳐에 비해 네트워크 트래픽, 대역폭, 레이턴시 문제는 덜함
  - 탄력성, 확장성 :-1: : 모놀리식 배포 때문에
  - 내고장성 :-1: : 모놀리식 배포 때문, 또 부족한 모듈성 때문. 어느 파트에 메모리 부족이 발생하면 어플리케이션 전체적으로 영향을 받음

<br/>

### Chapter 12 마이크로커널 아키텍쳐 스타일

- 보통 서드파티를 설치할 수 있는 애플리케이션에 적합해서 플러그인 아키텍쳐라고도 함

- 코어 시스템과 플러그인 컴포넌트로 구성된 비교적 단순한 모놀리식 아키텍쳐이다

  - 코어 시스템
    - 시스템을 실행시키는데 필요한 최소한의 기능으로 정의한다
  - 플러그인 컴포넌트
    - 특수 처리 로직, 부가 기능등이 구현된 스탠드얼론 컴포넌트
    - 이상적인 플러그인 컴포넌트는 상호 독립적이고 의존성이 없다
  - 새로운 플러그인이 생긴다면 새 플러그인은 구현하고 레지스트리를 업데이트하면 된다

- 플러그인 컴포넌트와 코어 시스템은 일반적으로 점대점 통신을 한다

- 레지스트리

  - 코어 시스템이 어떤 플러그인을 사용할 수 있는지, 그 플러그인을 가져오려면 어떻게 해야 하는지 알기 위해 경유하는 곳
  - 플러그인 명칭, 데이터 계약 등등

- 플러그인 컴포넌트와 코어 시스템간의 계약

  - 예 : 전자 제품 재활용 애플리케이션에서의 계약 (java)

  - ```java
    public interface AssessmentPlugin { 
      public AssessmentOutput assess(); // 플러그인 컴포넌트가 출력하리라 기대하는 데이터
      public String register();
      public String deregister();
    }
    
    public class AssessmentOutput { 
      public String assessmentReport; // 감정 리포트의 세부내용을 이해하는건 코어시스템의 책임이 아니므로 String!
      public Boolean resell;
      public Double value;
      public Double resellPrice;
    }
    ```

- 예

  - 이클립스 IDE, PMD, 지라, 젠킨스
  - 크롬, 파이어폭스 등 웹브라우저
  - 보험금 청구건을 처리하는 보험 회사 시스템, 세무 신고 소프트웨어 등

<br/>

### Chapter 13 서비스 기반 아키텍쳐 스타일

<br/>

### Chapter 14 이벤트 기반 아키텍쳐 스타일

- 이벤트 기반 아키텍쳐 스타일은 확장성이 뛰어난 고성능 애플리케이션 개발에 널리 쓰이는 비동기 분산 아키텍쳐 스타일이다

- 이벤트 기반 아키텍쳐의 주요 토폴로지는 2개
  1. 브로커 토폴로지 : 신속한 응답과 동적인 이벤트 처리 제어가 필요할때
  2. 중재자 토폴로지 : 이벤트 처리 워크플로를 제어해야 할 경우
  
- 브로커 토폴로지
  
  - 중앙에 이벤트 중재자가 없다
  
  - 4가지 기본 아키텍쳐 컴포넌트로 구성된다 : 시작 이벤트, 이벤트 브로커, 이벤트 프로세서, 처리 이벤트
  
  - 예 : 서점의 주문 입력 시스템
  
    - <img src="../images/broker_topology_example.jpeg" alt="broker_topology_example" style="zoom:80%;" />
    - 모든 이벤트 프로세서가 고도로 분리되어 있고 서로 독립적으로 움직인다
    - 중간에 처리가 실패해도 다른 파트는 알지 못한다
  
  - | 장점                          | 단점                                                         |
    | ----------------------------- | ------------------------------------------------------------ |
    | 이벤트 프로세서가 디커플링 됨 | 시작 이벤트와 연관된 전체 워크플로를 제어할 수 없다          |
    | 확장성 높음                   | 중간에 처리가 실패해도 다른 파트는 알지 못하므로 에러 처리가 힘들다 |
    | 응답성 우수함                 | 복구성                                                       |
    | 성능 우수함                   | 비즈니스 트랜잭션을 재시작하는 기능이 지원되지 않음          |
    | 내고장성 뛰어남               | 데이터 비일관성                                              |
  
- 중재자 토폴로지

  - 시작 이벤트, 이벤트 큐, 이벤트 중재자, 이벤트 채널, 이벤트 프로세서로 구성됨

  - 브로커 토폴로지와 달리 중재자 토폴로지에서는..

    - 시작 이벤트가 시작 이벤트 큐를 거쳐 이벤트 중재자로 전달된다
    - 이벤트 프로세서가 다른 프로세서에게 자신이 한 일을 알리지 않는다

  - 예 : 위와 동일

    - ![mediator_topology_example](../images/mediator_topology_example.jpeg)

    - 중재자 컴포넌트는 워크플로에 대해 잘 알고 있고 통제를 한다

    - 중재자는 이벤트 상태를 유지하면서 필요시 에러 처리, 복구, 재시작을 할 수 있다

    - | 장점          | 단점                       |
      | ------------- | -------------------------- |
      | 워크플로 제어 | 이벤트 프로세서가 커플링됨 |
      | 에러 처리     | 확장성 낮음                |
      | 복구성        | 성능 낮음                  |
      | 재시작 능력   | 내고장성 좋지 않음         |
      | 데이터 일관성 | 워크플로 모델링 복잡함     |

- 중재자 vs 브로커

  - 중재자 토폴로지의 이벤트는 일어나야 할 일 -> 반드시 처리해야함
  - 브로커 토폴로지의 이벤트는 이미 일어난 일 -> 무시해도 됨
  - 워크플로 제어와 에러처리 기능 vs 고성능과 확장성 어떤 게 더 중요한가?
    - 전자가 더 중요하면 중재자 토폴로지,
    - 후자가 더 중요하면 브포커 토폴로지

- 워크플로 이벤트 패턴으로 비동기 워크플로에서 에러 처리 문제를 해결할 수 있다

  - <img src="../images/workflow_event_pattern.jpeg" alt="workflow_event_pattern" style="zoom:50%;" />


<br/>

## Part 3 테크닉과 소프트 스킬