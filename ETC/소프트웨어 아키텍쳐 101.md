# 소프트웨어 아키텍쳐 101 (Fundamentals of Software Architecture)

## Part 1 기초

### Chapter 1 서론

- 소프트웨어 아키텍처를 규정하는(바라보는) 데에는 여러가지 측면들이 있다

  - 구조 관점에서 볼수도 있고, 아키텍쳐 특성 관점으로도, 아키텍쳐 결정, 설계 원칙 관점에서 볼수도 있다

  - 구조
    - 시스템이 구현된 아키텍쳐 스타일의 종류
    - 예: 마이크로서비스, 레이어드, 마이크로커널 등등

  - 아키텍쳐 특성
    - 시스템의 기능과 직교하는 시스템의 성공 기준을 결정함
    - 예 : 가용성, 신뢰성, 확장성, 보안, 탄력성, 복구성, 성능 등등

  - 아키텍쳐 결정
    - 시스템 구축에 필요한 규칙들
    - 시스템의 제약조건을 형성하며, 개발자가 해도 되는 것과 하지 말아야 할 것을 알려준다
    - 예 : 레이어드 아키텍쳐에서는 프레젠테이션 레이어에서 데이터베이스를 직접 호출하면 안된다 등

  - 설계 원칙
    - 아키텍쳐 결정이 규칙이라면, 설계 원칙은 가이드라인
    - 예 : MSA에서 성능 향상을 위해 서비스 간 통신은 비동기 메시징을 활용해야 한다

- 아키텍트에게 바라는 핵심적인 요구사항

  - 아키텍쳐 결정을 내린다
    - 아키텍트는 프론트엔드를 리액트로 개발하라고 정해주는 사람이 아니고, 프레임워크중 하나를 선택할 수 있도록 가이드하는 사람이다
  - 아키텍쳐를 지속석으로 분석하고 이를 개선하기 위해 해결방안을 제시한다
  - 최신 트렌드를 계속 유지한다
  - 아키텍쳐 결정의 컴플라이언스를 보장한다
    - 컴플라이언스 보장 : 아키텍트가 정의하고 문서화한 아키텍쳐 결정과 설계 원칙들을 개발팀이 제대로 준수하고 있는지 지속적으로 확인한다는 뜻
  - 다양한 기술, 프레임워크, 플랫폼과 경험에 노출되어야 한다
  - 비즈니스 도메인 지식을 보유한다
  - 대인 관계 기술이 뛰어나다
  - 정치를 이해하고 처세를 잘한다

<br/>

### Chapter 2 아키텍쳐 사고

<br/>

### Chapter 3 모듈성

<br/>

### Chapter 4 아키텍쳐 특성 정의

- 아키텍쳐 특성 목록
  - 운영 아키텍쳐 특성
    - 가용성, 연속성, 성능, 복구성, 신뢰성/안전, 견고성, 확장성
  - 구조 아키텍쳐 특성
    - 설정성, 신장성, 설치성, 활용성/재사용, 지역성, 유지보수성, 이식성, 지원성, 업그레이드성
  - 아키텍쳐 공동 특성
    - 접근성, 보관성, 인증, 인가, 합법성, 프라이버시, 보안, 사용성/성취성
- 아키텍쳐 특성들을 모두 최상으로 반영하는 건 불가능에 가깝기 때문에 최고의 아키텍쳐보다는 나쁜 것중에 제일 나은 아키텍쳐를 선택하는 게 좋다

<br/>

### Chapter 5 아키텍쳐 특성 식별

- 아키텍트는 적어도 3가지 출처(도메인 관심사, 요구사항, 암묵적 도메인 지식)에서 아키텍쳐 특성을 밝혀낸다
- 도메인 관심사에서 아키텍처 특성 도출
  - 도메인 관심사를 올바르게 해석하여 정확한 아키텍쳐 특성을 식별해야 한다
  - 아키텍쳐 특성의 개수에 연연하지 말고 가급적 설계를 단순화하는게 좋다
- 요구사항에서 아키텍처 특성 도출
  - 서드파티의 시스템 안정성, 애플리케이션을 웹으로 할지, 네이티브로 할지 등등
- 암묵적 도메인 지식에서 아키텍처 특성 도출
  - 요구사항 정의서엔 없지만 고려해야 하는 특성들
  - 가용성, 신뢰성, 보안 등

<br/>

### Chapter 6 아키텍쳐 특성의 측정 및 거버넌스

- 아키텍쳐 특성을 정의할때 흔히 발생하는 문제들

  1. 아키텍쳐 특성은 대부분 의미가 모호하다.
  2. 정의가 너무 다양하다. 성능 같은 특성에 대한 정의도 부서마다 달라서 원활하게 소통하기 어렵다
  3. 너무 복합적이다. 예를들어 개발자는 민첩성을 모듈성, 배포상, 시험성 등의 특성으로 세분화할 수 있다

  -> 아키텍쳐 특성을 객관적으로 정의하고 측정 가능하도록 하면 해결된다. 아키텍쳐 특성을 명확하게 정의하고 조직 전체가 동의하면 공통의 아키텍쳐 언어를 확립할 수 있다

- 운영적 측정

  - 특정 요청에 대한 평균 응답시간을 측정할 때, 최대 응답시간도 함께 측정해야 특이점까지 잡아낼 수 있다
  - 성능 목표를 정할 때 아무 수치로 잡기보단, 시간에 따라 어떤 추이를 보이는지 측정하고 통계 모델을 수립 후 정하는 게 좋다. 그래야 통계 모델이 부정확한지, 성능이 안좋은건지 확인할 수 있다

- 구조적 측정

  - 코드의 복잡도는 순환복잡도(CC)라는 메트릭으로 측정할 수 있다

    - CC(순환복잡도) = E(간선) - N(노드) + 2P(연결된 컴포넌트 수)

    - ```c
      public void decision(int ci, int c2) {
        if (c1 < 100)
          return 0;
        else if (c1 + c2 > 500)
          return -1; 
        else
          return 1;
      }
      ```

    - CC = 5 - 4 + 2 = 3

      <img src="../images/순환복잡도.jpeg" alt="순환복잡도" style="zoom:35%;" />

    - 어느 정도의 코드 복잡도가 적당한지는 경우에 따라 다르다. 저자는 5이하로 나와야 짜임새 있는 코드라고 생각함

    - 자바 진영에선 Crap4J로 측정할 수 있고, TDD를 이용하면 CC값도 낮게 나올 수 있다

- 프로세스 측정

  - 민첩성은 시험성, 배포성 등으로 나눌 수 있다
    - 시험성 : 코드 커버리지 등으로 측정 가능
    - 배포성 : 실패 대비 성공률, 배포 소요시간, 배포 시 발생한 이슈/버그 등으로 측정 가능

- 거버넌스
  - 아키텍트가 아키텍쳐 특성을 확정 후 우선순위를 정하면 개발자들이 이 우선순위를 잘 지킬거라 어떻게 확신할까?
  - 아키텍쳐 거버넌스 : 아키텍트가 영향력을 행사하려는 모든 소프트웨어 개발 프로세스를 포괄함
  - 아키텍쳐 거버넌스의 여러 부분을 자동화하기 위해 피트니스 함수를 사용함
- 피트니스 함수
  - 피트니스 함수 : 결과가 목표에 얼마나 근접했는지 나타내는 목표 함수
  - 아키텍쳐 피트니스 함수 : 어떤 아키텍쳐 특성의 객관적인 무결성을 평가하는 모든 메커니즘
  - 사용하는 방법에 따라 메트릭, 모니터, 단위테스트 라이브러리, 카오스 엔지니어링 등 기존의 많은 검증 메커니즘과 중첩되는 부분이 있음
  - 모듈성의 다양한 측면을 테스트하는 피트니스 함수 예
    1. '순환 의존성' 피트니스 함수
       - 순환 의존성이 생기면 모듈성이 떨어진다
       - JDepend라는 메트릭 도구로 순환참조가 존재하면 테스트가 실패하도록 할 수 있다
    2. '메인 시퀀스로부터의 거리' 피트니스 함수
       - JDepend로 수용 가능한 임계치를 설정하고 클래스가 이 범위를 벗어나면 테스트가 실패하도록 할 수 있다



<br/>

### Chapter 7 아키텍쳐 특성 범위

<br/>

### Chapter 8 컴포넌트 기반 사고

## Part 2 아키텍쳐 스타일

## Part 3 테크닉과 소프트 스킬