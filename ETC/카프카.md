자료

- https://youtu.be/0Ssx7jJJADI
- https://youtu.be/geMtm17ofPY
- https://youtu.be/xqrIDHbGjOY

# 카프카 개요

## 카프카?

- 스트리밍을 처리하기 위한 플랫폼(분산 이벤트 기반)
- 고성능

## 카프카 기본 구조

![kafka1](../images/kafka1.png)

- 카프카 클러스터
  - 메시지 저장소
  - 여러개의 브로커로 구성됨
  - 브로커(각각의 서버라고 보면 됨)들이 메시지를 나눠서 저장하고, 장애나면 대체도 하고 등등 많이함
- 주키퍼 클러스터
  - 카프카 클러스터를 관리하기 위한 용도
  - 주키퍼 속에 카프카 클러스터와 관련된 정보가 기록되고 관리됨
- 프로듀서
  - 카프카 클러스터에 메시지를 보내는 것
- 컨슈머
  - 메시지를 카프카에서 읽어옴

## 토픽과 파티션

- 토픽
  - 메시지를 저장하는 단위
  - 메시지를 구분하기 위한 용도
  - 폴더, 메일함과 유사함
  - 1개의 토픽은 1개 이상의 파티션으로 구성
- 파티션
  - 메시지를 저장하는 물리적인 파일

![kafka2](../images/kafka2.png)

프로듀서와 컨슈머는 토픽을 기준으로 메시지를 주고받음

## 파티션과 오프셋, 메시지 순서

- 오프셋 : 파티션 내에서 각 메시지 저장 위치
- 프로듀서가 넣은 메시지는 파티션의 맨 뒤에 추가
- 컨슈머는 오프셋 기준으로 메시지를 순서대로 읽음
- 메시지는 삭제되지 않고 설정에 따라 일정 시간이 지난 후 삭제됨
- 한 파티션 내에서만 메시지 순서 보장

## 한 토픽에 여러 파티션이 있다는데, 프로듀서는 어떤 파티션에 메시지를 저장하냐?

- 라운드 로빈으로 저장하거나, 키를 이용해서 파티션을 선택함
- 프로듀서가 카프카에 메시지를 전송할때, 토픽 뿐만 아니라 키도 지정할 수 있음
- 같은 키 -> 같은 파티션 -> 순서 보장

## 여러 파티션과 컨슈머

![kafka3](../images/kafka3.png)

- 컨슈머는 컨슈머 그룹에 속함. 컨슈머를 브로커에 연결할때 그룹을 지정해야 함

- 1 파티션에는 컨슈머그룹의 1 컨슈머에만 연결 가능. 컨슈머그룹 내의 컨슈머들과 연결되는 파티션은 겹치면 안됨

  예시

  - 컨슈머그룹A 안의 컨슈머1, 2는 p0를 공유할 수 없다
  - 컨슈머그룹A 안의 컨슈머1, 2는 p1를 공유할 수 없다
  - 컨슈머1, 2는 p0, p1을 나눠 가져야함

## 성능

- 파티션 파일은 OS 페이지 캐시 사용
  - 파일 IO가 메모리에서 처리되기 때문에 빠름
  - 서버에서 페이지캐시를 카프카만 사용해야 성능에 유리
- Zero Copy
  - 디스크에서 데이터를 읽어다가 네트워크로 보내는 속도가 빨라짐
- 컨슈머 추적을 위해 브로커가 하는 일이 비교적 단순
  - 브로커는 컨슈머와 파티션 간 매핑을 관리함
  - 메시지 필터, 메시지 재전송과 같은 일은 프로듀서, 컨슈머가 직접 해야하고 브로커가 하지 않음
- 묶어서 보내고, 묶어서 받기(batch) -> 낱개 처리보다 처리량 증가
  - 프로듀서 : 일정 크기만큼 메시지를 모아서 전송 가능
  - 컨슈머 : 최소 크기만큼 메시지를 모아서 조회 가능
- 처리량 증대(확장)가 쉬움
  - 1개 장비의 용량 한계 -> 브로커 추가, 파티션 추가
  - 컨슈머가 느림 -> 컨슈머 추가 (+ 파티션 추가)
  - ![kafka4](../images/kafka4.png)

## 리플리카 - 복제

장애가 났을때 대체하기 위해서 리플리카라는 것을 사용함

- 리플리카 : 파티션의 복제본
  - 복제수(replication factor) 만큼 파티션의 복제본이 각 브로커에 생김
  - 토픽을 생성할때 복제수를 2로 지정하면 동일한 데이터를 갖고 있는 파티션이 서로 다른 브로커에 2개가 생김
- 여러 파티션들은 리더와 팔로워로 구성
  - 프로듀서와 컨슈머는 리더를 통해서만 메시지 처리
  - 팔로워는 리더로부터 복제
- 장애 대응
  - 리더가 속한 브로커 장애 시 다른 팔로워가 리더가 됨
  - ![kafka5](../images/kafka5.png)

