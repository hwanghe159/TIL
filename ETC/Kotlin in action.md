# Kotlin in action

## 1장. 코틀린이란 무엇이며, 왜 필요한가?

- 코틀린 맛보기

  ```kotlin
  data class Person(val name: String, val age: Int? = null)
  
  fun main(args: Array<String>) {
      val people = listOf(Person("영희"), Person("철수", age = 20))
      val oldest = people.maxByOrNull { it.age ?: 0 }
      println("나이가 가장 많은 사람: $oldest") // 결과 -> 나이가 가장 많은 사람: Person(name=철수, age=20)
  }
  ```

  - `name`, `age`를 갖고 있는 데이터 클래스 `Person` 정의
  - `age`의 디폴트 값은 null (`?`으로 디폴트값 지정 가능)
  - null인 경우 지정된 값 반환하는 엘비스 연산자(`?:`)

- 코틀린의 주요 특성

  - 자바가 실행되는 모든 곳이 대상 플랫폼이다
    - 서버상의 코드(백엔드), 안드로이드 모바일 애플리케이션
    - 다른 환경에서도 잘 동작한다
      - 인텔의 멀티OS엔진을 사용하면 iOS디바이스 에서 실행 가능
      - 토네이도FX, 자바FX등과 함께 사용하여 데스크탑 애플리케이션 작성 가능
      - 자바스크립트로 코틀린 커파일 가능 -> 브라우저나 노드에서 실행 가능
  - 정적 타입 지정 언어다
    - 정적 타입 지정 언어란? 모든 프로그램 구성 요소의 타입을 컴파일 시점에 알 수 있고 프로그램 안에서 객체의 필드나 메소드를 사용할 때마다 컴파일러가 타입을 검증해주는 언어
    - 코틀린 컴파일러는 문맥으로부터 변수 타입을 자동으로 유추할 수 있다(= 타입 추론)
      - `var x = 1` 으로 작성하면 `x` 가 `Int`임을 자동으로 알아낸다
      - 직접 타입을 지정하지 않아도 된다
    - 정적 타입 언어의 장점은?
      1. 메소드 호출이 빠르다 (실행 시점에 어떤 메소드를 호출할 지 알아내는 과정이 필요 없으므로)
      2. 신뢰할 수 있다 (컴파일 시점에 정확성을 검증하기 때문에 실행 시점에 오류로 중단될 가능성이 적어진다)
      3. 유지 보수성이 좋다 (코드 상에서 어떤 타입인지 알 수 있기 때문에)
      4. 도구의 지원을 받기 좋다 (타입이 명확하기 때문에 더 정확한 자동 완성 등의 지원을 받기 좋다)
    - 코틀린의 타입 시스템
      - 클래스, 인터페이스, 제네릭스는 모두 자바와 비슷하게 작동한다
      - 널이 될 수 있는 타입(nullable type)을 지원함에 따라 컴파일 시점에 널 포인터 예외가 발생할 수 있는지 검사할 수 있다
      - 함수 타입을 지원한다
  - 함수형 프로그래밍과 객체지향 프로그래밍을 지원한다
    - 함수형 프로그래밍의 핵심 개념
      - 일급 시민인 함수 : 함수를 일반 값처럼 다룰 수 있어서 변수에 저장할수도, 인자로 전달할수도, 함수를 반환할수도 있다
      - 불변성 : 내부가 절대 바뀌지 않는 불변객체로 프로그래밍할 수 있다
      - 부수효과 없음 : 입력이 같으면 항상 같은 출력, 다른 객체의 상태를 변경하지 않음, 바깥 환경과 상호작용하지 않는다
    - 함수형 프로그래밍의 장점
      - 코드가 간결하다 (함수를 값처럼 활용하면 강력한 추상화를 통해 코드 중복을 막을 수 있다)
      - 다중 스레드를 사용해도 안전하다 (불변 데이터 구조를 사용하고 순수함수를 그 데이터 구조에 적용하면 안전하다)
      - 테스트하기 쉽다 (부수효과가 없기 때문에 준비코드 없이 독립적으로 테스트할 수 있다)
    - 코틀린이 지원하는 함수형 프로그래밍
      - 어떤 함수가 다른 함수를 파라미터로 받거나 함수가 새로운 함수를 반환할 수 있다
      - 람다식을 지원한다
      - 데이터 클래스로 불변인 값 객체를 간편하게 만들 수 있는 구문을 제공한다
      - 객체와 컬렉션을 함수형 스타일로 다룰 수 있는 API를 제공한다
      - 함수형 스타일로 코드를 짤 수 있게 지원하지만 강제하지는 않는다
  - 무료 오픈소스
    - 코틀린 관련 모든 도구는 모두 오픈소스

- 코틀린 응용

  - 코틀린 서버 프로그래밍
    - 자바로 작성되는 새로운 기술이나 프레임워크가 쏟아지는 환경에서 자바 코드와 매끄럽게 상호운용할 수 있으므로 코틀린은 서버 프로그래밍에 적합하다
    - 영속성 프레임워크인 익스포즈드를 사용하면 코틀린 코드만으로 쿼리를 실행할 수 있다

  - 코틀린 안드로이드 프로그래밍
    - 흔한 작업을 훨씬 적은 코드로 달성할 수 있고, 때로는 컴파일러가 자동으로 해줘서 전혀 코드를 작성하지 않는 경우도 있다
    - `NullPointerException`을 방지해줘서 "프로세스가 중단됨" 대화상자를 볼 가능성을 줄여준다

- 코틀린의 철학

  1. 실용성

     - 실제 문제를 해결하기 위해 만들어진 언어다
     - 개발자들의 피드백이 최신 코틀린에 적용되어 있다
     - 연구를 위한 언어가 아닌 이미 성공적으로 검증된 해법과 기능에 의존하므로 쉽게 배울 수 있다
     - 특정 프로그래밍 스타일이나 패러다임을 강요하지 않는다
     - intelliJ의 지원이 강력하다

  2. 간결성

     - 문법이 간결하여 읽기 쉽고 쓰기 쉽다
     - 부수적인 요소들(게터, 세터, 생성자 파라미터를 필드에 대입하기 위한 로직 등)을 묵시적으로 제공한다

  3. 안전성

     - JVM에서 실행되기 때문에 메모리 안정성을 보장하고, 버퍼 오버플로를 방지하고, 동적으로 할당된 메모리를 잘못 사용함으로써 발생하는 문제들을 방지할 수 있다

     - 정적 타입 지정 언어이므로 타입 안정성을 보장한다

     - 컴파일 시점 검사를 통해 오류를 방지해준다

     - null이 될 수 없는 값을 추적하여, `NullPointerException`을 방지한다

       ```kotlin
       val s1: String? = null	//null이 될 수 있음
       val s2: String = ""			//null이 될 수 없음
       ```

     - 타입 검사와 캐스트가 한 연산자에 의해 이루어지므로 `ClassCastException`을 방지해준다

       ```java
       // java
       if (value instanceof String) {
         System.out.println(((String) value).toUpperCase());
       }
       
       // kotlin
       if (value is String)
         println(value.toUpperCase())
       ```

  4. 상호운용성

     - 기존 자바 API를 그대로 사용할 수 있다
     - 자바 메서드를 호출하거나 자바 클래스를 상속, 확장하거나 인터페이스를 구현하거나, 자바 어노테이션을 사용할수도 있다
     - IDE로 다음의 동작이 가능하다
       - 자바와 코틀린 코드를 자유롭게 내비게이션 할 수 있다
       - 다른 언어로 작성된 코드에 관계없이 한 단계씩 디버깅 가능하다
       - 자바 메서드를 리팩토링해도 그 메서드와 관련있는 코틀린 코드도 변경된다. 반대도 가능하다

- 코틀린 도구 사용

  - 메이븐, 그레이들, 앤트 등의 빌드 시스템과 호환된다

    - 코틀린 빌드 과정

      <img src="../images/kotlin-build.jpeg" alt="kotlin-build" style="zoom:30%;" />

    - 코틀린 컴파일러로 컴파일한 코드는 코틀린 런타임 라이브러리와 의존하기 때문에 배포할때는 런타임 라이브러리도 함께 배포되어야 한다. 

  - intelliJ IDEA와 안드로이드 스튜디오에 코틀린 플러그인이 기본적으로 포함되어 있다

  - 자바-코틀린 변환기로 잘 작동하는 코틀린 코드를 빠르게 만들 수 있다


<br/>

## 2장. 코틀린 기초

### 기본 요소: 함수와 변수

- Hello, World!

  ```kotlin
  fun main(args: Array<String>) {
    println("Hello, world!")
  }
  ```

  - 함수를 선언할땐 `fun` 키워드
  - 파라미터 이름(`args`) 뒤에 파라미터 타입(`Array<String>`)을 쓴다
  - 함수를 꼭 클래스 안에 넣어야 할 필요가 없다
  - 코틀린 표준 라이브러리는 자바 표준 라이브러리를 간결하게 사용할 수 있도록 감싼 래퍼를 제공한다 (`println`도 그런 함수중 하나)
  - 세미콜론을 붙이지 않아도 된다

- 함수

  - 코틀린 함수의 기본 구조

    <img src="../images/kotlin-function.png" alt="kotlin-function" style="zoom:70%;" />

  - 코틀린의 if는 값을 만들어내지 못하는 문(statement)이 아니고 결과를 만드는 식(expression)이다

  - 위처럼 중괄호로 둘러싸인 함수를 **블록이 본문인 함수**라고 하고, 등호와 식으로 이뤄진 함수를 **식이 본문인 함수**라고 한다

    - 예 : `fun max(a: Int, b: Int): Int = if (a > b) a else b`
    - 식이 본문인 함수는 반환 타입을 생략할 수 있다 (타입 추론 덕분) -> `fun max(a: Int, b: Int) = if (a > b) a else b`

<br/>

## 3장. 함수 정의와 호출

<br/>

## 4장. 클래스, 객체, 인터페이스

<br/>

## 5장. 람다로 프로그래밍

<br/>

## 6장. 코틀린 타입 시스템

<br/>

## 7장. 연산자 오버로딩과 기타 관례

<br/>

## 8장. 고차 함수: 파라미터와 반환 값으로 람다 사용

<br/>

## 9장. 제네릭스

<br/>

## 10장. 애노테이션과 리플렉션

<br/>

## 11장. DSL 만들기

