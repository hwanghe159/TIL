
## Chapter1. 왜 이벤트 기반 마이크로서비스인가?

- 이벤트 기반 마이크로서비스란?
	- 시스템이 이벤트를 생산/소비하는 식으로 서로 통신한다
	- 이벤트는 다른 컨슈머에서도 가져갈 수 있게 보존되고 이 책에서 살펴볼 강력한 패턴들을 가능케 한다
- 이벤트 기반 마이크로서비스를 이해하기 위해선 DDD에 대한 이해가 선행되면 좋다
	- 도메인 : 문제 공간
	- 하위 도메인 : 메인 도메인을 이루는 컴포넌트. 
	- 도메인 모델 : 비즈니스가 문제를 해결하기 위해 사용하는 구성체
	- 경계 콘텍스트 : 하위 도메인과 연관된 논리적 경계. 응집력이 강해야 하고 다른 경계 콘텍스트끼리는 느슨하게 결합해야 한다. 
	- 경계 콘텍스트를 정할땐 비즈니스 요건 중심으로 정해야 한다
	    - 비즈니스 요건 변경 없이 제품의 구현체를 뜯어고치는 경우는 거의 없기 때문에.
	    - 팀별로 느슨하게 결합하며 고도로 응집된 마이크로서비스 구현체를 바꿀 수 있다
	    - 기술 요건에 맞추면 비즈니스 기능을 수행할 책임이 여러 팀으로 분산돼서 뭐 하나 바꾸기 어렵다.
	    - 팀마다 비슷한 코드가 생길 가능성이 있고, 풀스택 전문성을 갖춰야 한다는 트레이드 오프는 있다.
- 콘웨이의 법칙
	- "시스템 구조는 그 시스템을 설계하는 조직의 통신 구조를 그대로 따라간다"
- 조직의 통신 구조가 제품에 미치는 영향 예시
	- 새로운 서비스를 구현해야 하는데, 서비스를 새로 만들까? 기존 서비스에 추가할까?
	    - 옵션1. 서비스를 새로 만든다
		    - 비즈니스 요건이 기존과 많이 차이나면 좋은 선택
		    - 나중에 팀을 나누게 된다면 소유권을 분할하기 좋음
		    - 하지만 원래 DB의 데이터와 동기화하는 방법을 강구해야 한다. 또 DB, 서비스도 2개가 되므로 신경써야 할게 많다
	    - 옵션2. 기존 서비스에 추가한다
		    - 빠르게 구현할 수 있다
		    - 하지만 결합도는 높아지고 응집도와 모듈성은 떨어질 가능성이 있다.
		- 옵션2를 선택하고 1년 후.. 
			- 팀이 커졌고, 2개 팀으로 나누게 되었고, 고민이 생겼다
			- 어느 팀이 어느 데이터를 소유해야 하나? 데이터는 어디에 두어야 하나? 두 팀 모두 값을 변경하는 데이터는 어떻게 처리할까?
	- 이 모든 문제의 근원은 데이터 통신 수단이 취약하고 제대로 정의되지 않았기 때문!
- 이벤트 기반 통신 구조는 위 통신 구조의 대안이다.
	- 이벤트 스트리밍 방식의 데이터 통신 구조에서는 데이터를 생산/소유하는 것 과 데이터에 접근하는 행위가 철저히 분리되기 때문에 서비스는 더이상 요청-응답 API에 얽매이는 일 없다
	- 다른 팀/서비스에서 관심 있는 데이터는 공용 이벤트 스트림 세트에 발행함으로써 데이터의 생산과 소유권을 완전히 분리할 수 있다
	- 도메인 이벤트가 특정 구현체에 의존하지 않기 때문에 비즈니스가 유연해진다
- 이벤트 기반 마이크로서비스의 이점
	- 세분성 : 비즈니스 요건이 바뀌어도 쉽게 재작성할 수 있다
	- 확장성 : 개별 서비스는 필요시 스케일인/아웃이 용이하다
	- 기술 유연성
	- 비즈니스 요건 유연성 : 단위가 작은 마이크로서비스는 소유권을 재조정하기 쉽다
	- 느슨한 결합
	- 지속석 전달(CD) 지원 : 작은 마이크로서비스는 옮기기 쉽고 간편하게 롤백 가능
	- 우수한 테스트 가능성 : 디펜던시가 적어서 테스트할때 모킹하기 쉽고, 코드 커버리지를 유지하기 쉬움
- 위 예에서 이벤트 기반 데이터 통신구조로 바꾼다면...
	- 데이터를 어떻게 동기화할지 고민이 거의 없다. 필요한 데이터를 이벤트 스트림에서 받아오면 된다
- 비동기식 MSA vs 동기식 MSA
	- 비동기식 MSA는 이 책에서 권장하는 이벤트 방식. 동기식 MSA는 API를 통해 소통.
	- 동기식 MSA의 단점
	    - 점대점 결합 : 동기식 MSA는 결국 다른 서비스에 의존할 수 밖에 없기 때문에 나중엔 서비스간 연결이 너무 많아져서 뭐하나 고치기 어려워진다
	    - 의존적 확장 : 한 서비스의 확장 가능 여부는 그 서비스가 의존하는 다른 모든 서비스가 확장 가능한지 연관된다
	    - 서비스 실패 처리 : 의존하는 서비스가 내려가는 예외상황 발생 시 데이터 정합성, 재시도, 복구방안 등 결정을 내려야 한다
	    - API 버저닝과 디펜던시 관리 : 클라이언트가 항상 최신버전의 API로 업그레이드하도록 강제하기 어렵고 데이터 구조가 변경되어야 하는 경우 다수의 서비스에게 API 변경을 요청해야 한다
	    - 데이터 접근이 구현체에 종속된다
	    - 분산 모놀리스
	    - 테스트 : 통합테스트 하려면 의존하는 서비스 모두가 가동중이어야 하므로 통합테스트가 어렵다
	- 동기식 MSA의 장점
		- 사용자 인증, AB테스트 같은 데이터 접근 패턴은 동기식이 더 유리하다
		- 디버깅이 쉽고 가시성이 좋다
		- 동기식 방식에 익숙한 개발자가 더 많아 사람 구하기 더 쉽다
- 사내 아키텍쳐를 100% 이벤트 기반 MSA로 개발하는 회사는 거의 없을것이다. 문제 요건에 따라 동기식, 비동기식을 섞어쓰는 하이브리드형이 표준이 될 것이다

## Chapter2. 이벤트 기반 마이크로서비스 기초

## Chapter3. 통신 및 데이터 규약

## Chapter4. 기존 시스템에 이벤트 기반 아키텍쳐 통합

## Chapter5. 이벤트 기반 처리 기본

## Chapter6. 확정적 스트림 처리

## Chapter7. 상태 저장 스트리밍

## Chapter8. 마이크로서비스 워크플로 구축

## Chapter9. FaaS 응용 마이크로서비스

## Chapter10. 기본 프로듀서/컨슈머 마이크로서비스

## Chapter11. 대용량 프레임워크 마이크로서비스

## Chapter12. 경량 프레임워크 마이크로서비스

## Chapter13. 이벤트 기반 마이크로서비스와 요청-응답 마이크로서비스의 통합

## Chapter14. 지원 도구

## Chapter15. 이벤트 기반 마이크로서비스 테스트

## Chapter16. 이벤트 기반 마이크로서비스 배포

## Chapter17. 총정리