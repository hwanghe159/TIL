# 1부 소개
- 프로그램이 동작하도록 만드는 데에는 엄청난 수준의 지식과 기술이 필요하지 않지만, 제대로 만드는 것은 어렵다
	- 적정 수준의 지식과 기술, 사고력과 통찰력, 헌신이 필요하다
- 제대로 된 소프트웨어를 만들면 아주 적은 인력만으로도 기능 추가 및 유지보수가 가능하다
## 1장 설계와 아키텍처란?
- 좋은 소프트웨어 설계의 목표는? 기능추가 / 유지보수에 투입되는 인력을 최소화하는 것
- 개발자들은 종종 "구현 먼저, 코드 정리는 나중!"라며 자신을 과신한다
- 빨리 가는 유일한 방법은 제대로 가는 것이다
- 아키텍쳐가 엉망이면 생산성은 시간이 갈수록 0에 수렴한다
	- 이걸 막으려면 개발자들은 본인을 과신하지 말고, 엉망진창인 코드를 스스로 책임져야 한다
## 2장 두 가지 가치에 대한 이야기
- 소프트웨어의 두가지 가치 : 행위와 구조
	1. 행위 : 소프트웨어의 기능. 많은 프로그래머가 이것이 할 일의 전부라고 생각한다.
	2. 구조(아키텍쳐) : 반드시 변경하기 쉬어야 한다.
- 개발팀은 아키텍쳐의 중요성을 관리팀에게 설득하는 일을 책임져야 한다. (투쟁해야 한다)

# 2부 벽돌부터 시작하기: 프로그래밍 패러다임
## 3장 패러다임 개요
- 각 패러다임은 프로그램으로부터 어떤 권한을 박달하느냐에 따라 나뉜다.
	- 구조적 -> goto문, 객체지향 -> 함수 포인터, 함수형 -> 할당문
- 더 박탈할 만한 게 없다. 다른 패러다임은 나오지 않을 것이다.
## 4장 구조적 프로그래밍
- 데이크스트라는 goto문이 분할 정복 접근법에 방해되고, 분기/반복으로 대체하면 증명 가능한 다위로까지 모듈을 재귀적으로 세분화하는것이 가능하다는 걸 발견했다
- 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해하여, 분할정복이 가능해졌다
- 구조적 프로그래밍이 가치있는 이유는 반증 가능한 단위를 만들어 낼 수 있기 때문이다
## 5장 객체 지향 프로그래밍
- 객체지향 프로그래밍이란?
	- 데이터와 함수의 조합이다?
	- 실제 세계를 모델링하는 새로운 방법이다?
	- 캡슐화, 상속, 다형성을 지원하는 프로그래밍이다?
- 캡슐화
	- 내부 데이터 구조와 함수가 어떻게 구현되어 있는지 전혀 몰라야 완벽한 캡슐화다. (멤버 변수 등이 변경되어도 재컴파일이 필요없어야 한다)
	- 객체지향이 아닌 언어도 캡슐화를 지킬수 있다
- 상속
	- 객체지향이 아닌 언어에서도 흉내는 낼 수 있다
- 다형성
	- 함수를 가리키는 포인터를 응용한 것.
	- 함수 포인터를 직접 사용하면 위험하다. 객체지향 언어는 언어 차원에서 위험을 막아준다
	- 다형성을 사용하면 플러그인 아키텍쳐를 적용할 수 있다
	- 의존성 역전을 이용하면 소스코드 의존성을 원하는 대로 설정할 수 있다
- 그래서 객체지향 프로그래밍이란?
	- 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
## 6장 함수형 프로그래밍
- 함수형 프로그램에서 변수는 불변이다
- 다수의 쓰레드를 사용하는 프로그램에서 발생하는 동시성 문제(race condition, 데드락, 동시 업데이트)가 발생하지 않는다

# 3부 설계 원칙
- SOLID
	- 좋은 벽돌로 좋은 아키텍쳐를 정의하는 원칙
	- 함수와 데이터 구조를 클래스로 배치하는 방법, 이들 클래스를 결합하는 방법을 설명한다
	- 목적은 중간 수준의 소프트웨어(모듈 수준) 구조가 변경에 유연하고, 이해하기 쉽고, 사용될 수 있는 컴포넌트의 기반이 되는것이 목적이다.
## 7장 SRP: 단일 책임 원칙
- SRP : 하나의 모듈은 하나의 액터(변경되기를 원하는 집단)에 대해서만 책임져야 한다
- SRP를 위반하는 징후들
	1. 우발적 중복
		- `Employee` 클래스에 `calculatePay()`, `reportHours()`, `save()` 메서드가 있다고 가정하자
		- 각각 매우 다른 액터를 책임진다 (CFO, COO, CTO)
		- `calculatePay()`, `reportHours()` 두 메서드가 동일한 알고리즘을 하나의 코드로 공유한다고 가정하자
		- CFO 팀의 요구사항에 의해 그 알고리즘 코드를 수정하면 두 액터에 영향을 끼쳐서 COO팀에 문제를 일으킨다
		- 원인은 뭔가? 서로 다른 액터가 의존하는 코드를 너무 가까이 배치했기 때문
	2. 병합
		- 하나의 클래스 / 메서드가 다른 액터를 책임진다면 병합 시 문제가 발생할 가능성이 높다
		- 병합 시 문제가 발생할 수 있다. 최근 IDE는 뛰어나지만 완벽하지 않다
		- 해결책은? 서로 다른 액터를 책임지는 코드를 서로 분리해야 한다
- 해결책
	- 해결책은 모두 메서드를 각기 다른 클래스로 이동시키는 것이다.
	- 예시1.
		- `calculatePay()`, `reportHours()`, `save()` 을 각각 담당하는 새 클래스 3개를 만든다
		- 아무 메서드도 없는 `EmployeeData` 를 만들어 세 클래스가 공유하도록 한다
		- 각 클래스는 서로를 몰라야 한다
	- 예시2.
		- 예시1에서 세 클래스를 인스턴스화하고 추적해야 하는게 싫다면..
		- 세 클래스 앞단에 세 클래스의 인스턴스를 생성하고 위임하는 역할을 하는 파사드를 만든다 (파사드 패턴)
	- 예시3.
		- 가장 중요한 업무 규칙(`calculatePay()`)을 데이터와 가까이 배치하고 싶다면..
		- Employee 클래스에 `calculatePay()` 를 유지하고,  나머지 메서드들에 대한 파사드 역할을 하도록 한다
## 8장 OCP: 개방-폐쇄 원칙
- OCP : 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다
- 소프트웨어 아키텍펴응 공부하는 가장 근본적인 이유!
- OCP를 클래스와 모듈을 설계할때 도움되는 원칙으로 많이 알고 있지만 아키텍쳐 컴포넌트 수준에서 고려할때 훨씬 중요한 의미를 가진다
- 예시
	- 요구사항
		- 재무제표를 웹 페이지를 보여주는 시스템
		- 웹 페이지에 표시될땐 : 스크롤 가능, 음수는 빨간색으로 출력
		- 흑백 프린터로 출력할땐 : 페이지번호, 머리글/바닥글, 표의 각 열에는 레이블, 음수를 괄호로 감싸야 함 등등..
	- 어떻게 할까?
		- 서로 다른 목적으로 변경되는 요소를 적절하게 분리한다 (SRP)
			- 책임1. 재무 데이터를 계산하여 보고서용 재무 데이터를 생성한다
			- 책임2. 적합한 형태로 표현한다 (웹 or 프린터)
		- 이들 요소 사이에서 의존성을 체계화함으로써 변경량을 최소화한다 (DIP)
			- 책임들 중 하나에서 변경하더라고 다른 하나는 변경되지 않도록 의존성을 조직화해야 한다
			- 어떻게? 덜 중요한 것이 더 중요한 것을 의존하도록!
	- 전체 구조
		- ![ocp example](../images/ocp_example.jpeg)
		- 모든 컴포넌트 관계는 단방향으로 이루어진다 (보호하려는 컴포넌트를 향하도록 그려진다)
			- Interactor는 업무 규칙을 포함하기 때문에 가장 높은 수준으로 설계
			- View -> Presenter -> Controller -> **Interactor** <- Database
			- 다른 어느 컴포넌트의 변경도 Interactor에 영향을 주지 않는다 (최고의 보호를 받는다. 가장 높은 수준)
		- 방향성 제어
			- `FinancialDataGateway` 인터페이스가 없었다면 Interactor -> Database 의존성이 생긴다
			- Interactor <- Database 의존성만 생기도록 의도적으로 DIP를 사용했다
		- 정보 은닉
			- `FinancialReportRequester` 인터페이스는 방향성 제어 목적이 아니라 Controller가 Interactor에 대해서 너무 많이 알지 못하도록 존재한다
			- `FinancialReportRequester` 인터페이스가 없었다면 Controller는 `FinancialEntities`에 대한 추이종속성을 가지게 된다

## 9장 LSP: 리스코프 치환 원칙
- 상위 타입의 인스턴스 자리에 하위 타입을 치환하더라도 문제가 없어야 한다
- 초창기에는 상속을 사용하는 가이드로 간주되었지만, 인터페이스와 구현체에도 적용되는 광범위한 원칙으로 변모해왔다
- LSP를 준수하는 사례의 예
	- License 인터페이스가 calcFee() 메서드를 가지고 있고, PersonalLicense, BusinessLicense 클래스가 구현하고 있음
	- Billing 애플리케이션이 License 인터페이스에 의존성을 가짐
	- LSP를 준수한다. why? Billing 애플리케이션의 행위가 License의 하위타입중 무엇을 사용하는지에 전혀 의존하지 않기때문
- LSP를 준수하지 않는 사례의 예
	- 정사각형 / 직사각형 문제
		- 직사각형을 상위, 정사각형을 하위 클래스로 지정해놓고, 정사각형의 너비or높이 설정 코드에 너비, 높이 동시에 설정하도록 하는 코드를 넣는다면 LSP 위반
	- 택시 파견 서비스 앱
		- 요구사항
			- 고객은 어느 택시업체인지는 신경쓰지 않고 적합한 택시를 찾는다
			- 이용할 택시를 결정하면, 시스템은 REST 서비스를 통해 선택된 택시를 고객 위치로 파견한다
			- 택시 파견 REST 서비스의 URL가 운전기사 테이블에 저장되어 있다 (ex: `purplecab.com/driver/Bob`)
			- 이 URL에 필요한 정보를 붙여서 다음과 같이 호출한다
				- PUT `purplecab.com/driver/Bob`/pickupAddress/24 Maple St./pickupTime/153/destination/ORD
			- 다양한 택시 업체에서 PUT .../pickupAddress/?/pickupTime/?/destination/? 형식을 지켜야 하지만 지키지 않는 업체도 있을 수 있다
		- 어떻게 해야 할까?
			- 형식을 지키지 않는 업체때문에 분기를 넣어야 하나? 나중에 형식을 지키지 않는 업체가 purplecab을 인수하면?
			- 설정용 테이블을 이용해서 해결한다. (ex: url, dispatch_format 컬럼)
## 10장 ISP: 인터페이스 분리 원칙
- ![](../images/ISP.jpeg)
	- User1은 op1만을, User2은 op2만을, User3은 op3만을 사용한다고 가정해보자
	- User1은 op2, op3을 사용하지 않는데도 op2의 소스코드가 변경되면 User1은 재컴파일을 해야 한다
	- op1, op2, op3을 각각 인터페이스 단위로 분리하면 다시 컴파일하고 다시 배포하지 않아도 된다
- ISP는 언어 타입에 따라 영향 정도가 다르다
	- 정적 타입 언어는 import 같은 선언문을 강제하므로 재컴파일/재배포가 필요하다. 
	- 동적 타입 언어는 런타임 추론이 발생하므로 좀 더 유연하다
- 불필요한 짐을 실은 무언가에 의존하면 예상치 못한 문제에 빠진다
## 11장 DIP: 의존성 역전 원칙
- DIP에서 말하는 유연성이 극대화된 시스템이란? 소스코드 의존성이 추상에만 의존하고, 구체에는 의존하지 않는 시스템
	- import 구문은 오직 인터페이스나 추상클래스만을 참조해야 한다는 뜻
	- 하지만 비현실적이다. String 같은 구체 클래스를 의존하지 않을 수 없다. 그래서 OS나 플랫폼같이 안정성 있는 환경에서는 무시한다
	- 변동성이 큰 구체적인 요소는 의존하지 않아야 한다
- DIP 실천법
	1. 변동성이 큰 구체 클래스를 참조하지 말고 추상 인터페이스를 참조하라. 일반적으로 추상 팩토리를 사용하도록 강제한다
	2. 변동성이 큰 구체 클래스로부터 상속받지 말라. 상속은 신중하게 써야 한다
	3. 구체 함수를 오버라이드하지 말라. 의존성을 제거할 수 없게 된다. 차라리 추상 함수로 선언하고, 구현체들에서 각각 구현해야 한다.
	4. 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라(?)
- 추상 팩토리 패턴을 사용해서 DIP 준수하기
	- ![](../images/추상팩토리패턴.jpeg)
	- 목표 : 구체 컴포넌트 -> 추상 컴포넌트 의존성만을 갖도록 하면서 `ConcreteImpl` 인스턴스를 생성해서 사용하기
	- 구체적인 의존성이 하나 있어 DIP에 위배되지만 (`ServiceFactoryImpl` -> `ConcreteImpl`) 모두 없앨 순 없다. DIP를 위반하는 클래스들을 구체 컴포넌트 내부로 모을 수 있어서 OK

# 4부 컴포넌트 원칙
- SOLID 원칙 : 벽과 방에 벽돌을 배치하는 방법
- 컴포넌트 원칙 : 빌딩에 방을 배치하는 방법
## 12장 컴포넌트
- 컴포넌트란?
	- 배포 단위
	- 시스템의 구성요소로 배포할 수 있는 가장 작은 단위
	- 자바 - jar, 루비 - gem, 닷넷 - dll ...
- 컴포넌트로 할 수 있는 것들
	- 여러 컴포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성할 수 있다
	- 여러 컴포넌트를 묶어서 war 같은 단일 아카이브로 만들 수 있다
	- 컴포넌트 각각을 플러그인이나 exe 파일로 만들어서 독립적으로 배포할 수 있다
	- 어쨌든 독립적으로 개발 / 배포가 가능하도록 잘 설계되어야 한다
- 컴포넌트의 역사
	- 소프트웨어 개발 초창기
		- 메모리에서 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했다
		- 라이브러리 함수에 접근하려고 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일했다
		- 이 방식은 컴파일러가 소스코드 전체를 여러번에 걸쳐 읽어야 했지만, 메모리도 너무 작아서 소스코드 전체를 메모리에 로딩할수도 없었다
		- 컴파일 시간을 단축시키기 위해 함수 라이브러리와 소스코드를 애플리케이션 코드로부터 분리했다
		- 애플리케이션과 함수 라이브러리가 점점 커지면서 단편화가 계속되었다
		- 지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일을 수정했다
		- 오직 필요한 함수만 로드할 수 있게 되었다
		- 링킹 로더 탄생
	- 1960말 ~ 1970초
		- 프로그램이 점점 커지고, 링킹 로더가 너무 느려졌다
		- 링킹 로더를 로더와 링커 두 애플리케이션으로 분리하고, 프로그래머가 느린 링커를 담당했다
	- 1980년대
		- C나 다른 고수준 언어를 사용하기 시작했고, 프로그램도 점점 더 커졌다
	- 1980년대 후반
		- 디스크는 작아지고, 놀랄만큼 빨라졌다. 메모리는 굉장히 저렴해졌다.
	- 1990년대 후반
		- 프로그램이 성장하는 속도보다 링크 시간이 줄어드는 시간이 더 빨라지기 시작했다
		- 액티브X와 공유 라이브러리 시대가 열렸고 jar 파일도 등장했다
		- 로드와 링크를 동시에 할 수 있게 됐다
		- 컴포넌트 플러그인 아키텍쳐가 탄생했다
- 런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 컴포넌트다.
- 컴포넌트 플러그인 아키텍쳐를 적용하려면 엄청난 노력를 했어야 했지만, 지금은 기본이 됐다
## 13장 컴포넌트 응집도
- 컴포넌트 응집도와 관련된 세가지 원칙
	1. REP: 재사용/릴리스 등가 원칙 Reuse/Release Equivalence Principle
	2. CCP: 공통 폐쇄 원칙 Common Closure Principle
	3. CRP: 공통 재사용 원칙 Common Reuse Principle
- REP: 재사용/릴리스 등가 원칙
	- 재사용 단위 == 릴리스 단위
	- 릴리즈 번호와 문서가 있어야 개발자들이 업데이트 여부를 파악할 수 있다
	- 단일 컴포넌트는 응집성 높은 클래스와 모듈들로 구성되어야 한다. 컴포넌트를 구성하는 모든 모듈은 서로 공유하는 중요한 테마나 목적이 있어야 한다.
	- 이 원칙으론 컴포넌트로 묶는 방법을 제대로 설명하기 힘들지만, CCP와 CRP로 보완된다
- CCP: 공통 폐쇄 원칙
	- 동일한 이유, 시점에 변경되는 클래스를 같은 컴포넌트로 묶어라. 그 반대의 경우엔 분리하라.
	- 동일한 유형의 변경에 대해 닫혀 있는 클래스들을 묶어라.
	- 컴포넌트 수준의 SRP
	- 물리적/개념적으로 강결합되어 항상 함께 변경되는 클래스들은 하나의 컴포넌트에 속해야 한다
- CRP: 공통 재사용 원칙
	- 컴포넌트 사용자들을 필요하지 않는 것에 의존하게 강요하지 말라
	- 컴포넌트 수준의 ISP
	- A 컴포넌트가 B 컴포넌트를 의존하고 있다면, A 컴포넌트는 B 컴포넌트의 모든 클래스에 대해 의존하는 것이다
	- 같은 컴포넌트에 묶어야 하는 경우? 같이 재사용되는 경향이 있는 클래스와 모듈들
	- 같은 컴포넌트로 묶이면 안되는 경우? 강하게 결합되지 않은 클래스들
- 세 원칙에 대한 다이어그램
	- ![](../images/결합도_원칙들의_균형_다이어그램.jpeg)
	- 각 변의 내용은 마주보는 꼭지점을 포기했을때 감수해야 할 비용.
	- REP와 CCP는 포함 원칙. 컴포넌트를 크게 만든다.
	- CRP는 배제 원칙. 컴포넌트를 작게 만든다.
	- 프로젝트 구조는 시간과 성숙도에 따라 변한다.
		- 프로젝트 초기 : CCP > REP. 개발 가능성 > 재사용성
		- 프로젝트 성숙기 : 점차 왼쪽으로 이동한다
- 결론 : 컴포넌트로 묶고자 할땐 재사용성과 개발 가능성이라는 트레이드오프를 고려해야 한다
## 14장 컴포넌트 결합
- 컴포넌트 사이의 관계를 설명하는 3가지 원칙
	1. ADP(Acyclic Dependencies Principle), 의존성 비순환 원칙
	2. SDP(Stable Dependencies Principle), 안정된 의존성 원칙
	3. SAP(Stable Abstractions Principle), 안정된 추상화 원칙
- 숙취 증후군?
	- 내가 의존하고 있는 무언가의 변경으로 인해 내 작업물이 동작하지 않는 현상
	- 이를 해결하는 두 가지 방법
		1. 주 단위 빌드 : 주 1회 머지하는 시간을 갖는 것. 프로젝트가 커질수록 힘들어진다
		2. 순환 의존성 제거하기
- 컴포넌트 의존성 그래프에 순환이 있으면 안된다 (ADP, 의존성 비순환 원칙)
	- 순환이 발생하면?
		- 하나의 거대한 컴포넌트가 되어버린다
		- 테스트할때에도 어려워진다. 내가 의존하는 컴포넌트가 의존하는 다른 컴포넌트도 빌드하고 통합해야 한다
		- 컴포넌트들을 어느 순서로 빌드해야 올바를지 파악하기 힘들어진다
	- 순환을 끊는 방법
		1. DIP를 적용한다
		2. 순환 중간을 끊고, 새로운 컴포넌트를 만든다. (요구사항이 변경되면 컴포넌트 구조도 변경될 수 있다)
	- 컴포넌트 구조는 하향식으로 설계할 수 없다
		- 컴포넌트는 시스템에서 가장 먼저 설계할 수 있는 대상이 아니다
		- 시스템이 성장하고 변경될때 함께 진화한다
		- 컴포넌트 의존성 다이어그램은 애플리케이션의 기능과는 거의 관련이 없고, 오히려 빌드 가능성과 유지보수성을 보여주는 지도와 같다.
- 덜 안정된 곳에서 더 안정된 곳으로 의존하라 (SDP, 안정된 의존성 원칙)
	- 변경이 쉽지 않은 컴포넌트가 변경이 예상되는 컴포넌트에 의존하며 절대 안된다. 의존성이 생기면 변경하기 어려워진다
	- 안정성? 컴포넌트 안쪽으로 들어오는(fan-in) 의존성이 많아지면 안정적이다. 나가는(fan-out) 의존성이 많아지만 불안정적이다.
	- `I(불안정성) = fan-out / (fan-in + fan-out)` [0, 1] 범위를 갖고, 1에 가까울수록 불안정한 컴포넌트다.
	- 모든 컴포넌트가 안정적일 필요 없고, 둘 다 존재해야 한다.
	- 불안정하도록(변경하기 쉽도록) 설계된 컴포넌트는 `I` 지표가 커야 한다
	- 위반했을때 DIP로 해결할 수 있다
		- Stable 컴포넌트 -> Flexible 컴포넌트 의존이 있을때
		- 사이에 UService 컴포넌트를 두고, US 라는 인터페이스를 두고, Flexible 컴포넌트 내 클래스가 구현하게 한다.
		- Stable 컴포넌트 -> UService 컴포넌트 <- Flexible 컴포넌트 의존성이 된다
- 안정된 정도만큼만 추상화되어야 한다 (SAP, 안정된 추상화 원칙)
	- A(추상화 정도) = Na(추상클래스, 인터페이스 개수) / Nc(클래스개수)
		- 0 = 모두 구체 클래스
		- 1 = 모두 추상클래스, 인터페이스
	- ![배제구역.jpeg](../images/배제구역.jpeg)
		- 고통의 구역
			- 구체적이라 확장할 수 없고, 안정적이어서 변경하기도 어렵다. ex) 데이터베이스 스키마, 구체적인 유틸리티 라이브러리
			- 변동성이 없는 컴포넌트는 (0, 0) 구역에 위치했더라도 해롭지 않다. ex) String 컴포넌트
		- 쓸모없는 구역
			- 최고로 추상적이지만, 누구도 그 컴포넌트에 의존하지 않아 쓸모없고, 폐기물이다.
		- 주계열
			- (0,1)과 (1,0)을 잇는 선분
			- 안정성에 비해 너무 추상적이지 않고, 추상화정도에 비해 너무 불안정하지 않다.
			- 추상화된 수준에 어울릴 정도만 다른 컴포넌트에 의존하며, 구체화된 수준에 어울릴 정도로만 다른 컴포넌트에 의존한다
			- 주계열에 많이 벗어난 컴포넌트는 검토해야 한다. 의존하는 컴포넌트가 없는데도 너무 추상적이거나, 자신에게 의존하는 컴포넌트가 많은데도 너무 구체적일 가능성이 있다.
			- 릴리즈별로 주계열과의 거리(D) 값을 보고, 어느 릴리즈부터 이상한 의존성이 스며들어 왔는지 판단할수도 있다

# 5부 아키텍처
## 15장 아키텍처란?
- 아키텍트란?
	- 코드에서 탈피하여 고수준의 문제에 집중하는 사람이 아니다!
	- 아키텍트는 코드와 동떨어져서는 안된다. 여전히 프로그래머다.
	- 팀원들이 생산성을 극대화시키는 설계를 하도록 이끈다
- 아키텍쳐란?
	- 시스템을 분할하는 방법, 분할된 컴포넌트를 배치하는 방법, 컴포넌트가 서로 의사소통하는 방식에 따라 정해진다
	- 좋은 아키텍쳐는 쉽게 이해하고, 쉽게 개발하며, 쉽게 유지보수하고, 쉽게 배포할 수 있게 해준다
	- 궁극적인 목표는 시스템의 수명과 관련된 비용은 최소화하고, 생산성은 극대화하는 데 있다
- 쉽게 개발할 수 있어야 한다
	- 개발초기, 소수의 인원이라면 모놀리틱이 빠를지 모르지만 다수의 인원이고, 컴포넌트 단위가 잘 분리되어 있지 않으면 개발이 진척되지 않는다
- 쉽게 배포할 수 있어야 한다
- 개발자에게 시스템의 운영 방식을 잘 드러내준다
	- 사실 운영에서 겪는 문제는 하드웨어를 더 투입해서 해결할 순 있다
	- 유즈케이스, 기능, 시스템의 필수 행위를 일급 엔티티로 격상시킴으로써 개발자에게 주요 목표로 인식되도록 한다
- 유지보수가 쉬워야 한다
	- 기존 소프트웨어에 기능을 추가하거나, 수정할때의 위험 부담을 크게 줄일 수 있다
	- 시스템을 컴포넌트로 분리하고, 인터페이스를 두어 서로 격리하면 된다
- 선택사항을 열어두어야 한다
	- 선택사항 = 세부사항
	- 개발 초기에는 DB를 뭘쓸지, 웹서버를 뭘 쓸지, REST로 할지, DI 프레임워크를 적용할지 등을 고려하지 않아도 된다
	- 선택사항을 오랫동안 열어둘 수 있다면 많은 걸 실험, 시도를 해볼 수 있다.
	- 결정을 더이상 연기할 수 없는 순간이 닥쳐온다면, 실험과 시도 덕분에 많은 정보를 획득한 상태일 것이다.
- 장치와 독립적이어야 한다
## 16장 독립성
- 좋은 아키텍쳐는..
	- 시스템의 의도, 유즈케이스를 지원해야 한다
		- 장바구니 애플리케이션이 좋은 아키텍쳐를 갖춘다면, 아키텍쳐 수준에서 장바구니 애플리케이션처럼 보일 것이다.
	- 필요한 처리량과 응답시간을 지키며 운영할 수 있어야 한다
	- 각 팀이 독립적으로 개발할 수 있어야 한다
	- 시스템이 빌드된 후 즉각 배포할 수 있어야 한다 
	- 선택사항을 열어놔야 한다
		- 모든 유스케이스를 알수도 없고, 시시각각 바뀌기 때문에 선택사항을 열어놔야 향후 변경이 필요할때 쉽게 변경할 수 있다
- 유스케이스 자체도 다른 시점에, 다른 이유로 변경된다면 분리해야 한다
	- 분리할 때 적절한 모드를 선택해야 한다.
		1. 소스 수준 (모놀리틱)
			- 모든 컴포넌트가 같은 주소 공간에서 실행되고, 서로 통신할 땐 함수 호출을 사용한다
		2. 배포 수준
			- 분리된 컴포넌트가 독립적으로 배포할 수 있는 단위로 분할되어 있음 (jar)
		3. 서비스 수준 (MSA)
			- 네트워크 패킷을 통해서만 통신
			- 서로 완전히 독립적
	- 어떤 모드를 선택할지에 대한 선택권도 열어둬야 한다
	- 좋은 아키텍쳐는 모놀리틱 -> MSA으로, 혹은 그 반대 방향으로도 되돌릴 수 있어야 한다
- 중복이 발생하면 자동반사적으로 중복을 제거하고 싶은 유횩을 떨쳐내라
	- 진짜 중복과 가짜(우발적) 중복이 있다. 
	- DB 레코드를 그대로 UI까지 전달하지 마라. 이런 건 우발적 중복이다
## 17장 경계: 선 긋기
- 소프트웨어 아키텍쳐는 선(경계)를 긋는 기술이다
- 경계는 소프트웨어 요소를 서로 분리하고, 경계를 기준으로 서로 알지 못하도록 막는다
- 경계는 프로젝트 극초기에 그어지기고 하고, 매우 나중에 그어지기도 한다
	- 초기에 그어지는 경계는 가능한 한 오랫동안 결정을 연기시키기 위해, 이 결정이 핵심적인 업무 로직을 오염시키지 못하게 하려고 그어짐
- 너무 일찍 내려진 결정은 결합(coupling)이 생겨 효율을 떨어뜨릴 수 있다
	- ex) 프레임워크, DB, 웹 서버, 유틸 라이브러리, DI에 대한 결정 등
	- BAD 사례1) 추후에 별개의 장비에서 실행할 것을 너무 빨리 결정해버려서 끝까지 단일 서버에서 실행함에도 불구하고 별개의 장비에서 실행할때를 대비한 작업을 계속 했던 P사 이야기
	- BAD 사례2) SOA를 약속하는 도구들을 너무 일찍 채택한 W사 이야기
	- GOOD 사례) DB에 대한 결정을 미룬 FitNesse 이야기. 나중에 영속성을 구현해야 할 시점이 오자 DB는 필요 없다는 것을 깨닫고, 플랫 파일에 저장함.
- 경계선을 그리면서 컴포넌트 단위로 분할하고, 일부는 핵심 업무 규칙으로, 나머지는 플러그인에 해당한다.
	- 핵심 업무 규칙을 향하도록 배치한다
	- 저수준 세부사항에서 고수준 추상화를 향하도록 배치한다
## 18장 경계 해부학
- 소스코드 의존성 구성을 잘 하면 변경이 전파(재컴파일, 재배포 등)되는 것을 막는 방화벽을 세울 수 있다
- 경계의 형태
	1. 소스 수준 분리 모드 ![경계횡단](../images/경계횡단.jpeg)
		- 그림18.1
			- 저수준 클라이언트가 고수준 서비스를 호출하는 경우
			- 경계 횡단 방향은 오른쪽
			- Data가 호출되는 쪽에 위치한다
		- 그림18.2
			- 고수준 클라이언트가 저수준 서비스를 호출하는 경우
			- 경계 횡단 방향은 왼쪽
			- 런타임 의존성(->방향)은 컴파일타임 의존성(<-방향)과는 반대가 된다
			- Data가 호출하는 쪽에 위치한다
	2. 배포 수준 분리 모드
		- 배포 과정에서만 차이날 뿐, 소스 수준 분리모드와 동일하다
	3. 서비스 수준 분리 모드
		- 물리적 형태를 띠는 가장 강력한 경계
		- 저수준 서비스는 고수준 서비스에 플러그인 되어야 한다
		- 고수준 서비스의 소스코드에는 저수준 서비스를 특정짓는 어떤 정보(URI같은)도 포함돼서는 안된다
## 19장 정책과 수준
- 소프트웨어 시스템이란 정책을 기술한 것이다.
- 하나의 정책은 여러 조그만 정책들로 쪼갤 수 있다
	- 이런 정책들을 신중하게 분리하고 재편성 할줄도 알아야 한다
	- 같은 이유/시점에 변경되는 정책은 동일한 수준에, 다른 이유/시점에 변경되는 정책은 다른 수준에 위치해야 한다
- 재편성된 컴포넌트들은 비순환 방향그래프 구조가 되어야 한다
	- 정점(노드) : 동일한 수준의 정책을 포함하는 컴포넌트
	- 방향이 있는 간선 : 컴포넌트 사이의 의존성 (컴파일 타임의 의존성. java의 경우엔 import문)
	- 좋은 아키텍쳐는 의존성의 방향이 컴포넌트 수준을 기반으로 연결되도록 만들어야 한다. (저 -> 고)
- 수준?
	- 엄밀히 말하자면 '입력과 출력까지의 거리'
	- 입력과 출력 모두로부터 멀어질수록 정책의 수준은 높아진다. 입력과 출력을 다루는 정책이라면 최하위 수준이다.
	- 잘 설계된 간단한 암호화 프로그램 ![잘 설계된 암호화 프로그램](../images/잘_설계된_암호화_프로그램.jpeg)
		- 입력 장치에서 문자를 읽는다 -> 테이블을 참조해서 번역한다 -> 출력장치로 기록한다
		- 번역 컴포넌트는 최고 수준 컴포넌트다 (입출력으로부터 가장 멀리 떨어져 있기 때문)
		- 데이터 흐름과 소스코드 의존성이 일치하지 않는다!
			- 소스코드 의존성은 수준에 따라 결합되어야 한다 (데이터 흐름 기준 X)
		- 코드로 나타내면?
			- 번역 컴포넌트 : Encrypt, CharReader(interface), CharWriter(interface)
			- 그 외 : ConsoleReader(CharReader 구현체), ConsoleWriter(CharWriter 구현체)
## 20장 업무 규칙
- 업무 규칙?
	- 사업적으로 수익을 얻거나 비용을 줄일 수 있는 규칙 / 절차
- 핵심 업무 규칙?
	- 자동화 시스템이 있던 없던, 사업 자체에 핵심적인 업무 규칙
	- ex) 대출에 N%의 이자를 부과하는 은행
- 핵심 업무 데이터?
	- 핵심 업무 규칙에는 보통 데이터를 요구하고, 이때의 데이터
- 엔티티
	- 핵심 규칙 + 핵심 데이터
	- 핵심 엄무 데이터를 직접 포함하거나, 매우 쉽게 접근한다
	- 핵심 업무 규칙을 구현한 함수들로 구성된다
	- DB, UI, 서드파티 프레임워크에 대한 고려사항으로 오염되어서는 절대 안된다
- 유즈케이스
	- 자동화된 시스템을 어떻게 쓰는지?
	- 사용자의 입력, 출력, 그 사이의 처리 단계를 설명한다
	- 어플리케이션에 특화된 업무 규칙을 설명한다
	- 엔티티 내부의 핵심 업무 규칙을 어떻게, 언제 호출할지를 담는다
	- UI를 기술하지 않는다. (웹 기반인지? 콘솔 기반인지? 등..)
	- ex) 은행 직원이 사용하는 어플리케이션에서 "신청자의 신용도가 500보다 낮다면 대출 견적을 제공하지 않는다"는 기능을 제공하는 것
- 엔티티는 고수준, 유즈케이스는 저수준이다
	- 엔티티는 유즈케이스를 모르고, 유즈케이스는 엔티티를 안다 (의존성 방향 : 유즈케이스 -> 엔티티)
	- 유즈케이스는 단일 애플리케이션에 특화되어 있고, 입출력에 보다 가깝게 위치한다
	- 엔티티는 다양한 애플리케이션에서 사용될 수 있도록 일반화된 것이다
- 유즈케이스 객체는 다른 컴포넌트와 주고받는 방식을 몰라야 한다
	- 유즈케이스의 코드가 HTML이나 SQL에 대해 알 수 없어야 한다
	- 유즈케이스의 입/출력 데이터 구조는 어떤것에도 의존하지 않는다(HttpRequest, HttpResponse 같은 표준 인터페이스로부터도 파생되면 안된다)
	- 의존시켜 버리면 나중에 분리하느라, 그리고 수많은 조건문으로 고생하게 될 것이다
## 21장 소리치는 아키텍처
- 당신의 애플리케이션 아키텍쳐는 뭐라고 소리치는가?
	- "헬스케어 시스템이야" 혹은 "재고 관리 시스템이야"라고 소리치는가? 아님 "스프링/하이버네이트야"라고 소리치는가?
- 아키텍쳐는 프레임워크에 대한 것이 아니고, 아키텍쳐를 프레임워크로부터 제공받아서는 절대 안된다
- 좋은 아키텍쳐는 프레임워크 뿐만 아니라 DB, 웹서버 등에 해당 결정을 미룰 수 있도록 한다
- 웹도 아키텍쳐가 아니다. 전달 메커니즘 중 하나이며, 세부사항이다.
- 아키텍쳐를 유즈케이스에 중점을 두어야 하고, 프레임워크가 중심을 차지하지 않도록 해야 한다
- 테스트하기 쉬워야 한다
	- 프레임워크, 웹서버, DB를 전혀 준비하지 않아도 단위 테스트가 가능해야 한다
## 22장 클린 아키텍처
- 지난 수십년간 시스템 아키텍쳐와 관련된 여러 아이디어(육각형 아키텍쳐, DCI, BCE 등..)가 있었지만, 목표는 모두 '관심사의 분리'이다.
	- 소프트웨어를 계층으로 분리하여 관심사의 분리라는 목표를 달성한다
	- 이들 아키텍쳐는 다음의 특징을 지니도록 만든다
		1. 프레임워크 독립성
		2. 테스트 용이성
		3. UI 독립성
		4. 데이터베이스 동립성
		5. 모든 외부 에이전시에 대한 독립성
- ![](../images/클린_아키텍쳐.jpeg)
	- 소스 코드 의존성은 반드시 안쪽(고수준)으로 향해야 한다
		- 바깥쪽은 메커니즘, 안쪽은 정책
		- 내부의 원에 속한 요소는 외부의 원에 선언된 어떤 것에 대해서도 알지 못한다
		- 안쪽일수록 가장 범용적이고 추상화와 정책의 수준은 높아진다
	- 엔티티
		- 전사적인 핵심 업무 규칙을 캡슐화한다
		- 운영 관점에서 특정 애플리케이션에 무언가 변경이 필요하더라도 엔티티 계층에는 절대로 영향을 주어서는 안된다
	- 유스케이스
		- 애플리케이션에 특화된 업무 규칙을 포함한다
		- 엔티티로 들어오고 나가는 데이터 흐름을 조정하며, 엔티티가 목적을 달성하도록 이끈다
		- 운영 관점에서 애플리케이션이 변경되면 유즈케이스가 영향을 받는다
	- 인터페이스 어댑터
		- 프레젠터, 뷰, 컨트롤러같은 일련의 어댑터들로 구성된다
		- 유즈케이스/엔티티에게 가장 편한 데이터 형식과 DB/웹 등에게 가장 편한 데이터 형식 사이에서 변환을 수행한다
		- 이 원 안에 속한 어떤 코드도 데이터베이스에 대해 조금도 알아서는 안된다
	- 프레임워크와 드라이버
		- 모든 세부사항이 위치하는 곳
	- 원은 4개여야만 하나?
		- 더 많은 원이 필요할 수 있지만 소스 코드 의존성은 항상 안쪽을 향한다는 것은 변하지 않는다
	- 경계를 횡단하려면?
		- 그림 22.1의 우측 하단은 제어 흐름이 '컨트롤러 -> 유즈케이스 -> 프레젠터' 인 예시를 보여줌
		- 제어흐름과 의존성의 방향이 반대인 경우, DIP를 사용하여 해결한다
		- 경계를 횡단하는 데이터는 여러 형태일 수 있다 (구조체, DTO, 함수 파라미터, 해시맵, 객체 등..)
			- 엔티티 객체나 DB row 등은 X
- ![](../images/클린_아키텍쳐_자바_예시.jpeg)
	- 
## 23장 프레젠터와 험블 객체  
## 24장 부분적 경계  
## 25장 계층과 경계  
## 26장 메인(Main) 컴포넌트  
## 27장 ‘크고 작은 모든’ 서비스들    
## 28장 테스트 경계  
## 29장 클린 임베디드 아키텍처  


# 6부 세부사항
## 30장 데이터베이스는 세부사항이다  
## 31장 웹은 세부사항이다    
## 32장 프레임워크는 세부사항이다  
## 33장 사례 연구: 비디오 판매 
## 34장 빠져 있는 장