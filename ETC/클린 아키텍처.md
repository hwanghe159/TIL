# 1부 소개
- 프로그램이 동작하도록 만드는 데에는 엄청난 수준의 지식과 기술이 필요하지 않지만, 제대로 만드는 것은 어렵다
	- 적정 수준의 지식과 기술, 사고력과 통찰력, 헌신이 필요하다
- 제대로 된 소프트웨어를 만들면 아주 적은 인력만으로도 기능 추가 및 유지보수가 가능하다
## 1장 설계와 아키텍처란?
- 좋은 소프트웨어 설계의 목표는? 기능추가 / 유지보수에 투입되는 인력을 최소화하는 것
- 개발자들은 종종 "구현 먼저, 코드 정리는 나중!"라며 자신을 과신한다
- 빨리 가는 유일한 방법은 제대로 가는 것이다
- 아키텍쳐가 엉망이면 생산성은 시간이 갈수록 0에 수렴한다
	- 이걸 막으려면 개발자들은 본인을 과신하지 말고, 앙망진창은 코드를 스스로 책임져야 한다
## 2장 두 가지 가치에 대한 이야기
- 소프트웨어의 두가지 가치 : 행위와 구조
	1. 행위 : 소프트웨어의 기능. 많은 프로그래머가 이것이 할 일의 전부라고 생각한다.
	2. 구조(아키텍쳐) : 반드시 변경하기 쉬어야 한다.
- 개발팀은 아키텍쳐의 중요성을 관리팀에게 설득하는 일을 책임져야 한다. (투쟁해야 한다)

# 2부 벽돌부터 시작하기: 프로그래밍 패러다임
## 3장 패러다임 개요
- 각 패러다임은 프로그램으로부터 어떤 권한을 박달하느냐에 따라 나뉜다.
	- 구조적 -> goto문, 객체지향 -> 함수 포인터, 함수형 -> 할당문
- 더 박탈할 만한 게 없다. 다른 패러다임은 나오지 않을 것이다.
## 4장 구조적 프로그래밍
- 데이크스트라는 goto문이 분할 정복 접근법에 방해되고, 분기/반복으로 대체하면 증명 가능한 다위로까지 모듈을 재귀적으로 세분화하는것이 가능하다는 걸 발견했다
- 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해하여, 분할정복이 가능해졌다
- 구조적 프로그래밍이 가치있는 이유는 반증 가능한 단위를 만들어 낼 수 있기 때문이다
## 5장 객체 지향 프로그래밍
- 객체지향 프로그래밍이란?
	- 데이터와 함수의 조합이다?
	- 실제 세계를 모델링하는 새로운 방법이다?
	- 캡슐화, 상속, 다형성을 지원하는 프로그래밍이다?
- 캡슐화
	- 내부 데이터 구조와 함수가 어떻게 구현되어 있는지 전혀 몰라야 완벽한 캡슐화다. (멤버 변수 등이 변경되어도 재컴파일이 필요없어야 한다)
	- 객체지향이 아닌 언어도 캡슐화를 지킬수 있다
- 상속
	- 객체지향이 아닌 언어에서도 흉내는 낼 수 있다
- 다형성
	- 함수를 가리키는 포인터를 응용한 것.
	- 함수 포인터를 직접 사용하면 위험하다. 객체지향 언어는 언어 차원에서 위험을 막아준다
	- 다형성을 사용하면 플러그인 아키텍쳐를 적용할 수 있다
	- 의존성 역전을 이용하면 소스코드 의존성을 원하는 대로 설정할 수 있다
- 그래서 객체지향 프로그래밍이란?
	- 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
## 6장 함수형 프로그래밍
- 함수형 프로그램에서 변수는 불변이다
- 다수의 쓰레드를 사용하는 프로그램에서 발생하는 동시성 문제(race condition, 데드락, 동시 업데이트)가 발생하지 않는다

# 3부 설계 원칙
- SOLID
	- 좋은 벽돌로 좋은 아키텍쳐를 정의하는 원칙
	- 함수와 데이터 구조를 클래스로 배치하는 방법, 이들 클래스를 결합하는 방법을 설명한다
	- 목적은 중간 수준의 소프트웨어(모듈 수준) 구조가 변경에 유연하고, 이해하기 쉽고, 사용될 수 있는 컴포넌트의 기반이 되는것이 목적이다.
## 7장 SRP: 단일 책임 원칙
- SRP : 하나의 모듈은 하나의 액터(변경되기를 원하는 집단)에 대해서만 책임져야 한다
- SRP를 위반하는 징후들
	1. 우발적 중복
		- `Employee` 클래스에 `calculatePay()`, `reportHours()`, `save()` 메서드가 있다고 가정하자
		- 각각 매우 다른 액터를 책임진다 (CFO, COO, CTO)
		- `calculatePay()`, `reportHours()` 두 메서드가 동일한 알고리즘을 하나의 코드로 공유한다고 가정하자
		- CFO 팀의 요구사항에 의해 그 알고리즘 코드를 수정하면 두 액터에 영향을 끼쳐서 COO팀에 문제를 일으킨다
		- 원인은 뭔가? 서로 다른 액터가 의존하는 코드를 너무 가까이 배치했기 때문
	2. 병합
		- 하나의 클래스 / 메서드가 다른 액터를 책임진다면 병합 시 문제가 발생할 가능성이 높다
		- 병합 시 문제가 발생할 수 있다. 최근 IDE는 뛰어나지만 완벽하지 않다
		- 해결책은? 서로 다른 액터를 책임지는 코드를 서로 분리해야 한다
- 해결책
	- 해결책은 모두 메서드를 각기 다른 클래스로 이동시키는 것이다.
	- 예시1.
		- `calculatePay()`, `reportHours()`, `save()` 을 각각 담당하는 새 클래스 3개를 만든다
		- 아무 메서드도 없는 `EmployeeData` 를 만들어 세 클래스가 공유하도록 한다
		- 각 클래스는 서로를 몰라야 한다
	- 예시2.
		- 예시1에서 세 클래스를 인스턴스화하고 추적해야 하는게 싫다면..
		- 세 클래스 앞단에 세 클래스의 인스턴스를 생성하고 위임하는 역할을 하는 파사드를 만든다 (파사드 패턴)
	- 예시3.
		- 가장 중요한 업무 규칙(`calculatePay()`)을 데이터와 가까이 배치하고 싶다면..
		- Employee 클래스에 `calculatePay()` 를 유지하고,  나머지 메서드들에 대한 파사드 역할을 하도록 한다
## 8장 OCP: 개방-폐쇄 원칙
- OCP : 소프트웨어 개체는 확장에는 열려 있어야 하고, 변경에는 닫혀 있어야 한다
- 소프트웨어 아키텍펴응 공부하는 가장 근본적인 이유!
- OCP를 클래스와 모듈을 설계할때 도움되는 원칙으로 많이 알고 있지만 아키텍쳐 컴포넌트 수준에서 고려할때 훨씬 중요한 의미를 가진다
- 예시
	- 요구사항
		- 재무제표를 웹 페이지를 보여주는 시스템
		- 웹 페이지에 표시될땐 : 스크롤 가능, 음수는 빨간색으로 출력
		- 흑백 프린터로 출력할땐 : 페이지번호, 머리글/바닥글, 표의 각 열에는 레이블, 음수를 괄호로 감싸야 함 등등..
	- 어떻게 할까?
		- 서로 다른 목적으로 변경되는 요소를 적절하게 분리한다 (SRP)
			- 책임1. 재무 데이터를 계산하여 보고서용 재무 데이터를 생성한다
			- 책임2. 적합한 형태로 표현한다 (웹 or 프린터)
		- 이들 요소 사이에서 의존성을 체계화함으로써 변경량을 최소화한다 (DIP)
			- 책임들 중 하나에서 변경하더라고 다른 하나는 변경되지 않도록 의존성을 조직화해야 한다
			- 어떻게? 덜 중요한 것이 더 중요한 것을 의존하도록!
	- 전체 구조
		- ![[ocp_example.jpeg]]
		- 모든 컴포넌트 관계는 단방향으로 이루어진다 (보호하려는 컴포넌트를 향하도록 그려진다)
			- Interactor는 업무 규칙을 포함하기 때문에 가장 높은 수준으로 설계
			- View -> Presenter -> Controller -> **Interactor** <- Database
			- 다른 어느 컴포넌트의 변경도 Interactor에 영향을 주지 않는다 (최고의 보호를 받는다. 가장 높은 수준)
		- 방향성 제어
			- `FinancialDataGateway` 인터페이스가 없었다면 Interactor -> Database 의존성이 생긴다
			- Interactor <- Database 의존성만 생기도록 의도적으로 DIP를 사용했다
		- 정보 은닉
			- `FinancialReportRequester` 인터페이스는 방향성 제어 목적이 아니라 Controller가 Interactor에 대해서 너무 많이 알지 못하도록 존재한다
			- `FinancialReportRequester` 인터페이스가 없었다면 Controller는 `FinancialEntities`에 대한 추이종속성을 가지게 된다

## 9장 LSP: 리스코프 치환 원칙
- 상위 타입의 인스턴스 자리에 하위 타입을 치환하더라도 문제가 없어야 한다
- 초창기에는 상속을 사용하는 가이드로 간주되었지만, 인터페이스와 구현체에도 적용되는 광범위한 원칙으로 변모해왔다
- LSP를 준수하는 사례의 예
	- License 인터페이스가 calcFee() 메서드를 가지고 있고, PersonalLicense, BusinessLicense 클래스가 구현하고 있음
	- Billing 애플리케이션이 License 인터페이스에 의존성을 가짐
	- LSP를 준수한다. why? Billing 애플리케이션의 행위가 License의 하위타입중 무엇을 사용하는지에 전혀 의존하지 않기때문
- LSP를 준수하지 않는 사례의 예
	- 정사각형 / 직사각형 문제
		- 직사각형을 상위, 정사각형을 하위 클래스로 지정해놓고, 정사각형의 너비or높이 설정 코드에 너비, 높이 동시에 설정하도록 하는 코드를 넣는다면 LSP 위반
	- 택시 파견 서비스 앱
		- 요구사항
			- 고객은 어느 택시업체인지는 신경쓰지 않고 적합한 택시를 찾는다
			- 이용할 택시를 결정하면, 시스템은 REST 서비스를 통해 선택된 택시를 고객 위치로 파견한다
			- 택시 파견 REST 서비스의 URL가 운전기사 테이블에 저장되어 있다 (ex: `purplecab.com/driver/Bob`)
			- 이 URL에 필요한 정보를 붙여서 다음과 같이 호출한다
				- PUT `purplecab.com/driver/Bob`/pickupAddress/24 Maple St./pickupTime/153/destination/ORD
			- 다양한 택시 업체에서 PUT .../pickupAddress/?/pickupTime/?/destination/? 형식을 지켜야 하지만 지키지 않는 업체도 있을 수 있다
		- 어떻게 해야 할까?
			- 형식을 지키지 않는 업체때문에 분기를 넣어야 하나? 나중에 형식을 지키지 않는 업체가 purplecab을 인수하면?
			- 설정용 테이블을 이용해서 해결한다. (ex: url, dispatch_format 컬럼)
## 10장 ISP: 인터페이스 분리 원칙
- ![[ISP.jpeg]]
	- User1은 op1만을, User2은 op2만을, User3은 op3만을 사용한다고 가정해보자
	- User1은 op2, op3을 사용하지 않는데도 op2의 소스코드가 변경되면 User1은 재컴파일을 해야 한다
	- op1, op2, op3을 각각 인터페이스 단위로 분리하면 다시 컴파일하고 다시 배포하지 않아도 된다
- ISP는 언어 타입에 따라 영향 정도가 다르다
	- 정적 타입 언어는 import 같은 선언문을 강제하므로 재컴파일/재배포가 필요하다. 
	- 동적 타입 언어는 런타임 추론이 발생하므로 좀 더 유연하다
- 불필요한 짐을 실은 무언가에 의존하면 예상치 못한 문제에 빠진다
## 11장 DIP: 의존성 역전 원칙
- DIP에서 말하는 유연성이 극대화된 시스템이란? 소스코드 의존성이 추상에만 의존하고, 구체에는 의존하지 않는 시스템
	- import 구문은 오직 인터페이스나 추상클래스만을 참조해야 한다는 뜻
	- 하지만 비현실적이다. String 같은 구체 클래스를 의존하지 않을 수 없다. 그래서 OS나 플랫폼같이 안정성 있는 환경에서는 무시한다
	- 변동성이 큰 구체적인 요소는 의존하지 않아야 한다
- DIP 실천법
	1. 변동성이 큰 구체 클래스를 참조하지 말고 추상 인터페이스를 참조하라. 일반적으로 추상 팩토리를 사용하도록 강제한다
	2. 변동성이 큰 구체 클래스로부터 상속받지 말라. 상속은 신중하게 써야 한다
	3. 구체 함수를 오버라이드하지 말라. 의존성을 제거할 수 없게 된다. 차라리 추상 함수로 선언하고, 구현체들에서 각각 구현해야 한다.
	4. 구체적이며 변동성이 크다면 절대로 그 이름을 언급하지 말라(?)
- 추상 팩토리 패턴을 사용해서 DIP 준수하기
	- ![[추상팩토리패턴.jpeg]]
	- 목표 : 구체 컴포넌트 -> 추상 컴포넌트 의존성만을 갖도록 하면서 `ConcreteImpl` 인스턴스를 생성해서 사용하기
	- 구체적인 의존성이 하나 있어 DIP에 위배되지만 (`ServiceFactoryImpl` -> `ConcreteImpl`) 모두 없앨 순 없다. DIP를 위반하는 클래스들을 구체 컴포넌트 내부로 모을 수 있어서 OK

# 4부 컴포넌트 원칙
- SOLID 원칙 : 벽과 방에 벽돌을 배치하는 방법
- 컴포넌트 원칙 : 빌딩에 방을 배치하는 방법
## 12장 컴포넌트
- 컴포넌트란?
	- 배포 단위
	- 시스템의 구성요소로 배포할 수 있는 가장 작은 단위
	- 자바 - jar, 루비 - gem, 닷넷 - dll ...
- 컴포넌트로 할 수 있는 것들
	- 여러 컴포넌트를 서로 링크하여 실행 가능한 단일 파일로 생성할 수 있다
	- 여러 컴포넌트를 묶어서 war 같은 단일 아카이브로 만들 수 있다
	- 컴포넌트 각각을 플러그인이나 exe 파일로 만들어서 독립적으로 배포할 수 있다
	- 어쨌든 독립적으로 개발 / 배포가 가능하도록 잘 설계되어야 한다
- 컴포넌트의 역사
	- 소프트웨어 개발 초창기
		- 메모리에서 프로그램 위치와 레이아웃을 프로그래머가 직접 제어했다
		- 라이브러리 함수에 접근하려고 애플리케이션 코드에 직접 포함시켜 단일 프로그램으로 컴파일했다
		- 이 방식은 컴파일러가 소스코드 전체를 여러번에 걸쳐 읽어야 했지만, 메모리도 너무 작아서 소스코드 전체를 메모리에 로딩할수도 없었다
		- 컴파일 시간을 단축시키기 위해 함수 라이브러리와 소스코드를 애플리케이션 코드로부터 분리했다
		- 애플리케이션과 함수 라이브러리가 점점 커지면서 단편화가 계속되었다
		- 지능적인 로더를 사용해서 메모리에 재배치할 수 있는 형태의 바이너리를 생성하도록 컴파일을 수정했다
		- 오직 필요한 함수만 로드할 수 있게 되었다
		- 링킹 로더 탄생
	- 1960말 ~ 1970초
		- 프로그램이 점점 커지고, 링킹 로더가 너무 느려졌다
		- 링킹 로더를 로더와 링커 두 애플리케이션으로 분리하고, 프로그래머가 느린 링커를 담당했다
	- 1980년대
		- C나 다른 고수준 언어를 사용하기 시작했고, 프로그램도 점점 더 커졌다
	- 1980년대 후반
		- 디스크는 작아지고, 놀랄만큼 빨라졌다. 메모리는 굉장히 저렴해졌다.
	- 1990년대 후반
		- 프로그램이 성장하는 속도보다 링크 시간이 줄어드는 시간이 더 빨라지기 시작했다
		- 액티브X와 공유 라이브러리 시대가 열렸고 jar 파일도 등장했다
		- 로드와 링크를 동시에 할 수 있게 됐다
		- 컴포넌트 플러그인 아키텍쳐가 탄생했다
- 런타임에 플러그인 형태로 결합할 수 있는 동적 링크 파일이 컴포넌트다.
- 컴포넌트 플러그인 아키텍쳐를 적용하려면 엄청난 노력를 했어야 했지만, 지금은 기본이 됐다
## 13장 컴포넌트 응집도
## 14장 컴포넌트 결합


# 5부 아키텍처
## 15장 아키텍처란?
## 16장 독립성
## 17장 경계: 선 긋기
## 18장 경계 해부학  
## 19장 정책과 수준  
## 20장 업무 규칙  
## 21장 소리치는 아키텍처  
## 22장 클린 아키텍처  
## 23장 프레젠터와 험블 객체  
## 24장 부분적 경계  
## 25장 계층과 경계  
## 26장 메인(Main) 컴포넌트  
## 27장 ‘크고 작은 모든’ 서비스들    
## 28장 테스트 경계  
## 29장 클린 임베디드 아키텍처  


# 6부 세부사항
## 30장 데이터베이스는 세부사항이다  
## 31장 웹은 세부사항이다    
## 32장 프레임워크는 세부사항이다  
## 33장 사례 연구: 비디오 판매 
## 34장 빠져 있는 장