# 1부 소개
- 프로그램이 동작하도록 만드는 데에는 엄청난 수준의 지식과 기술이 필요하지 않지만, 제대로 만드는 것은 어렵다
	- 적정 수준의 지식과 기술, 사고력과 통찰력, 헌신이 필요하다
- 제대로 된 소프트웨어를 만들면 아주 적은 인력만으로도 기능 추가 및 유지보수가 가능하다
## 1장 설계와 아키텍처란?
- 좋은 소프트웨어 설계의 목표는? 기능추가 / 유지보수에 투입되는 인력을 최소화하는 것
- 개발자들은 종종 "구현 먼저, 코드 정리는 나중!"라며 자신을 과신한다
- 빨리 가는 유일한 방법은 제대로 가는 것이다
- 아키텍쳐가 엉망이면 생산성은 시간이 갈수록 0에 수렴한다
	- 이걸 막으려면 개발자들은 본인을 과신하지 말고, 앙망진창은 코드를 스스로 책임져야 한다
## 2장 두 가지 가치에 대한 이야기
- 소프트웨어의 두가지 가치 : 행위와 구조
	1. 행위 : 소프트웨어의 기능. 많은 프로그래머가 이것이 할 일의 전부라고 생각한다.
	2. 구조(아키텍쳐) : 반드시 변경하기 쉬어야 한다.
- 개발팀은 아키텍쳐의 중요성을 관리팀에게 설득하는 일을 책임져야 한다. (투쟁해야 한다)

# 2부 벽돌부터 시작하기: 프로그래밍 패러다임
## 3장 패러다임 개요
- 각 패러다임은 프로그램으로부터 어떤 권한을 박달하느냐에 따라 나뉜다.
	- 구조적 -> goto문, 객체지향 -> 함수 포인터, 함수형 -> 할당문
- 더 박탈할 만한 게 없다. 다른 패러다임은 나오지 않을 것이다.
## 4장 구조적 프로그래밍
- 데이크스트라는 goto문이 분할 정복 접근법에 방해되고, 분기/반복으로 대체하면 증명 가능한 다위로까지 모듈을 재귀적으로 세분화하는것이 가능하다는 걸 발견했다
- 구조적 프로그래밍을 통해 모듈을 증명 가능한 더 작은 단위로 재귀적으로 분해하여, 분할정복이 가능해졌다
- 구조적 프로그래밍이 가치있는 이유는 반증 가능한 단위를 만들어 낼 수 있기 때문이다
## 5장 객체 지향 프로그래밍
- 객체지향 프로그래밍이란?
	- 데이터와 함수의 조합이다?
	- 실제 세계를 모델링하는 새로운 방법이다?
	- 캡슐화, 상속, 다형성을 지원하는 프로그래밍이다?
- 캡슐화
	- 내부 데이터 구조와 함수가 어떻게 구현되어 있는지 전혀 몰라야 완벽한 캡슐화다. (멤버 변수 등이 변경되어도 재컴파일이 필요없어야 한다)
	- 객체지향이 아닌 언어도 캡슐화를 지킬수 있다
- 상속
	- 객체지향이 아닌 언어에서도 흉내는 낼 수 있다
- 다형성
	- 함수를 가리키는 포인터를 응용한 것.
	- 함수 포인터를 직접 사용하면 위험하다. 객체지향 언어는 언어 차원에서 위험을 막아준다
	- 다형성을 사용하면 플러그인 아키텍쳐를 적용할 수 있다
	- 의존성 역전을 이용하면 소스코드 의존성을 원하는 대로 설정할 수 있다
- 그래서 객체지향 프로그래밍이란?
	- 다형성을 이용하여 전체 시스템의 모든 소스 코드 의존성에 대한 절대적인 제어 권한을 획득할 수 있는 능력이다.
## 6장 함수형 프로그래밍
- 함수형 프로그램에서 변수는 불변이다
- 다수의 쓰레드를 사용하는 프로그램에서 발생하는 동시성 문제(race condition, 데드락, 동시 업데이트)가 발생하지 않는다

# 3부 설계 원칙
- SOLID
	- 좋은 벽돌로 좋은 아키텍쳐를 정의하는 원칙
	- 함수와 데이터 구조를 클래스로 배치하는 방법, 이들 클래스를 결합하는 방법을 설명한다
	- 목적은 중간 수준의 소프트웨어(모듈 수준) 구조가 변경에 유연하고, 이해하기 쉽고, 사용될 수 있는 컴포넌트의 기반이 되는것이 목적이다.
## 7장 SRP: 단일 책임 원칙
- 하나의 모듈은 하나의 액터(변경되기를 원하는 집단)에 대해서만 책임져야 한다
- SRP를 위반하는 징후들
	1. 우발적 중복
		- 
	2. 병합
## 8장 OCP: 개방-폐쇄 원칙  
## 9장 LSP: 리스코프 치환 원칙  
## 10장 ISP: 인터페이스 분리 원칙  
## 11장 DIP: 의존성 역전 원칙


# 4부 컴포넌트 원칙
## 12장 컴포넌트  
## 13장 컴포넌트 응집도  
## 14장 컴포넌트 결합


# 5부 아키텍처
## 15장 아키텍처란?  
## 16장 독립성  
## 17장 경계: 선 긋기  
## 18장 경계 해부학  
## 19장 정책과 수준  
## 20장 업무 규칙  
## 21장 소리치는 아키텍처  
## 22장 클린 아키텍처  
## 23장 프레젠터와 험블 객체  
## 24장 부분적 경계  
## 25장 계층과 경계  
## 26장 메인(Main) 컴포넌트  
## 27장 ‘크고 작은 모든’ 서비스들    
## 28장 테스트 경계  
## 29장 클린 임베디드 아키텍처  


# 6부 세부사항
## 30장 데이터베이스는 세부사항이다  
## 31장 웹은 세부사항이다    
## 32장 프레임워크는 세부사항이다  
## 33장 사례 연구: 비디오 판매 
## 34장 빠져 있는 장