# 스프링 배치 완벽 가이드 2/e

## 1장. 배치와 스프링

### 배치 처리란? 

- 상호작용이나 중단 없이 유한한 양의 데이터를 처리하는 것
- 일단 시작되면 아무런 개입 없이 어떤 형태로든 완료된다

### 배치 처리는 왜 필요한가?

1. 필요한 정보를 실제 처리가 시작되기 전에 미리 수집할 수 있다
2. 때로는 사업적으로 도움이 된다
3. 자원을 더 효율적으로 사용할 수 있다

### 배치 처리를 개발하는 데 기술적으로 해결해야 하는 과제들

1. (코드의) 사용성
   - 공통 컴포넌트를 쉽게 확장해 새로운 기능을 추가할 수 있는가?
   - 기존 컴포넌트를 변경할 때 시스템 전체에 미치는 영향을 알 수 있도록 단위테스트가 잘 마련돼있는가?
   - 잡이 실패할 때 디버깅에 오랜 시간을 소비하지 않고, 언제, 어디서, 왜 실패했는지 알 수 있는가?
2. 확장성
   - 배치가 처리할 수 있는 규모가 웹 애플리케이션의 규모보다 몇자리 수 이상 더 클 수 있다
3. 가용성
   - 필요할 때 바로 배치 처리를 수행할 수 있는가?
   - 허용된 시간 내에 잡을 수행함으로써 다른 시스템에 영향을 미치지 않게 할 수 있는가?
4. 보안
   - 민감한 데이터베이스 필드는 암호화돼 있는가?
   - 실수로 개인 정보를 로그로 남기지는 않는가?
   - 자격증명이 필요한가?

### 왜 자바로 배치를 처리하는가?

1. 유지 보수성
   - 스프링 프레임워크는 테스트 용이성이나 추상화같은 이점을 얻을 수 있도록 설계됐다
   - DI를 통해 객체간 결합을 제거할 수 있다
   - 테스트 도구를 활용하여 유지 보수시 발행할 수 있는 위험을 줄일 수 있다
   - JDBC 코드나 파일I/O API를 직접 다룰 필요 없다
   - 트랜잭션 및 커밋 횟수같은 것들을 제공하므로 실패시 무슨 일을 해야 하는지 관리할 필요가 없다
2. 유연성
   - 배치 처리가 가능한 플랫폼은 메인프레임, C++/UNIX 등이 있다
   - 위 방식들은 JVM의 유연성과 스프링 배치의 기능들을 제공하지 않는다
   - 스프링 배치는 유닉스 계열 또는 윈도우 서버, 데스크탑 등등 어디에서든 돌아간다
   - 웹 애플리케이션에서 이미 테스트 및 디버깅 된 서비스를 배치 처리에서 동일하게 바로 사용할 수 있다
3. 확장성
   - 단일 서버 내의 단일 JVM에서 배치처리를 수행할수도, 나눠서 수행할수도 있다.
   - 클라우드 리소스를 사용하여 배치처리할 수 있다
4. 개발 리소스
   - 배치 처리 코드는 수명이 길기 때문에 개발 인력을 구하는 것도 중요하다.
   - 스프링 개발자는 많다
5. 지원
   - 온라인 커뮤니티가 잘 갖춰져 있다
   - 소스코드에 접근할 수 있고 비용을 지불하면 기술 지원을 받을 수 있다
6. 비용
   - 스프링 배치는 가장 저렴한 솔루션

### 스프링 배치의 사용 사례

- ETL(추출, 변환, 적재) 처리
  - 스프링 배치의 청크기반 처리 및 확장 기능은 ETL워크로드에 자연스럽게 들어맞는다
- 데이터 마이그레이션
  - 잡을 기동하는데 많은 코딩이 필요없다
  - 마이그레이션에 필요한 커밋 횟수 측정이나 롤백 기능을 제공한다
- 병렬 처리
  - 멀티 코어 도는 멀티 서버에 처리를 분산하는 기능을 제공한다

### 스프링 배치 프레임워크

- 스프링 배치의 구조

  - 레이어 구조로 조립된 세개의 티어로 이뤄져 있다

    ![Figure 1.1: Spring Batch Layered Architecture](https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/images/spring-batch-layers.png)

  - 애플리케이션 레이어

    - 코어 레이어와 상호작용하는데 대부분의 시간을 소비한다

  - 코어 레이어

    - 배치 도메인을 정의하는 모든 부분이 포함된다
    - `Job`, `Step`, `JobLauncher`, `JobParameters` 등이 있다

  - 인프라스트럭쳐 레이어

    - 파일, 데이터베이스 등으로부터 읽고 쓸 수 있게 한다
    - 잡 실패 후 재시도될 때 어떤 일을 수행할 지 다룰 수 있게 한다

- 잡 config

  - 중단이나 상호작용 없이 처음부터 끝까지 실행되는 처리

  - 여러 개의 스텝이 모여 이뤄질 수 있다

  - 여러 방법으로 구성할 수 있지만, 아래는 자바 구성 클래스에 구성하는 방법을 보여준다

    ```java
    @Bean
    public AccountTasklet accountTasklet() {
      // 커스텀 컴포넌트. 스프링 배치는 AccountTasklet이 완료될때까지 execute메서드를 반복해서 호출한다. (각각은 새 트랜잭션으로 호출됨)
      return new AccountTasklet();
    }
    
    @Bean
    public Job accountJob() {
      Step accountStep = this.stepBuilderFactory.get("accountStep")
        .tasklet(accountTasklet())
        .build();
      
      return this.jobBuilderFactory.get("accountJob")
        .start("accountStep")
        .build();
    }
    ```

- 잡 관리

  - 실패해서 재실행할 때 필요한 잡의 상태 정보를 유지해준다
  - 실패했을 때 데이터 무결성을 유지할 수 있도록 트랜잭션을 관리해준다

- 로컬 및 원격 병렬화

  - 각 커밋 간격내의 처리를 스레드 풀에서 가져온 자체 스레드에서 처리하는 단순 스레드 기반 방식
  - 병렬 청크/스텝 처리, 원격 청크 처리, 파티셔닝 기능
  - 모든 스텝을 병렬로 실행하기, 파티셔닝을 통해 원격 마스터로부터 작업 단위를 제공받는 워커의 그리드 구성하기 등 

- IO 표준화하기

  - 다양한 형식을 읽거나 쓰는 일은 간단한 config로 해결할 수 있다

- 스프링 배치 에코시스템

  - 스프링부트
  - 스프링 클라우드 태스크
  - 스프링 클라우드 데이터 플로우

<br/>

## 2장. 스프링 배치

### 스텝

- 잡을 구성하는 독립된 작업의 단위
- 스텝은 두가지 유형이 있음
  1. tasklet기반 스텝
     - 비교적 더 간단함
     - `Tasklet`을 구현하면 됨. 스텝이 중지될 때까지 `execute`메서드가 계속 반복해서 수행된다
     - 초기화, 저장 프로시저 실행, 알림 전송 등과 같은 잡에서 사용
  2. chunk기반 스텝
     - 약간 더 복잡함
     - 아이템 기반 처리에 사용
     - `ItemReader`, `ItemProcessor`(필수x), `ItemWriter`으로 구성
- 스텝을 분리하는 것의 이점
  1. 유연성 : 재사용할 수 있도록 여러 빌더 클래스 제공
  2. 유지보수성 : 각 스텝은 독립적 -> 각 스텝의 단위테스트, 디버그, 변경 등을 할 수 있음. 또 독립적이기 때문에 여러 잡에서 재사용 가능
  3. 확장성 : 스텝을 병렬로 실행할 수 있는 등의 확장 가능한 기능 제공
  4. 신뢰성 : 오류 처리 방법(예외 발생시 재시도, 건너뛰기 등) 제공

### `JobRepository`

- 다양한 배치 수행과 관련된 수치 데이터, 잡의 상태를 유지/관리
- 실행된 스텝, 현재 상태, 읽은 아이템 수, 처리된 아이템 수 등이 저장됨
- 관계형 데이터베이스 사용
- 스프링 배치 내의 대부분의 주요 컴포넌트가 공유

### `JobLauncher`

- `Job.execute`를 실행하는 역할
- 잡이 재실행 가능한지, 잡을 어떻게 실행할건지(현재 스레드에서 할지, 스레드 풀을 통해 실행할지), 파라미터 유효성 검증 등의 처리도 함

### `Job`, `JobInstance`, `JobExecution`

- `JobInstance` : 배치 잡의 논리적인 실행. "잡의 이름"과 "식별 파라미터"로 식별할 수 있다.
- `JobExecution` : 배치 잡의 실제 실행. 잡을 구동할때마다 새로운 JobExecution을 얻는다.

-> 한 잡을 같은 파라미터로 2번 실행했는데 첫번째는 실패, 두번째는 성공했다면 `JobInstance`는 1개, `JobExecution`는 2개

### `StepExecution`

- `JobExecution`이 잡의 실제 실행을 나타내듯이 `StepExecution`은 스텝의 실제 실행을 나타낸다
- `StepInstance`라는 개념은 존재하지 않는다

### 병렬화 방법

1. 다중 스레드 스텝을 이용해 잡 나누기
   - 잡은 청크라는 블록 단위로 처리되도록 구성됨
   - 각 청크는 독립적인 트랜잭션으로 처리됨
   - 일반적으로 각 청크는 연속해서 처리됨
   - 여러 스레드를 사용하도록 변경하면 처리량을 늘릴 수 있다
2. 스텝을 병렬로 실행
   - 각 스텝이 연관이 없다면 병렬로 실행하는게 효율적
3. 비동기 `ItemProcessor`/`ItemWriter` 구성
   - `AsynchronousItemProcessor` , `AsynchronousItemWriter` 등을 사용할 수 있다
4. 원격 청킹
   - 메시지 브로커등을 통해 여러 JVM에서 처리를 분산할 수 있다
   - 단 네트워크 사용량이 매우 많아질 수 있다
5. 파티셔닝
   - 원격 파티셔닝과 로컬 파티셔닝을 모두 지원한다

### Hello world!

```java
@EnableBatchProcessing //배치 인프라스터럭쳐를 부트스트랩하는데 사용됨
@SpringBootApplication
public class BatchApplication {
  
  @Autowired
  private JobBuilderFactory jobBuilderFactory;
  @Autowired
  private StepBuilderFactory stepBuilderFactory;

  @Bean
  public Step step() {
    return stepBuilderFactory.get("step1")
        .tasklet(new Tasklet() {
          @Override
          public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext)
              throws Exception {
            System.out.println("Hello, World!");
            return RepeatStatus.FINISHED; //tasklet이 완료됐음을 스프링배치에게 알리는 역할
          }
        }).build();
  }

  @Bean
  public Job job() {
    return jobBuilderFactory.get("job")
        .start(step())
        .build();
  }

  public static void main(String[] args) {
    SpringApplication.run(BatchApplication.class, args);
  }
}
```

- 실행하면 "Hello, World!"가 출력되고 종료된다.
- 실제로 일어난 일
  1. `@SpringBootApplication`이 스프링부트를 부트스트랩한다
  2. `ApplicationContext` 생성됨
  3. 스프링배치가 클래스 경로에 있어서` JobLauncherCommandLineRunner`가 실행됨
  4. 잡이 수행되어 첫번째 스텝이 실행됨(이때 트랜잭션이 시작됨)
  5. `Tasklet`이 실행됨
  6. 결과가 `JobRepository`에 갱신됨

<br/>

## 3장. 예제 잡 애플리케이션

### 월별 은행 거래명세서 예제 요구사항

- 매일 밤 수행됨
- 지난 달 거래 정보를 사용해 거래명세서 생성
- 기존 계좌에서 거래 내역을 적용한 후 각 계좌별로 거래명세서를 생성

### 살펴볼 배치 개념

- 다양한 입출력 방식
- 오류 처리
- 확장성

### 배치 처리가 수행하는 기능

1. 제공된 입력 파일을 기반으로 고객 정보 갱신하기
2. 데이터베이스에 저장된 모든 고객의 거래 정보 가져오기
3. 계좌 잔액으로 계좌 정보 갱신하기
4. 지난 한 달 동안의 은행 계좌 파일 인쇄하기

<br/>

## 4장. 잡과 스텝 이해하기

### 잡은...

- 유일하다
  - 잡을 여러번 실행하려고 동일한 잡을 여러번 정의할 필요가 없다
- 순서를 가진 여러 스텝의 목록이다
  - 잡에서 스텝의 순서는 중요하다
  - 모든 스텝을 논리적인 순서대로 실행할 수 있다
- 처음부터 끝까지 실행 가능하다
  - 외부 의존성 없이 실행할 수 있다
- 독립적이다
  - 의존성을 관리할 수 있어야 한다

### 잡의 생명주기

- 잡은 생명주기대로 실행된다.
- 잡의 실행은 잡 러너에서 시작된다. 
- 잡 러너 : 잡의 이름과 여러 파라미터를 받아들여 잡을 실행시키는 역할. 스프링배치는 두가지를 제공한다
  1. `CommandLineJobRunner`
     - 스크립트를 이용하거나 명령행에서 직접 잡을 실행할 때 사용
     - 스프링을 부트스트랩하고, 전달받은 파라미터를 사용해 요청된 잡을 실행한다
  2. `JobRegistryBackgroundJobRunner`
     - `JobRegistry`를 생성하는데 사용
     - `JobRegistry`란? 스케줄러를 사용해 잡을 실행한다면 생성되는것. 스프링이 부트스트랩될 때 실행 가능한 잡을 가지고 있음
- 이와 별개로 스프링부트가 제공하는 `JobLauncherCommandLineRunner`도 있음.
  - 별도의 config가 없다면 `ApplicationContext`에 정의된 모든 잡 빈을 실행함
  - 이 책에선 이걸 사용
- `JobInstance`
  - 잡 이름 + 파라미터로 식별
    - `BATCH_JOB_INSTANCE`와 `BATCH_JOB_EXECUTION_PARAMS` 사용
  - 성공적으로 완료된 `JobExecution`이 있다면 완료된 것으로 간주됨.
  - 한 번 성공하면 다시 실행시킬 수 없음
- `JobExecution`
  - 잡 실행의 실제 시도
  - 시도할때마다 새로운 `JobExecution` 생성되고 `BATCH_JOB_EXECUTION` 테이블의 레코드로 저장됨
  - `JobExecution`이 실행될때의 상태는 `BATCH_JOB_EXECUTION_CONTEXT`에 저장됨 -> 오류 발생 시 그 시점부터 실행 가능

### 잡 config

- `CommandLineJobRunner`에 파라미터 전달하기 : `java -jar demo.jar name=junho`

  - 그럼 파라미터들은 `JobParameters`와 매핑됨 (`Map<String, JobParameter>`의 래퍼)
  - 타입 변환기능을 이용하고 싶으면 타입도 같이 넘겨준다(소문자로) : `java -jar demo.jar executionDate(date)=2020/12/27`
  - 전달한 파라미터는 `BATCH_JOB_EXECUTION_PARAMS` 에 저장됨
  - 식별에 사용하고 싶지 않는 파라미터는 `-`를 붙이면 됨 : `java -jar demo.jar executionDate(date)=2020/12/27 -name=junho`

- 잡 파라미터에 접근하는 방법

  1. `chunkContext`

     ```java
     @Bean
     public Tasklet helloWorldTasklet() {
       return ((contribution, chunkContext) -> {
         String name = (String) chunkContext.getStepContext()
             .getJobParameters()
             .get("name");
         System.out.println(String.format("Hello, %s!", name));
         return RepeatStatus.FINISHED;
       });
     }
     ```

     - `StepContribution contribution` : 아직 커밋되지 않은 현재 트랜잭션에 대한 정보(쓰기수, 읽기수 등)
     - `ChunkContext chunkContext` : 실행 시점의 잡 상태를 제공. 테스크릿 내에서는 처리중인 청크와 관련된 정보도 갖고있음

  2. 늦은 바인딩

     ```java
     @StepScope
     @Bean
     public Tasklet helloWorldTasklet(@Value("#{jobParameters['name']}") String name) {
       return ((contribution, chunkContext) -> {
         System.out.println(String.format("Hello, %s!", name));
         return RepeatStatus.FINISHED;
       });
     }
     ```

     - 스코프 기능을 사용하면 늦은 바인딩을 쉽게 사용할 수 있다
     - 스텝 스코프, 잡 스코프 : 스텝, 잡의 실행범위에 들어갈 때까지 빈 생성을 지연시키는 기능

- 스프링 배치의 파라미터 특화 기능

  1. 파라미터 유효성 검증 기능

     - `JobParametersValidator` 인터페이스를 구현하고 잡 config에 넣어주면 됨
     - 필수 파라미터와 옵션 파라미터에 대한 검증만 하고 싶으면? `DefaultJobParametersValidator`
     - 여러 검증 구현체를 적용하고 싶으면? `CompositeJobParametersValidator`

  2. 파라미터 증가 기능

     ```java
     @Bean
     public Job job(){
       return jobBuilderFactory.get("basicJob")
           .start(step1())
           .validator(validator()) //CompositeJobParametersValidator
           .incrementer(new RunIdIncrementer()) //JobParametersIncrementer
           .build();
     }
     ```

     - `JobParametersIncrementer` : 파라미터를 고유하게 생성할 수 있도록 해줌
     - `RunIdIncrementer`를 추가하면 validator에 `run.id` 를 옵션 파라미터에 추가해야 한다
     - 날짜를 증가시키는 것 같이 커스텀하게 만들고 싶다면 `JobParametersIncrementer` 을 구현하고 잡 config에 넣고 옵션 파라미터에 추가하면 된다

- 잡 리스너

  - 잡 리스너로 잡의 생명주기의 여러 시점에 로직을 추가할 수 있다

  - 잡 리스너 작성 방법

    1. `JobExecutionListener` 인터페이스 구현

       - `beforeJob`과 `afterJob` 메서드가 있다 : 잡 실행 전 초기화, 잡 실행 후 정리, 알림 등등에 이용한다

       - 구현 후 Job config에 넣음

         ```java
         @Bean
         public Job job() {
           return jobBuilderFactory.get("basicJob")
               .start(step1())
               .validator(validator())
               .incrementer(new RunIdIncrementer())
               .listener(new JobLoggerListener()) // <--
               .build();
         }
         ```

    2. `@BeforeJob`, `@AfterJob` 사용

       - `JobExecutionListener` 을 implements할 필요가 없다

       - config가 살짝 다르다

         ```java
         @Bean
         public Job job() {
           return jobBuilderFactory.get("basicJob")
               .start(step1())
               .validator(validator())
               .incrementer(new RunIdIncrementer())
               .listener(JobListenerFactoryBean.getListener(new JobLoggerListener())) // <--
               .build();
         }
         ```

  - 리스너는 잡 리스너 외에도 스텝, 리더, 라이터 등에도 있다

- `ExecutionContext`

  - 잡 상태는 `JobExecution`의 `ExecutionContext`에 저장된다

  - `ExecutionContext`은 기본적으로 잡의 세션이다

  - `ExecutionContext`에 담겨있는 모든 게 `JobRepository`에 저장된다

  - 조작하는 방법

    1. `JobExecution` 또는 `StepExecution`으로부터 가져오기

       ```java
       public class HelloWorldTasklet implements Tasklet {
       
         @Override
         public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
           ExecutionContext jobContext = chunkContext.getStepContext()
               .getStepExecution() //getStepExecutionContext()는 변경사항이 반영되지 않음
               .getJobExecution()
               .getExecutionContext();
           jobContext.put(...); // <-- 조작
         
         }
       }
       ```

    2. `StepExecution`의 `ExecutionContext`에 있는 키를 `JobExecution`의 `ExecutionContext`로 승격하기

       - ?

    3. `ItemStream` 인터페이스 사용

       - 추후 다룸

  - 저장하는 법

    - 잡이 처리되는 동안 각 청크를 커밋하면서 잡과 스텝의 현재 `ExecutionContext`를 데이터베이스에 저장한다
    - `BATCH_JOB_EXECUTION_CONTEXT` 테이블
      - `JOB_EXECUTION_ID` 컬럼 : 관련된 `JobExecution`의 참조
      - `SHORT_CONTEXT` 컬럼 : `ExecutionContext`의 json 표현. 배치 처리가 진행되면서 갱신됨
      - `SERIALIZED_CONTEXT` 컬럼 : 직렬화된 자바 객체

### 스텝

- 잡이 전체적인 처리를 정의한다면, 스텝은 잡의 구성 요소
- 독립적이고 순차적으로 배치 처리를 수행 -> 스텝을 "배치 프로세서"라고 부름
- 자체적으로 입력을 처리, 자체적으로 처리기를 가짐, 자체적으로 출력을 처리함
- 트랜잭션을 스텝 내에서 이뤄짐
- 스텝에서 테이터를 처리하는 방법 : 태스크릿 처리, 청크 처리
  1. 태스크릿 모델
     - `Tasklet` 인터페이스를 사용. `execute`메서드가 `RepeatStatus.FINISHED`를 반환할때까지 트랜잭션 범위 내에서 반복적으로 실행
  2. 청크 처리
     - `ItemReader`, `ItemProcessor`(필수x), `ItemWriter`로 구성
     - 이 컴포넌트들을 사용해서 레코드를 청크 또는 레코드 그룹 단위로 처리
     - 각 청크는 자체 트랜잭션으로 실행됨. 실패한다면 마지막으로 성공한 트랜잭션 이후부터 다시 시작

### 스텝 config

- 태스크릿 스텝을 만드는 유형

  1. 사용자가 작성한 코드를 마치 태스크릿 스텝처럼 실행하도록 하는 유형

  2. `Tasklet` 인터페이스를 구현하는 유형

     - `execute` 메서드를 구현하고, `RepeatStatus.CONTINUABLE` 또는 `RepeatStatus.FINISHED`를 반환하면 된다
       - `RepeatStatus.CONTINUABLE` : 해당 태스크릿을 다시 실행하겠다는 뜻. 특정 태스크릿을 특정 조건이 만족할때까지 반복하고, 추적하고 싶다면 이 타입을 반환하면 된다
       - `RepeatStatus.FINISHED` : 처리의 성공여부에 관계없이 처리를 완료하고 다음 처리를 하겠다는 뜻

  3. `CallableTaskletAdapter` 구현체 사용

     - `Callable<RepeatStatus>` 의 구현체를 구성할 수 있게 해주는 어댑터.
     - 스텝의 특정 로직을 해당 스텝이 실행되는 스레드가 아닌 다른 스레드에서 실행하고 싶을때 사용함
     - 스텝이 실행되는 스레드와 별개의 스레드에서 태스크릿이 실행되지만 스텝과 병렬로 실행되는 건 아니다
     - `Callable` 객체가 유효한 `RepeatStatus` 객체를 반환하기 전에는 완료된 것으로 간주하지 않는다

     ```java
     @Bean
     public Step callableStep() {
       return stepBuilderFactory.get("callableStep")
           .tasklet(tasklet())
           .build();
     }
     
     @Bean
     public CallableTaskletAdapter tasklet() {
       CallableTaskletAdapter adapter = new CallableTaskletAdapter();
       adapter.setCallable(callableObject());
       return adapter;
     }
     
     @Bean
     public Callable<RepeatStatus> callableObject() {
       return () -> {
         System.out.println("이건 다른 스레드에서 실행됩니다.");
         return RepeatStatus.FINISHED;
       };
     }
     ```

  4. `MethodInvokingTaskletAdapter` 구현체 사용

     - 기존에 존재하던 다른 클래스 내의 메서드를 잡 내의 태스크릿처럼 실행할 수 있다
     - 기존 메서드 호출을 매핑하는 `Tasklet` 인터페이스의 구현체를 만들지 않을 수 있다.

     ```java
     @Bean
     public Step methodInvokingStep() {
       return stepBuilderFactory.get("methodInvokingStep")
           .tasklet(methodInvokingTasklet())
           .build();
     }
     
     @Bean
     public MethodInvokingTaskletAdapter methodInvokingTasklet() {
       MethodInvokingTaskletAdapter adapter = new MethodInvokingTaskletAdapter();
       adapter.setTargetObject(service()); //태스크릿으로 실행하고자 하는 메서드의 클래스
       adapter.setTargetMethod("method"); //메서드 이름
       return adapter;
     }
     ```

     - 정적 파라미터 셋을 구성하려면? 늦은 바인딩 이용

     ```java
     @StepScope
     @Bean
     public MethodInvokingTaskletAdapter methodInvokingTasklet(@Value("#{jobParameters['message']}") String message) {
       MethodInvokingTaskletAdapter adapter = new MethodInvokingTaskletAdapter();
       adapter.setTargetObject(service()); //태스크릿으로 실행하고자 하는 메서드의 클래스
       adapter.setTargetMethod("method"); //메서드 이름
       adapter.setArguments(new String[]{message}) //인자 목록
       return adapter;
     }
     ```

  5. `SystemCommandTasklet` 구현체 사용

     - 시스템 명령을 비동기로 실행할때 사용한다
     - 자세한 사용법은 책 참조

- 청크 기반 스텝

  - 청크는 커밋 간격에 의해 정의된다
    - 커밋 간격이 50이라면? "50개 읽기 -> 50개 처리 -> 50개 기록"을 반복

  ```java
  @Bean
  public Step step1() {
    return stepBuilderFactory.get("step1")
        .<String, String>chunk(10) //커밋 간격=10, 10개 단위로 레코드 처리한 후 커밋된다
        .reader(itemReader(null))
        .writer(itemWriter(null))
        .build();
  }
  
  @Bean
  public FlatFileItemReader<String> itemReader(@Value("#{#jobParameters['inputFile']}") Resource inputFile) {
    //생략
  }
  
  @Bean
  public FlatFileItemWriter<String> itemWriter(@Value("#{#jobParameters['outputFile']}") Resource outputFile) {
    //생략
  }
  ```

  - 청크 크기 config 하는방법

    1. 커밋 개수가 고정적이라면 -> `chunk()` 안에 커밋 개수 넣으면 됨

    2. 청크가 완료되는 시점을 동적으로 정하고 싶다면 -> `CompletionPolicy` 구현체 사용

       ```java
       @Bean
       public Step chunkStep() {
         return stepBuilderFactory.get("chunkStep")
             .<String, String>chunk(completionPolicy())
             .reader(itemReader())
             .writer(itemWriter())
             .build();
       }
       
       @Bean
       public CompletionPolicy completionPolicy() {
         CompositeCompletionPolicy policy = new CompositeCompletionPolicy();
         policy.setPolicies(new CompletionPolicy[]{ //밑에 나열된 조건 중 하나라도 만족하면 안전하게 빠져나옴
             new TimeoutTerminationPolicy(3), //청크 내에서 3ms가 넘으면 안전하게 빠져나옴
             new SimpleCompletionPolicy(1000) //1000개가 처리되면 안전하게 빠져나옴
         }); //"안전하게 빠져나옴?" : 해당 청크가 완료된 것으로 간주하고 모든 트랜잭션 처리가 정상적으로 계속된다는 뜻
         return policy;
       }
       ```

       - 아이템이 100000개, 청크크기가 1000개인데 커밋 개수는 101개(100000 / 1000 + 1)가 아니라 101보다 크다.(`TimeoutTerminationPolicy`가 없다면 101임)
       - 직접 만들수도 있음. 아래 예제는 매 청크마다 20 미만의 수를 랜덤하게 정해서 그 수만큼 아이템이 처리되면 청크를 완료하는 예제.

       ```java
       public class RandomChunkSizePolicy implements CompletionPolicy {
       
         //상태를 가지고 있어야 함
         private int chunkSize;
         private int totalProcessed;
         private Random random = new Random();
       
         @Override
         public boolean isComplete(RepeatContext context, RepeatStatus result) {
           if (RepeatStatus.FINISHED == result) {
             return true;
           } else {
             return isComplete(context);
           }
         }
       
         @Override
         public boolean isComplete(RepeatContext context) {
           return this.totalProcessed >= chunkSize;
         }
       
         @Override
         public RepeatContext start(RepeatContext parent) { //정책 초기화
           this.chunkSize = random.nextInt(20);
           this.totalProcessed = 0;
           System.out.printf("청크 사이즈가 %d로 설정됨.", this.chunkSize);
           return parent;
         }
       
         @Override
         public void update(RepeatContext context) { //각 아이템이 처리될때 처리됨
           this.chunkSize++;
         }
       }
       ```

       ```java
       @Bean
       public Step chunkStep() {
         return stepBuilderFactory.get("chunkStep")
             .<String, String>chunk(completionPolicy()) //새 청크마다 적용됨
             .reader(itemReader())
             .writer(itemWriter())
             .build();
       }
       
       @Bean
       public CompletionPolicy completionPolicy() {
         return new RandomChunkSizePolicy();
       }
       ```

  - 스텝 리스너

    - `StepExecutionListener`, `ChunkListener`로 각각 스텝과 청크의 시작과 끝에 특정 로직을 수행하게 할 수 있다
      - `StepListener`가 아니다. `StepListener`은 마커 인터페이스임
    - 잡 리스너와 유사하게 `after...` `before...` 메서드를 제공하고, `@After...` `@Before...` 어노테이션도 제공한다
    - 로직을 정의하고 step config에 넣으면 된다

    ```java
    @Bean
    public Step chunkStep() {
      return stepBuilderFactory.get("chunkStep")
          .<String, String>chunk(1000)
          .reader(itemReader())
          .writer(itemWriter())
          .listener(new LoggingStepStartStopListener()) // <--
          .build();
    }
    ```

### 스텝 플로우

- `firstStep`이..
  - 정상일때 -> `successStep`으로 이동
  - `ExitStatus.FAILED`을 반환할때 -> `failureStep`으로 이동

```java
@Bean
public Job job(){
  return jobBuilderFactory.get("conditionalJob")
      .start(firstStep())
      .on("FAILED").to(failureStep()) //on: ExitStatus를 평가
      .from(firstStep()).on("*").to(successStep())
      .end()
      .build();
}
```

- `on()`안에 들어가는 건 문자열, 와일드카드 사용 가능
  
  - `*` : 0개 이상의 문자를 일치시킴. 
    - `C*` == C, COMPLETE, CORRECT
  - `?` : 1개의 문자를 일치시킴.
    - `?AT` == CAT, KAT
    - `?AT` != THAT
  
- 다음에 뭘할지 코드로 구현하고 싶다면? -> `JobExecutionDecider` 인터페이스를 구현

  ```java
  public class RandomDecider implements JobExecutionDecider {
  
    private Random random = new Random();
  
    //decide 메서드만 구현하면 됨
    @Override
    public FlowExecutionStatus decide(JobExecution jobExecution, StepExecution stepExecution) {
      if (random.nextBoolean()) {
        return new FlowExecutionStatus(FlowExecutionStatus.COMPLETED.getName());
      } else {
        return new FlowExecutionStatus(FlowExecutionStatus.FAILED.getName());
      }
    }
  }
  ```

  ```java
  @Bean
  public Job job() {
    return jobBuilderFactory.get("conditionalJob")
      .start(firstStep())
      .next(decider())
      .from(decider())
      .on("FAILED").to(failureStep())
      .from(decider())
      .on("*").to(successStep())
      .end()
      .build();
  }
  
  @Bean
  public JobExecutionDecider decider() {
    return new RandomDecider();
  }
  ```
  
- 잡 종료하기

  - 잡 종료의 3가지 상태

    1. Completed

       - 배치 처리가 성공적으로 종료됨. 

       - 이후엔 동일한 파라미터로 다시 실행할 수 없다

       - 잡 빌더의 `end`메서드를 사용하면 됨

         ```java
         @Bean
         public Job job() {
           return jobBuilderFactory.get("conditionalJob")
             .start(firstStep())
             .on("FAILED").end()
             .from(firstStep()).on("*").to(successStep())
             .end()
             .build();
         }
         ```

         - `firstStep`이 `FAILED` 인 `ExitStatus`로 끝난다면 `BATCH_JOB_EXECUTION`에 `COMPLETED`가 저장되며 종료
         - `firstStep`이 `FAILED`이 아닌 `ExitStatus`로 끝난다면 `successStep`을 실행하고 `BATCH_JOB_EXECUTION`에 `COMPLETED`가 저장되며 종료

    2. Failed

       - 배치 처리가 성공적으로 완료되지 않음. 

       - 동일한 파라미터로 다시 실행할 수 있다

       - 잡 빌더의 `fail` 메서드를 사용하면 됨

         ```java
         @Bean
         public Job job() {
           return jobBuilderFactory.get("conditionalJob")
             .start(firstStep())
             .on("FAILED").fail()
             .from(firstStep()).on("*").to(successStep())
             .end()
             .build();
         }
         ```

         - `firstStep`이 `FAILED` 인 `ExitStatus`로 끝난다면 `JobRepository`에 잡 실패로 저장되며 종료 -> 나중에 재실행 가능
         - `firstStep`이 `FAILED`이 아닌 `ExitStatus`로 끝난다면 `successStep`을 실행하고 `BATCH_JOB_EXECUTION`에 `COMPLETED`가 저장되며 종료

    3. Stopped

       - 잡에 오류가 발생하지 않았지만 중단된 위치에서 잡을 다시 시작할 수 있다.

       - 스텝 사이에 사람의 개입이 필요하거나 다른 검사 처리가 필요한 상황에 유용하다

       - 잡 빌더의 `stopAndRestart` 메서드를 사용하면 됨

         ```java
         @Bean
         public Job job() {
           return jobBuilderFactory.get("conditionalJob")
             .start(firstStep())
             .on("FAILED").stopAndRestart(successStep())
             .from(firstStep()).on("*").to(successStep())
             .end()
             .build();
         }
         ```

         - `firstStep`이 `FAILED` 인 `ExitStatus`로 끝난다면 FAILED로 종료, 다음에 실행하면 `successStep`부터 실행 가능
         - `firstStep`이 `FAILED`이 아닌 `ExitStatus`로 끝난다면 `successStep`을 실행하고 `BATCH_JOB_EXECUTION`에 `COMPLETED`가 저장되며 종료

- 스텝의 순서를 외부화하는 3가지 방법

  1. 스텝의 시퀀스를 독자적인 플로우로 만드는 방법

     ```java
     @Bean
     public Job conditionalStepLogicJob() {
       return jobBuilderFactory.get("conditionalStepLogicJob")
         .start(preProcessingFlow())
         .next(runBatch())
         .end()
         .build();
     }
     
     @Bean
     public Flow preProcessingFlow() {
       return new FlowBuilder<Flow>("preProcessingFlow")
         .start(step1())
         .next(step2())
         .next(step3())
         .build();
     }
     ```

  2. 플로우 스텝을 사용하는 방법

     - 플로우를 스텝으로 래핑하고 잡 빌더로 전달한다

     ```java
     @Bean
     public Job conditionalStepLogicJob() {
       return jobBuilderFactory.get("conditionalStepLogicJob")
         .start(initializeBatch())
         .next(runBatch())
         .build();
     }
     
     @Bean
     public Step initializeBatch() {
       return stepBuilderFactory.get("initializeBatch")
         .flow(preProcessingFlow())
         .build();
     }
     
     @Bean
     public Flow preProcessingFlow() {
       return new FlowBuilder<Flow>("preProcessingFlow")
         .start(step1())
         .next(step2())
         .next(step3())
         .build();
     }
     ```

     - 위 코드처럼 플로우스텝을 사용하면 스프링 배치는 `step1`, `step2`, `step3`를 하나의 스텝처럼 기록한다 -> 개별 스텝을 집계하지 않고도 플로우의 영향을 전체적으로 볼 수 있다

  3. 잡 내에서 다른 잡을 호출하는 방법(스텝을 전혀 외부화하지 않는 방법)

     - 책 참조

<br/>

## 5장. `JobRepository`와 메타데이터

### JobRepository란?

- 스프링 배치 내에서 `JobRepository`를 말한 땐 둘 중 하나다
  1. `JobRepository` 인터페이스
  2. `JobRepository` 인터페이스를 구현해 데이터를 저장하는 데 사용되는 데이터 저장소 <- 이 절에선 주로 이걸 가리킨다

- 배치 잡 내부에서 바로 사용할 수 있는 데이터 저장소 2가지

  1. 관계형 데이터베이스

     ![Spring Batch Meta-Data ERD](https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/images/meta-data-erd.png)

     - `BATCH_JOB_INSTANCE` : 잡의 논리적 실행
     - `BATCH_JOB_EXECUTION` : 잡의 실제 실행 기록
     - `BATCH_JOB_EXECUTION_PARAMS` : 잡이 매번 실행될때마다 사용된 잡 파라미터 기록
     - `BATCH_JOB_EXECUTION_CONTEXT` : `JobExecution`의 `ExecutionContext` 기록
     - `BATCH_STEP_EXECUTION` : 스텝의 시작, 완료, 상태에 대한 메타데이터 기록
     - `BATCH_STEP_EXECUTION_CONTEXT` : `StepExecution`의 `ExecutionContext` 기록

  2. 인메모리 저장소

     - 개발 단계나 단위테스트를 수행할 때 사용할 수 있게 `Map`기반 인메모리 데이터베이스를 제공한다. 다음 절에서 다룬다.

### 배치 인프라스트럭쳐 config

`@EnableBatchProcessing`을 사용하면 `JobRepository`를 사용할 수 있다.

`JobRepository`를 비롯한 모든 스프링배치 인프라스트럭쳐를 커스터마이징을 하고 싶다면 `BatchConfigurer` 인터페이스를 사용하면 된다

- `BatchConfigurer` 인터페이스

  - 스프링 배치 인프라스트럭쳐 컴포넌트 구성을 커스터마이징하는데 사용되는 전략 인터페이스이다. (일반적으론 `DefaultBatchConfigurer` 을 상속해서 커스터마이징한다.)
  - `@EnableBatchProcessing`을 사용했을때 빈이 추가되는 과정
    1. `BatchConfigurer` 구현체에서 빈을 생성한다
    2. `SimpleBatchConfiguration`에서 스프링의 `ApplicationContext`에 생성한 빈을 등록한다

- `JobRepository`커스터마이징하기

  - 보통 `ApplicationContext`에 두 개 이상의 데이터소스가 존재할때 커스터마이징한다.
  - 예) 업무 데이터 용도의 데이터소스와 `JobRepository`용 데이터소스가 별도로 존재할때

  ```java
  public class CustomBatchConfigurer extends DefaultBatchConfigurer {
  
    @Autowired
    @Qualifier("repositoryDataSource") //"repositoryDataSource"가 어딘가 있다고 가정.
    private DataSource dataSource;
  
    @Override
    protected JobRepository createJobRepository() throws Exception {
      JobRepositoryFactoryBean factoryBean = new JobRepositoryFactoryBean();
      factoryBean.setDatabaseType(DatabaseType.MYSQL.getProductName());
      // 접두어 "BATCH_" -> "FOO_"
      factoryBean.setTablePrefix("FOO_");
      // 데이터 생성시 트랜잭션 격리레벨 "ISOLATION_SERIALIZED" -> "ISOLATION_REPEATABLE_READ"
      factoryBean.setIsolationLevelForCreate("ISOLATION_REPEATABLE_READ");
      factoryBean.setDataSource(this.dataSource);
      // 보통 아래의 두 메서드는 스프링 컨테이너가 호출해준다. 근데 create...메서드 모두는 스프링 컨테이너에 노출되지 않는다. 그래서 개발자가 직접 호출해줘야 한다.
      factoryBean.afterPropertiesSet();
      return factoryBean.getObject();
    }
  }
  ```

- `TransactionManager`커스터마이징하기

  ```java
  public class CustomBatchConfigurer extends DefaultBatchConfigurer {
  
    @Autowired
    @Qualifier("batchTransactionManager") //"batchTransactionManager"가 어딘가 있다고 가정.
    private PlatformTransactionManager transactionManager;
  
    @Override
    public PlatformTransactionManager getTransactionManager() {
      return this.transactionManager;
    }
  }
  ```

- `JobExplorer`커스터마이징하기

  - 배치 메타데이터를 읽기 전용으로 제공하고 싶을 때

  ```java
  public class CustomBatchConfigurer extends DefaultBatchConfigurer {
  
    @Autowired
    @Qualifier("repositoryDataSource")
    private DataSource dataSource;
  
    //JobExplorer와 JobRepository는 동일한 데이터 저장소를 사용하므로 함께 커스터마이징을 하는 게 좋다
    @Override
    protected JobRepository createJobRepository() throws Exception {
      JobRepositoryFactoryBean factoryBean = new JobRepositoryFactoryBean();
      factoryBean.setDatabaseType(DatabaseType.MYSQL.getProductName());
      factoryBean.setTablePrefix("FOO_");
      factoryBean.setIsolationLevelForCreate("ISOLATION_REPEATABLE_READ");
      factoryBean.setDataSource(this.dataSource);
      factoryBean.afterPropertiesSet();
      return factoryBean.getObject();
    }
    
    @Override
    protected JobExplorer createJobExplorer() throws Exception {
      JobExplorerFactoryBean factoryBean = new JobExplorerFactoryBean();
      factoryBean.setDataSource(this.dataSource);
      factoryBean.setTablePrefix("FOO_");
      factoryBean.afterPropertiesSet();
      return factoryBean.getObject();
    }
  }
  ```

- `JobLauncher`커스터마이징하기

  - 스프링 배치가 기본 제공하는 `SimpleJobLauncher` 외의 방식으로 커스터마이징하고 싶을때 (예 : 컨트롤러를 통해 잡 실행하려 할때)

- 데이터베이스 config

  ```yaml
  spring:
    datasource:
      driverClassName: ...
      url: ...
      username: ...
      password: ...
    batch:
      initialize-schema: ...
  ```

  - `initialize-schema` : 스프링부트가 스프링배치 스키마 스크립트를 실행하도록 지시
    - `always` : 애플리케이션을 실행할때마다 스크립트 실행. 개발 환경일때 사용하기 쉬움
    - `never` : 스크립트를 실행하지 않음
    - `embedded` : 내장 데이터베이스를 사용할때, 각 실행 시마다 데이터가 초기화된 데이터베이스 인스턴스를 사용한다는 가정으로 스크립트를 실행

### 잡 메타데이터 사용하기

어떻게 `JobRepository` 내의 정보를 얻을 수 있을까? 주로 `JobExplorer`을 사용한다.

- `JobExplorer`

  - `JobExplorer`은 `JobRepository`의 데이터에 접근하는 시작점이다.

  - 대부분의 배치 프레임워크 컴포넌트가 `JobRepository`를 사용해 잡 관련 정보에 접근하지만 `JobExplorer`은 데이터베이스에 직접 접근한다.

  - 예시 : 잡의 `JobInstance`가 얼마나 많이 실행됐는지, 각 `JobInstance`당 얼마나 많은 실제 실행이 있었는지 확인하는 config

  - ```java
    public class ExploringTasklet implements Tasklet {
    
      private JobExplorer explorer;
    
      public ExploringTasklet(JobExplorer explorer) {
        this.explorer = explorer;
      }
    
      @Override
      public RepeatStatus execute(StepContribution stepContribution, ChunkContext chunkContext) throws Exception {
        String jobName = chunkContext.getStepContext().getJobName();
        List<JobInstance> instances = explorer.getJobInstances(jobName, 0, Integer.MAX_VALUE);
        System.out.printf("%s 잡에는 %d개의 잡 인스턴스가 존재합니다.", jobName, instances.size());
    
        System.out.println("********************* 결과 *********************");
        for (JobInstance instance : instances) {
          List<JobExecution> jobExecutions = explorer.getJobExecutions(instance);
          System.out.printf("%d 인스턴스에는 %d개의 execution이 존재합니다.",
              instance.getInstanceId(), jobExecutions.size());
          for (JobExecution jobExecution : jobExecutions) {
            System.out.printf("\t%d execution의 ExitStatus 결과는 %s입니다.",
                jobExecution.getId(), jobExecution.getExitStatus());
          }
        }
        return RepeatStatus.FINISHED;
      }
    }
    ```

    ```java
    @Autowired
    private JobExplorer jobExplorer;
    
    @Bean
    public Job explorerJob() {
      return jobBuilderFactory.get("explorerJob")
        .start(explorerStep())
        .build();
    }
    
    @Bean
    public Step explorerStep() {
      return stepBuilderFactory.get("explorerStep")
        .tasklet(explorerTasklet())
        .build();
    }
    
    @Bean
    public Tasklet explorerTasklet() {
      return new ExploringTasklet(jobExplorer);
    }
    ```

<br/>

## 6장. 잡 실행하기

### 스프링 부트로 배치 잡 시작시키기

- 스프링부트는 `CommandLineRunner`와 `ApplicationRunner`라는 두가지 메커니즘을 이용해 실행시 로직을 수행한다

  - 두 인터페이스는 한개의 메서드(`run()` : 애플리케이션이 코드를 실행할 준비가 되면 호출됨)를 가지고있다
  - 스프링부트를 스프링배치와 함께 사용할땐 `JobLauncherCommandLineRunner`가 사용된다
    - 스프링부트가 `ApplicationContext`내에 구성된 모든 `CommandLineRunner`를 실행할 때 클래스패스에 `spring-boot-starter-batch`가 존재한다면 `JobLauncherCommandLineRunner`는 컨텍스트 내에서 찾아낸 모든 잡을 실행한다.
    - 이전 예제는 모두 이런식으로 작동했음

- 애플리케이션 기동 시에 실행할 잡 정의하는 법

  - 애플리케이션이 기동될때 잡이 실행되지 않도록 `spring.batch.job.enabled`를 false로 설정해야 한다 (기본값은 true)

  ```java
  public static void main(String[] args) {
    SpringApplication application = new SpringApplication(BatchApplication.class);
    Properties properties = new Properties();
    properties.put("spring.batch.job.enable", false);
    application.setDefaultProperties(properties);
    application.run(args);
  }
  ```

- 컨텍스트의 여러 잡 중 특정 잡만 실행하는 법

  - `spring.batch.job.names` 프로퍼티 사용

### REST 방식으로 잡 실행하기

- 컨트롤러와 `JobLauncher.run(Job, JobParameters)`을 연결시키면 된다

- 스프링 배치는 기본적으로 `JobLauncher`의 구현체인 `SimpleJobLauncher`을 제공한다

  - `SimpleJobLauncher`은 `JobParameters`에 대한 조작을 제공하지 않으므로 전달되기 전에 조작해야 한다.

- `JobLauncher`가 사용하는 `TaskExecutor`을 구성하여 동기식/비동기식을 선택할 수 있다.

  - `SimpleJobLauncher`은 기본적으로 동기식 (호출자와 동일한 스레드에서 잡이 수행됨)
  - 잡이 오래 걸리는경우 비동기가 적절할 수도 있음 (이럴땐 `JobExecution`의 id만 반환됨)

- 잡 파라미터를 자동으로 증가시키고 싶다면? `JobParametersBuilder.getNextJobParameters` 이용.

  ```java
  // inputJobParameters은 입력받은 잡 파라미터, JobExplorer은 autowired
  JobParameters jobParameters = new JobParametersBuilder(inputJobParameters, jobExplorer)
    .getNextJobParameters(job) //입력받은 job 정보로 찾은 job(incrementer config가 되어 있어야 함)
    .toJobParameters();
  return jobLauncher.run(job, jobParameters).getExitStatus();
  ```

- 쿼츠로 스케줄링하기

  - 쿼츠의 컴포넌트
    - 스케줄러 : 연관된 트리거가 작동할 때 잡을 실행하는 역할
      - `SchedulerFactory`를 통해 가져올 수 있음
      - `JobDetails` 및 트리거의 저장소 기능
    - 트리거 : 작업 실행 시점
      - 트리거가 작동돼 쿼츠에게 잡을 실행하도록 지시하면 잡의 개별 실행을 정의하는 `JobDetails` 객체가 생성됨
    - 잡 : 실행할 작업의 단위
    
  - config

    ```java
    //배치 잡을 기동하는 쿼츠 잡
    //일정 이벤트가 발생할 때 잡을 실행
    public class BatchScheduledJob extends QuartzJobBean {
    
      @Autowired
      private Job job;
    
      @Autowired
      private JobExplorer jobExplorer;
    
      @Autowired
      private JobLauncher jobLauncher;
    
      @Override
      protected void executeInternal(JobExecutionContext context) {
        JobParameters jobParameters = new JobParametersBuilder(this.jobExplorer)
            .getNextJobParameters(this.job)
            .toJobParameters();
    
        try {
          this.jobLauncher.run(this.job, jobParameters);
        } catch (Exception e) {
          e.printStackTrace();
        }
      }
    }
    ```

    ```java
    @Configuration
    public class QuartzConfig {
    
      // Trigger: 스케줄과 JobDetail을 연결함
      @Bean
      public Trigger jobTrigger() {
        SimpleScheduleBuilder scheduleBuilder = SimpleScheduleBuilder.simpleSchedule()
            .withIntervalInSeconds(5).withRepeatCount(4); // 5초마다 실행, 4번 반복 (총 5번 실행됨)
    
        return TriggerBuilder.newTrigger()
            .forJob(quartzJobDetail())
            .withSchedule(scheduleBuilder)
            .build();
      }
    
      // JobDetail: 실행할 쿼츠 잡 수행 시에 사용되는 메타데이터
      @Bean
      public JobDetail quartzJobDetail() {
        return JobBuilder.newJob(BatchScheduledJob.class)
            .storeDurably()
            .build();
      }
    }
    ```

### 잡 중지하기

- 예

  - 스텝1. 거래파일(`transaction.csv`) 불러옴

    ```
    3985729387,2010-01-08 12:15:26,523.65 // 계좌번호,타임스탬프,금액(양수:입금, 음수:출금)
    3985729387,2010-01-08 1:28:58,-25.83
    2 // 총 레코드 수
    ```

  - 스텝2. 거래 정보를 `transaction` 테이블에 저장 -> `account_summary` 테이블에 적용

    - `transaction`테이블의 컬럼 : id, timestamp, amount, account_summary_id
    - `account_summary`테이블의 컬럼 : id, account_number, current_balance

  - 스텝3. 요약파일(`summary.csv`) 생성

    ```
    3985729387,497.72 // 계좌번호, 잔액
    ```

- 위 예에서 중지 트랜지션을 사용해 중지하도록 구성된 잡을 만들고, 재시작 위치를 지정하는 방법을 알아보자.

- 

### 재시작 제어하기













<br/>
