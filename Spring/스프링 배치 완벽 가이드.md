# 스프링 배치 완벽 가이드 2/e

## 2장. 스프링 배치

### 스텝

- 잡을 구성하는 독립된 작업의 단위
- 스텝은 두가지 유형이 있음
  1. tasklet기반 스텝
     - 비교적 더 간단함
     - `Tasklet`을 구현하면 됨. 스텝이 중지될 때까지 `execute`메서드가 계속 반복해서 수행된다
     - 초기화, 저장 프로시저 실행, 알림 전송 등과 같은 잡에서 사용
  2. chunk기반 스텝
     - 약간 더 복잡함
     - 아이템 기반 처리에 사용
     - `ItemReader`, `ItemProcessor`(필수x), `ItemWriter`으로 구성
- 스텝을 분리하는 것의 이점
  1. 유연성 : 재사용할 수 있도록 여러 빌더 클래스 제공
  2. 유지보수성 : 각 스텝은 독립적 -> 여러 잡에서 재사용 가능
  3. 확장성 : 스텝을 병렬로 실행할 수 있는 등의 확장 가능한 기능 제공
  4. 신뢰성 : 오류 처리 방법 제공

### `JobRepository`

- 다양한 배치 수행과 관련된 수치 데이터, 잡의 상태를 유지/관리
- 실행된 스텝, 현재 상태, 읽은 아이템 수, 처리된 아이템 수 등이 저장됨
- 관계형 데이터베이스 사용
- 스프링 배치 내의 대부분의 주요 컴포넌트가 공유

### `JobLauncher`

- `Job.execute`를 실행하는 역할
- 잡의 재실행 가능 여부 검증, 잡의 실행 방법, 파라미터 유효성 검증 등의 처리도 함

### `Job`, `JobInstance`, `JobExecution`

- `JobInstance` : 배치 잡의 논리적인 실행. "잡의 이름"과 "식별 파라미터"로써 유일하게 존재한다.
- `JobExecution` : 배치 잡의 실제 실행. 잡을 구동할때마다 새로운 JobExecution을 얻는다.

-> 한 잡을 같은 파라미터를 2번 실행했는데 첫번째는 실패, 두번째는 성공했다면 `JobInstance`는 1개, `JobExecution`는 2개

### 병렬화 방법

1. 다중 스레드 스텝을 통한 잡 분할
   - 잡은 청크라는 블록 단위로 처리되도록 구성됨
   - 각 청크는 독립적인 트랜잭션으로 처리됨
   - 일반적으로 각 청크는 연속해서 처리됨
   - 여러 스레드를 사용하도록 변경하면 처리량을 늘릴 수 있다
2. 스텝을 병렬로 실행
   - 각 스텝이 연관이 없다면 병렬로 실행하는게 효율적
3. 비동기 `ItemProcessor`/`ItemWriter` 구성
   - `AsynchronousItemProcessor` , `AsynchronousItemWriter` 등을 사용할 수 있다
4. 원격 청킹
   - 메시지 브로커등을 통해 여러 JVM에서 처리를 분산할 수 있다
   - 단 네트워크 사용량이 매우 많아질 수 있다
5. 파티셔닝

### Hello world!

```java
@EnableBatchProcessing
@SpringBootApplication
public class BatchApplication {
  
  @Autowired
  private JobBuilderFactory jobBuilderFactory;
  @Autowired
  private StepBuilderFactory stepBuilderFactory;

  @Bean
  public Step step() {
    return stepBuilderFactory.get("step1")
        .tasklet(new Tasklet() {
          @Override
          public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext)
              throws Exception {
            System.out.println("Hello, World!");
            return RepeatStatus.FINISHED;
          }
        }).build();
  }

  @Bean
  public Job job() {
    return jobBuilderFactory.get("job")
        .start(step())
        .build();
  }

  public static void main(String[] args) {
    SpringApplication.run(BatchApplication.class, args);
  }
}
```

- 실행하면 "Hello, World!"가 출력되고 종료된다.
- 실제로 일어난 일
  1. `@SpringBootApplication`이 스프링부트를 부트스트랩한다
  2. `ApplicationContext` 생성됨
  3. 스프링배치가 클래스 경로에 있어서` JobLauncherCommandLineRunner`가 실행됨
  4. 잡이 수행되어 첫번째 스텝이 실행됨(이때 트랜잭션이 시작됨)
  5. `Tasklet`이 실행됨
  6. 결과가 `JobRepository`에 갱신됨

<br/>

## 3장. 예제 잡 애플리케이션

### 월별 은행 거래명세서 예제 요구사항

- 매일 밤 수행됨
- 지난 달 거래 정보를 사용해 거래명세서 생성
- 기존 계좌에서 거래 내역을 적용한 후 각 계좌별로 거래명세서를 생성

### 살펴볼 배치 개념

- 다양한 입출력 방식
- 오류 처리
- 확장성

### 배치 처리가 수행하는 기능

1. 제공된 입력 파일을 기반으로 고객 정보 갱신하기
2. 데이터베이스에 저장된 모든 고객의 거래 정보 가져오기
3. 계좌 잔액으로 계좌 정보 갱신하기
4. 지난 한 달 동안의 은행 계좌 파일 인쇄하기

<br/>

## 4장. 잡과 스텝 이해하기

### 잡은...

- 유일하다
  - 잡을 여러번 실행하려고 동일한 잡을 여러번 정의할 필요가 없더
- 순서를 가진 여러 스텝의 목록이다
  - 잡에서 스텝의 순서는 중요하다
  - 모든 스텝을 논리적인 순서대로 실행할 수 있다
- 처음부터 끝까지 실행 가능하다
  - 외부 의존성 없이 실행할 수 있다
- 독립적이다
  - 의존성을 관리할 수 있어야 한다

### 잡의 생명주기

- 잡은 생명주기대로 실행된다.
- 잡의 실행은 잡 러너에서 시작된다. 
- 잡 러너 : 잡의 이름과 여러 파라미터를 받아들여 잡을 실행시키는 역할. 스프링배치는 두가지를 제공한다
  1. `CommandLineJobRunner`
     - 스크립트를 이용하거나 명령행에서 직접 잡을 실행할 때 사용
     - 스프링을 부트스트랩하고, 전달받은 파라미터를 사용해 요청된 잡을 실행한다
  2. `JobRegistryBackgroundJobRunner`
     - `JobRegistry`를 생성하는데 사용
     - `JobRegistry`란? 스케줄러를 사용해 잡을 실행한다면 생성되는것. 스프링이 부트스트랩될 때 실행 가능한 잡을 가지고 있음
- 이와 별개로 스프링부트가 제공하는 `JobLauncherCommandLineRunner`도 있음.
  - 별도의 config가 없다면 `ApplicationContext`에 정의된 모든 잡 빈을 실행함
  - 이 책에선 이걸 사용
- `JobInstance`
  - 잡 이름 + 파라미터로 식별
    - `BATCH_JOB_INSTANCE`와 `BATCH_JOB_EXECUTION_PARAMS` 사용
  - 성공적으로 완료된 `JobExecution`이 있다면 완료된 것으로 간주됨.
  - 한 번 성공하면 다시 실행시킬 수 없음
- `JobExecution`
  - 잡 실행의 실제 시도
  - 시도할때마다 새로운 `JobExecution` 생성되고 `BATCH_JOB_EXECUTION` 테이블의 레코드로 저장됨
  - `JobExecution`이 실행될때의 상태는 `BATCH_JOB_EXECUTION_CONTEXT`에 저장됨 -> 오류 발생 시 그 시점부터 실행 가능

### 잡 config
