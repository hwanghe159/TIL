# 스프링 배치 완벽 가이드 2/e

## 2장. 스프링 배치

### 스텝

- 잡을 구성하는 독립된 작업의 단위
- 스텝은 두가지 유형이 있음
  1. tasklet기반 스텝
     - 비교적 더 간단함
     - `Tasklet`을 구현하면 됨. 스텝이 중지될 때까지 `execute`메서드가 계속 반복해서 수행된다
     - 초기화, 저장 프로시저 실행, 알림 전송 등과 같은 잡에서 사용
  2. chunk기반 스텝
     - 약간 더 복잡함
     - 아이템 기반 처리에 사용
     - `ItemReader`, `ItemProcessor`(필수x), `ItemWriter`으로 구성
- 스텝을 분리하는 것의 이점
  1. 유연성 : 재사용할 수 있도록 여러 빌더 클래스 제공
  2. 유지보수성 : 각 스텝은 독립적 -> 여러 잡에서 재사용 가능
  3. 확장성 : 스텝을 병렬로 실행할 수 있는 등의 확장 가능한 기능 제공
  4. 신뢰성 : 오류 처리 방법 제공

### `JobRepository`

- 다양한 배치 수행과 관련된 수치 데이터, 잡의 상태를 유지/관리
- 실행된 스텝, 현재 상태, 읽은 아이템 수, 처리된 아이템 수 등이 저장됨
- 관계형 데이터베이스 사용
- 스프링 배치 내의 대부분의 주요 컴포넌트가 공유

### `JobLauncher`

- `Job.execute`를 실행하는 역할
- 잡의 재실행 가능 여부 검증, 잡의 실행 방법, 파라미터 유효성 검증 등의 처리도 함

### `Job`, `JobInstance`, `JobExecution`

- `JobInstance` : 배치 잡의 논리적인 실행. "잡의 이름"과 "식별 파라미터"로써 유일하게 존재한다.
- `JobExecution` : 배치 잡의 실제 실행. 잡을 구동할때마다 새로운 JobExecution을 얻는다.

-> 한 잡을 같은 파라미터를 2번 실행했는데 첫번째는 실패, 두번째는 성공했다면 `JobInstance`는 1개, `JobExecution`는 2개

### 병렬화 방법

1. 다중 스레드 스텝을 통한 잡 분할
   - 잡은 청크라는 블록 단위로 처리되도록 구성됨
   - 각 청크는 독립적인 트랜잭션으로 처리됨
   - 일반적으로 각 청크는 연속해서 처리됨
   - 여러 스레드를 사용하도록 변경하면 처리량을 늘릴 수 있다
2. 스텝을 병렬로 실행
   - 각 스텝이 연관이 없다면 병렬로 실행하는게 효율적
3. 비동기 `ItemProcessor`/`ItemWriter` 구성
   - `AsynchronousItemProcessor` , `AsynchronousItemWriter` 등을 사용할 수 있다
4. 원격 청킹
   - 메시지 브로커등을 통해 여러 JVM에서 처리를 분산할 수 있다
   - 단 네트워크 사용량이 매우 많아질 수 있다
5. 파티셔닝

### Hello world!

```java
@EnableBatchProcessing
@SpringBootApplication
public class BatchApplication {
  
  @Autowired
  private JobBuilderFactory jobBuilderFactory;
  @Autowired
  private StepBuilderFactory stepBuilderFactory;

  @Bean
  public Step step() {
    return stepBuilderFactory.get("step1")
        .tasklet(new Tasklet() {
          @Override
          public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext)
              throws Exception {
            System.out.println("Hello, World!");
            return RepeatStatus.FINISHED;
          }
        }).build();
  }

  @Bean
  public Job job() {
    return jobBuilderFactory.get("job")
        .start(step())
        .build();
  }

  public static void main(String[] args) {
    SpringApplication.run(BatchApplication.class, args);
  }
}
```

- 실행하면 "Hello, World!"가 출력되고 종료된다.
- 실제로 일어난 일
  1. `@SpringBootApplication`이 스프링부트를 부트스트랩한다
  2. `ApplicationContext` 생성됨
  3. 스프링배치가 클래스 경로에 있어서` JobLauncherCommandLineRunner`가 실행됨
  4. 잡이 수행되어 첫번째 스텝이 실행됨(이때 트랜잭션이 시작됨)
  5. `Tasklet`이 실행됨
  6. 결과가 `JobRepository`에 갱신됨

<br/>

## 3장. 예제 잡 애플리케이션

### 월별 은행 거래명세서 예제 요구사항

- 매일 밤 수행됨
- 지난 달 거래 정보를 사용해 거래명세서 생성
- 기존 계좌에서 거래 내역을 적용한 후 각 계좌별로 거래명세서를 생성

### 살펴볼 배치 개념

- 다양한 입출력 방식
- 오류 처리
- 확장성

### 배치 처리가 수행하는 기능

1. 제공된 입력 파일을 기반으로 고객 정보 갱신하기
2. 데이터베이스에 저장된 모든 고객의 거래 정보 가져오기
3. 계좌 잔액으로 계좌 정보 갱신하기
4. 지난 한 달 동안의 은행 계좌 파일 인쇄하기

<br/>

## 4장. 잡과 스텝 이해하기

### 잡은...

- 유일하다
  - 잡을 여러번 실행하려고 동일한 잡을 여러번 정의할 필요가 없다
- 순서를 가진 여러 스텝의 목록이다
  - 잡에서 스텝의 순서는 중요하다
  - 모든 스텝을 논리적인 순서대로 실행할 수 있다
- 처음부터 끝까지 실행 가능하다
  - 외부 의존성 없이 실행할 수 있다
- 독립적이다
  - 의존성을 관리할 수 있어야 한다

### 잡의 생명주기

- 잡은 생명주기대로 실행된다.
- 잡의 실행은 잡 러너에서 시작된다. 
- 잡 러너 : 잡의 이름과 여러 파라미터를 받아들여 잡을 실행시키는 역할. 스프링배치는 두가지를 제공한다
  1. `CommandLineJobRunner`
     - 스크립트를 이용하거나 명령행에서 직접 잡을 실행할 때 사용
     - 스프링을 부트스트랩하고, 전달받은 파라미터를 사용해 요청된 잡을 실행한다
  2. `JobRegistryBackgroundJobRunner`
     - `JobRegistry`를 생성하는데 사용
     - `JobRegistry`란? 스케줄러를 사용해 잡을 실행한다면 생성되는것. 스프링이 부트스트랩될 때 실행 가능한 잡을 가지고 있음
- 이와 별개로 스프링부트가 제공하는 `JobLauncherCommandLineRunner`도 있음.
  - 별도의 config가 없다면 `ApplicationContext`에 정의된 모든 잡 빈을 실행함
  - 이 책에선 이걸 사용
- `JobInstance`
  - 잡 이름 + 파라미터로 식별
    - `BATCH_JOB_INSTANCE`와 `BATCH_JOB_EXECUTION_PARAMS` 사용
  - 성공적으로 완료된 `JobExecution`이 있다면 완료된 것으로 간주됨.
  - 한 번 성공하면 다시 실행시킬 수 없음
- `JobExecution`
  - 잡 실행의 실제 시도
  - 시도할때마다 새로운 `JobExecution` 생성되고 `BATCH_JOB_EXECUTION` 테이블의 레코드로 저장됨
  - `JobExecution`이 실행될때의 상태는 `BATCH_JOB_EXECUTION_CONTEXT`에 저장됨 -> 오류 발생 시 그 시점부터 실행 가능

### 잡 config

- `CommandLineJobRunner`에 파라미터 전달하기 : `java -jar demo.jar name=junho`

  - 그럼 파라미터들은 `JobParameters`와 매핑됨 (`Map<String, JobParameter>`의 래퍼)
  - 타입 변환기능을 이용하고 싶으면 타입도 같이 넘겨준다(소문자로) : `java -jar demo.jar executionDate(date)=2020/12/27`
  - 전달한 파라미터는 `BATCH_JOB_EXECUTION_PARAMS` 에 저장됨
  - 식별에 사용하고 싶지 않는 파라미터는 `-`를 붙이면 됨 : `java -jar demo.jar executionDate(date)=2020/12/27 -name=junho`

- 잡 파라미터에 접근하는 방법

  1. `chunkContext`

     ```java
     @Bean
     public Tasklet helloWorldTasklet() {
       return ((contribution, chunkContext) -> {
         String name = (String) chunkContext.getStepContext()
             .getJobParameters()
             .get("name");
         System.out.println(String.format("Hello, %s!", name));
         return RepeatStatus.FINISHED;
       });
     }
     ```

     - `StepContribution contribution` : 아직 커밋되지 않은 현재 트랜잭션에 대한 정보(쓰기수, 읽기수 등)
     - `ChunkContext chunkContext` : 실행 시점의 잡 상태를 제공. 테스크릿 내에서는 처리중인 청크와 관련된 정보도 갖고있음

  2. 늦은 바인딩

     ```java
     @StepScope
     @Bean
     public Tasklet helloWorldTasklet(@Value("#{jobParameters['name']}") String name) {
       return ((contribution, chunkContext) -> {
         System.out.println(String.format("Hello, %s!", name));
         return RepeatStatus.FINISHED;
       });
     }
     ```

     - 스코프 기능을 사용하면 늦은 바인딩을 쉽게 사용할 수 있다
     - 스텝 스코프, 잡 스코프 : 스텝, 잡의 실행범위에 들어갈 때까지 빈 생성을 지연시키는 기능

- 스프링 배치의 파라미터 특화 기능

  1. 파라미터 유효성 검증 기능

     - `JobParametersValidator` 인터페이스를 구현하고 잡 config에 넣어주면 됨
     - 필수 파라미터와 옵션 파라미터에 대한 검증만 하고 싶으면? `DefaultJobParametersValidator`
     - 여러 검증 구현체를 적용하고 싶으면? `CompositeJobParametersValidator`

  2. 파라미터 증가 기능

     ```java
     @Bean
     public Job job(){
       return jobBuilderFactory.get("basicJob")
           .start(step1())
           .validator(validator()) //CompositeJobParametersValidator
           .incrementer(new RunIdIncrementer()) //JobParametersIncrementer
           .build();
     }
     ```

     - `JobParametersIncrementer` : 파라미터를 고유하게 생성할 수 있도록 해줌
     - `RunIdIncrementer`를 추가하면 validator에 `run.id` 를 옵션 파라미터에 추가해야 한다
     - 날짜를 증가시키는 것 같이 커스텀하게 만들고 싶다면 `JobParametersIncrementer` 을 구현하고 잡 config에 넣고 옵션 파라미터에 추가하면 된다

- 잡 리스너

  - 잡 리스너로 잡의 생명주기의 여러 시점에 로직을 추가할 수 있다

  - 잡 리스너 작성 방법

    1. `JobExecutionListener` 인터페이스 구현

       - `beforeJob`과 `afterJob` 메서드가 있다 : 잡 실행 전 초기화, 잡 실행 후 정리, 알림 등등에 이용한다

       - 구현 후 Job config에 넣음

         ```java
         @Bean
         public Job job(){
           return jobBuilderFactory.get("basicJob")
               .start(step1())
               .validator(validator())
               .incrementer(new RunIdIncrementer())
               .listener(new JobLoggerListener()) // <--
               .build();
         }
         ```

    2. `@BeforeJob`, `@AfterJob` 사용

       - `JobExecutionListener` 을 implements할 필요가 없다

       - config가 살짝 다르다

         ```java
         @Bean
         public Job job(){
           return jobBuilderFactory.get("basicJob")
               .start(step1())
               .validator(validator())
               .incrementer(new RunIdIncrementer())
               .listener(JobListenerFactoryBean.getListener(new JobLoggerListener())) // <--
               .build();
         }
         ```

  - 리스너는 잡 리스너 외에도 스텝, 리더, 라이터 등에도 있다

- `ExecutionContext`

  - 잡 상태는 `JobExecution`의 `ExecutionContext`에 저장된다

  - `ExecutionContext`은 기본적으로 잡의 세션이다

  - `ExecutionContext`에 담겨있는 모든 게 `JobRepository`에 저장된다

  - 조작하는 방법

    1. `JobExecution` 또는 `StepExecution`으로부터 가져오기

       ```java
       public class HelloWorldTasklet implements Tasklet {
       
         @Override
         public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
           ExecutionContext jobContext = chunkContext.getStepContext()
               .getStepExecution() //getStepExecutionContext()는 변경사항이 반영되지 않음
               .getJobExecution()
               .getExecutionContext();
           jobContext.put(...); // <-- 조작
         
         }
       }
       ```

    2. `StepExecution`의 `ExecutionContext`에 있는 키를 `JobExecution`의 `ExecutionContext`로 승격하기

       - ?

    3. `ItemStream` 인터페이스 사용

       - 추후 다룸

  - 저장하는 법

    - 잡이 처리되는 동안 각 청크를 커밋하면서 잡과 스텝의 현재 `ExecutionContext`를 데이터베이스에 저장한다
    - `BATCH_JOB_EXECUTION_CONTEXT` 테이블
      - `JOB_EXECUTION_ID` 컬럼 : 관련된 `JobExecution`의 참조
      - `SHORT_CONTEXT` 컬럼 : `ExecutionContext`의 json 표현. 배치 처리가 진행되면서 갱신됨
      - `SERIALIZED_CONTEXT` 컬럼 : 직렬화된 자바 객체

### 스텝

- 잡이 전체적인 처리를 정의한다면, 스텝은 잡의 구성 요소
- 독립적이고 순차적으로 배치 처리를 수행 -> 스텝을 "배치 프로세서"라고 부름
- 자체적으로 입력을 처리, 자체적으로 처리기를 가짐, 자체적으로 출력을 처리함
- 트랜잭션을 스텝 내에서 이뤄짐
- 스텝에서 테이터를 처리하는 방법 : 태스크릿 처리, 청크 처리
  1. 태스크릿 모델
     - `Tasklet` 인터페이스를 사용. `execute`메서드가 `RepeatStatus.FINISHED`를 반환할때까지 트랜잭션 범위 내에서 반복적으로 실행
  2. 청크 처리
     - `ItemReader`, `ItemProcessor`(필수x), `ItemWriter`로 구성
     - 이 컴포넌트들을 사용해서 레코드를 청크 또는 레코드 그룹 단위로 처리
     - 각 청크는 자체 트랜잭션으로 실행됨. 실패한다면 마지막으로 성공한 트랜잭션 이후부터 다시 시작

### 스텝 config

- 태스크릿 스텝을 만드는 유형

  1. 사용자가 작성한 코드를 마치 태스크릿 스텝처럼 실행하도록 하는 유형

  2. `Tasklet` 인터페이스를 구현하는 유형

     - `execute` 메서드를 구현하고, `RepeatStatus.CONTINUABLE` 또는 `RepeatStatus.FINISHED`를 반환하면 된다
       - `RepeatStatus.CONTINUABLE` : 해당 태스크릿을 다시 실행하겠다는 뜻. 특정 태스크릿을 특정 조건이 만족할때까지 반복하고, 추적하고 싶다면 이 타입을 반환하면 된다
       - `RepeatStatus.FINISHED` : 처리의 성공여부에 관계없이 처리를 완료하고 다음 처리를 하겠다는 뜻

  3. `CallableTaskletAdapter` 구현체 사용

     - `Callable<RepeatStatus>` 의 구현체를 구성할 수 있게 해주는 어댑터.
     - 스텝의 특정 로직을 해당 스텝이 실행되는 스레드가 아닌 다른 스레드에서 실행하고 싶을때 사용함
     - 스텝이 실행되는 스레드와 별개의 스레드에서 태스크릿이 실행되지만 스텝과 병렬로 실행되는 건 아니다
     - `Callable` 객체가 유효한 `RepeatStatus` 객체를 반환하기 전에는 완료된 것으로 간주하지 않는다

     ```java
     @Bean
     public Step callableStep() {
       return stepBuilderFactory.get("callableStep")
           .tasklet(tasklet())
           .build();
     }
     
     @Bean
     public CallableTaskletAdapter tasklet() {
       CallableTaskletAdapter adapter = new CallableTaskletAdapter();
       adapter.setCallable(callableObject());
       return adapter;
     }
     
     @Bean
     public Callable<RepeatStatus> callableObject() {
       return () -> {
         System.out.println("이건 다른 스레드에서 실행됩니다.");
         return RepeatStatus.FINISHED;
       };
     }
     ```

  4. `MethodInvokingTaskletAdapter` 구현체 사용

     - 기존에 존재하던 다른 클래스 내의 메서드를 잡 내의 태스크릿처럼 실행할 수 있다
     - 기존 메서드 호출을 매핑하는 `Tasklet` 인터페이스의 구현체를 만들지 않을 수 있다.

     ```java
     @Bean
     public Step methodInvokingStep() {
       return stepBuilderFactory.get("methodInvokingStep")
           .tasklet(methodInvokingTasklet())
           .build();
     }
     
     @Bean
     public MethodInvokingTaskletAdapter methodInvokingTasklet() {
       MethodInvokingTaskletAdapter adapter = new MethodInvokingTaskletAdapter();
       adapter.setTargetObject(service()); //태스크릿으로 실행하고자 하는 메서드의 클래스
       adapter.setTargetMethod("method"); //메서드 이름
       return adapter;
     }
     ```

     - 정적 파라미터 셋을 구성하려면? 늦은 바인딩 이용

     ```java
     @StepScope
     @Bean
     public MethodInvokingTaskletAdapter methodInvokingTasklet(@Value("#{jobParameters['message']}") String message) {
       MethodInvokingTaskletAdapter adapter = new MethodInvokingTaskletAdapter();
       adapter.setTargetObject(service()); //태스크릿으로 실행하고자 하는 메서드의 클래스
       adapter.setTargetMethod("method"); //메서드 이름
       adapter.setArguments(new String[]{message}) //인자 목록
       return adapter;
     }
     ```

  5. `SystemCommandTasklet` 구현체 사용

     - 시스템 명령을 비동기로 실행할때 사용한다
     - 자세한 사용법은 책 참조

- 청크 기반 스텝

  - 청크는 커밋 간격에 의해 정의된다
    - 커밋 간격이 50이라면? "50개 읽기 -> 50개 처리 -> 50개 기록"을 반복

  ```java
  @Bean
  public Step step1() {
    return stepBuilderFactory.get("step1")
        .<String, String>chunk(10) //커밋 간격=10, 10개 단위로 레코드 처리한 후 커밋된ㄷ
        .reader(itemReader(null))
        .writer(itemWriter(null))
        .build();
  }
  
  @Bean
  public FlatFileItemReader<String> itemReader(@Value("#{#jobParameters['inputFile']}") Resource inputFile) {
    //생략
  }
  
  @Bean
  public FlatFileItemWriter<String> itemWriter(@Value("#{#jobParameters['outputFile']}") Resource outputFile) {
    //생략
  }
  ```

  - 청크 크기 config
