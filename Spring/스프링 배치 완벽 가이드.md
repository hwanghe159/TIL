# 스프링 배치 완벽 가이드 2/e

## 1장. 배치와 스프링

### 배치 처리란? 

- 상호작용이나 중단 없이 유한한 양의 데이터를 처리하는 것
- 일단 시작되면 아무런 개입 없이 어떤 형태로든 완료된다

### 배치 처리는 왜 필요한가?

1. 필요한 정보를 실제 처리가 시작되기 전에 미리 수집할 수 있다
2. 때로는 사업적으로 도움이 된다
3. 자원을 더 효율적으로 사용할 수 있다

### 배치 처리를 개발하는 데 기술적으로 해결해야 하는 과제들

1. (코드의) 사용성
   - 공통 컴포넌트를 쉽게 확장해 새로운 기능을 추가할 수 있는가?
   - 기존 컴포넌트를 변경할 때 시스템 전체에 미치는 영향을 알 수 있도록 단위테스트가 잘 마련돼있는가?
   - 잡이 실패할 때 디버깅에 오랜 시간을 소비하지 않고, 언제, 어디서, 왜 실패했는지 알 수 있는가?
2. 확장성
   - 배치가 처리할 수 있는 규모가 웹 애플리케이션의 규모보다 몇자리 수 이상 더 클 수 있다
3. 가용성
   - 필요할 때 바로 배치 처리를 수행할 수 있는가?
   - 허용된 시간 내에 잡을 수행함으로써 다른 시스템에 영향을 미치지 않게 할 수 있는가?
4. 보안
   - 민감한 데이터베이스 필드는 암호화돼 있는가?
   - 실수로 개인 정보를 로그로 남기지는 않는가?
   - 자격증명이 필요한가?

### 왜 자바로 배치를 처리하는가?

1. 유지 보수성
   - 스프링 프레임워크는 테스트 용이성이나 추상화같은 이점을 얻을 수 있도록 설계됐다
   - DI를 통해 객체간 결합을 제거할 수 있다
   - 테스트 도구를 활용하여 유지 보수시 발행할 수 있는 위험을 줄일 수 있다
   - JDBC 코드나 파일I/O API를 직접 다룰 필요 없다
   - 트랜잭션 및 커밋 횟수같은 것들을 제공하므로 실패시 무슨 일을 해야 하는지 관리할 필요가 없다
2. 유연성
   - 배치 처리가 가능한 플랫폼은 메인프레임, C++/UNIX 등이 있다
   - 위 방식들은 JVM의 유연성과 스프링 배치의 기능들을 제공하지 않는다
   - 스프링 배치는 유닉스 계열 또는 윈도우 서버, 데스크탑 등등 어디에서든 돌아간다
   - 웹 애플리케이션에서 이미 테스트 및 디버깅 된 서비스를 배치 처리에서 동일하게 바로 사용할 수 있다
3. 확장성
   - 단일 서버 내의 단일 JVM에서 배치처리를 수행할수도, 나눠서 수행할수도 있다.
   - 클라우드 리소스를 사용하여 배치처리할 수 있다
4. 개발 리소스
   - 배치 처리 코드는 수명이 길기 때문에 개발 인력을 구하는 것도 중요하다.
   - 스프링 개발자는 많다
5. 지원
   - 온라인 커뮤니티가 잘 갖춰져 있다
   - 소스코드에 접근할 수 있고 비용을 지불하면 기술 지원을 받을 수 있다
6. 비용
   - 스프링 배치는 가장 저렴한 솔루션

### 스프링 배치의 사용 사례

- ETL(추출, 변환, 적재) 처리
  - 스프링 배치의 청크기반 처리 및 확장 기능은 ETL워크로드에 자연스럽게 들어맞는다
- 데이터 마이그레이션
  - 잡을 기동하는데 많은 코딩이 필요없다
  - 마이그레이션에 필요한 커밋 횟수 측정이나 롤백 기능을 제공한다
- 병렬 처리
  - 멀티 코어 도는 멀티 서버에 처리를 분산하는 기능을 제공한다

### 스프링 배치 프레임워크

- 스프링 배치의 구조

  - 레이어 구조로 조립된 세개의 티어로 이뤄져 있다

    ![Figure 1.1: Spring Batch Layered Architecture](https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/images/spring-batch-layers.png)

  - 애플리케이션 레이어

    - 코어 레이어와 상호작용하는데 대부분의 시간을 소비한다

  - 코어 레이어

    - 배치 도메인을 정의하는 모든 부분이 포함된다
    - `Job`, `Step`, `JobLauncher`, `JobParameters` 등이 있다

  - 인프라스트럭쳐 레이어

    - 파일, 데이터베이스 등으로부터 읽고 쓸 수 있게 한다
    - 잡 실패 후 재시도될 때 어떤 일을 수행할 지 다룰 수 있게 한다

- 잡 config

  - 중단이나 상호작용 없이 처음부터 끝까지 실행되는 처리

  - 여러 개의 스텝이 모여 이뤄질 수 있다

  - 여러 방법으로 구성할 수 있지만, 아래는 자바 구성 클래스에 구성하는 방법을 보여준다

    ```java
    @Bean
    public AccountTasklet accountTasklet() {
      // 커스텀 컴포넌트. 스프링 배치는 AccountTasklet이 완료될때까지 execute메서드를 반복해서 호출한다. (각각은 새 트랜잭션으로 호출됨)
      return new AccountTasklet();
    }
    
    @Bean
    public Job accountJob() {
      Step accountStep = this.stepBuilderFactory.get("accountStep")
        .tasklet(accountTasklet())
        .build();
      
      return this.jobBuilderFactory.get("accountJob")
        .start("accountStep")
        .build();
    }
    ```

- 잡 관리

  - 실패해서 재실행할 때 필요한 잡의 상태 정보를 유지해준다
  - 실패했을 때 데이터 무결성을 유지할 수 있도록 트랜잭션을 관리해준다

- 로컬 및 원격 병렬화

  - 각 커밋 간격내의 처리를 스레드 풀에서 가져온 자체 스레드에서 처리하는 단순 스레드 기반 방식
  - 병렬 청크/스텝 처리, 원격 청크 처리, 파티셔닝 기능
  - 모든 스텝을 병렬로 실행하기, 파티셔닝을 통해 원격 마스터로부터 작업 단위를 제공받는 워커의 그리드 구성하기 등 

- IO 표준화하기

  - 다양한 형식을 읽거나 쓰는 일은 간단한 config로 해결할 수 있다

- 스프링 배치 에코시스템

  - 스프링부트
  - 스프링 클라우드 태스크
  - 스프링 클라우드 데이터 플로우

<br/>

## 2장. 스프링 배치

### 스텝

- 잡을 구성하는 독립된 작업의 단위
- 스텝은 두가지 유형이 있음
  1. tasklet기반 스텝
     - 비교적 더 간단함
     - `Tasklet`을 구현하면 됨. 스텝이 중지될 때까지 `execute`메서드가 계속 반복해서 수행된다
     - 초기화, 저장 프로시저 실행, 알림 전송 등과 같은 잡에서 사용
  2. chunk기반 스텝
     - 약간 더 복잡함
     - 아이템 기반 처리에 사용
     - `ItemReader`, `ItemProcessor`(필수x), `ItemWriter`으로 구성
- 스텝을 분리하는 것의 이점
  1. 유연성 : 재사용할 수 있도록 여러 빌더 클래스 제공
  2. 유지보수성 : 각 스텝은 독립적 -> 각 스텝의 단위테스트, 디버그, 변경 등을 할 수 있음. 또 독립적이기 때문에 여러 잡에서 재사용 가능
  3. 확장성 : 스텝을 병렬로 실행할 수 있는 등의 확장 가능한 기능 제공
  4. 신뢰성 : 오류 처리 방법(예외 발생시 재시도, 건너뛰기 등) 제공

### `JobRepository`

- 다양한 배치 수행과 관련된 수치 데이터, 잡의 상태를 유지/관리
- 실행된 스텝, 현재 상태, 읽은 아이템 수, 처리된 아이템 수 등이 저장됨
- 관계형 데이터베이스 사용
- 스프링 배치 내의 대부분의 주요 컴포넌트가 공유

### `JobLauncher`

- `Job.execute`를 실행하는 역할
- 잡이 재실행 가능한지, 잡을 어떻게 실행할건지(현재 스레드에서 할지, 스레드 풀을 통해 실행할지), 파라미터 유효성 검증 등의 처리도 함

### `Job`, `JobInstance`, `JobExecution`

- `JobInstance` : 배치 잡의 논리적인 실행. "잡의 이름"과 "식별 파라미터"로 식별할 수 있다.
- `JobExecution` : 배치 잡의 실제 실행. 잡을 구동할때마다 새로운 JobExecution을 얻는다.

-> 한 잡을 같은 파라미터로 2번 실행했는데 첫번째는 실패, 두번째는 성공했다면 `JobInstance`는 1개, `JobExecution`는 2개

### `StepExecution`

- `JobExecution`이 잡의 실제 실행을 나타내듯이 `StepExecution`은 스텝의 실제 실행을 나타낸다
- `StepInstance`라는 개념은 존재하지 않는다

### 병렬화 방법

1. 다중 스레드 스텝을 이용해 잡 나누기
   - 잡은 청크라는 블록 단위로 처리되도록 구성됨
   - 각 청크는 독립적인 트랜잭션으로 처리됨
   - 일반적으로 각 청크는 연속해서 처리됨
   - 여러 스레드를 사용하도록 변경하면 처리량을 늘릴 수 있다
2. 스텝을 병렬로 실행
   - 각 스텝이 연관이 없다면 병렬로 실행하는게 효율적
3. 비동기 `ItemProcessor`/`ItemWriter` 구성
   - `AsynchronousItemProcessor` , `AsynchronousItemWriter` 등을 사용할 수 있다
4. 원격 청킹
   - 메시지 브로커등을 통해 여러 JVM에서 처리를 분산할 수 있다
   - 단 네트워크 사용량이 매우 많아질 수 있다
5. 파티셔닝
   - 원격 파티셔닝과 로컬 파티셔닝을 모두 지원한다

### Hello world!

```java
@EnableBatchProcessing //배치 인프라스터럭쳐를 부트스트랩하는데 사용됨
@SpringBootApplication
public class BatchApplication {
  
  @Autowired
  private JobBuilderFactory jobBuilderFactory;
  @Autowired
  private StepBuilderFactory stepBuilderFactory;

  @Bean
  public Step step() {
    return stepBuilderFactory.get("step1")
        .tasklet(new Tasklet() {
          @Override
          public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext)
              throws Exception {
            System.out.println("Hello, World!");
            return RepeatStatus.FINISHED; //tasklet이 완료됐음을 스프링배치에게 알리는 역할
          }
        }).build();
  }

  @Bean
  public Job job() {
    return jobBuilderFactory.get("job")
        .start(step())
        .build();
  }

  public static void main(String[] args) {
    SpringApplication.run(BatchApplication.class, args);
  }
}
```

- 실행하면 "Hello, World!"가 출력되고 종료된다.
- 실제로 일어난 일
  1. `@SpringBootApplication`이 스프링부트를 부트스트랩한다
  2. `ApplicationContext` 생성됨
  3. 스프링배치가 클래스 경로에 있어서` JobLauncherCommandLineRunner`가 실행됨
  4. 잡이 수행되어 첫번째 스텝이 실행됨(이때 트랜잭션이 시작됨)
  5. `Tasklet`이 실행됨
  6. 결과가 `JobRepository`에 갱신됨

<br/>

## 3장. 예제 잡 애플리케이션

### 월별 은행 거래명세서 예제 요구사항

- 매일 밤 수행됨
- 지난 달 거래 정보를 사용해 거래명세서 생성
- 기존 계좌에서 거래 내역을 적용한 후 각 계좌별로 거래명세서를 생성

### 살펴볼 배치 개념

- 다양한 입출력 방식
- 오류 처리
- 확장성

### 배치 처리가 수행하는 기능

1. 제공된 입력 파일을 기반으로 고객 정보 갱신하기
2. 데이터베이스에 저장된 모든 고객의 거래 정보 가져오기
3. 계좌 잔액으로 계좌 정보 갱신하기
4. 지난 한 달 동안의 은행 계좌 파일 인쇄하기

<br/>

## 4장. 잡과 스텝 이해하기

### 잡은...

- 유일하다
  - 잡을 여러번 실행하려고 동일한 잡을 여러번 정의할 필요가 없다
- 순서를 가진 여러 스텝의 목록이다
  - 잡에서 스텝의 순서는 중요하다
  - 모든 스텝을 논리적인 순서대로 실행할 수 있다
- 처음부터 끝까지 실행 가능하다
  - 외부 의존성 없이 실행할 수 있다
- 독립적이다
  - 의존성을 관리할 수 있어야 한다

### 잡의 생명주기

- 잡은 생명주기대로 실행된다.
- 잡의 실행은 잡 러너에서 시작된다. 
- 잡 러너 : 잡의 이름과 여러 파라미터를 받아들여 잡을 실행시키는 역할. 스프링배치는 두가지를 제공한다
  1. `CommandLineJobRunner`
     - 스크립트를 이용하거나 명령행에서 직접 잡을 실행할 때 사용
     - 스프링을 부트스트랩하고, 전달받은 파라미터를 사용해 요청된 잡을 실행한다
  2. `JobRegistryBackgroundJobRunner`
     - `JobRegistry`를 생성하는데 사용
     - `JobRegistry`란? 스케줄러를 사용해 잡을 실행한다면 생성되는것. 스프링이 부트스트랩될 때 실행 가능한 잡을 가지고 있음
- 이와 별개로 스프링부트가 제공하는 `JobLauncherCommandLineRunner`도 있음.
  - 별도의 config가 없다면 `ApplicationContext`에 정의된 모든 잡 빈을 실행함
  - 이 책에선 이걸 사용
  - 스프링배치 2.3.0부터 `JobLauncherApplicationRunner` 가 쓰이고 `JobLauncherCommandLineRunner` 는 deprecated됨
- `JobInstance`
  - 잡 이름 + 파라미터로 식별
    - `BATCH_JOB_INSTANCE`와 `BATCH_JOB_EXECUTION_PARAMS` 사용
  - 성공적으로 완료된 `JobExecution`이 있다면 완료된 것으로 간주됨.
  - 한 번 성공하면 다시 실행시킬 수 없음
- `JobExecution`
  - 잡 실행의 실제 시도
  - 시도할때마다 새로운 `JobExecution` 생성되고 `BATCH_JOB_EXECUTION` 테이블의 레코드로 저장됨
  - `JobExecution`이 실행될때의 상태는 `BATCH_JOB_EXECUTION_CONTEXT`에 저장됨 -> 오류 발생 시 그 시점부터 실행 가능

### 잡 config

- `CommandLineJobRunner`에 파라미터 전달하기 : `java -jar demo.jar name=junho`

  - 그럼 파라미터들은 `JobParameters`와 매핑됨 (`Map<String, JobParameter>`의 래퍼)
  - 타입 변환기능을 이용하고 싶으면 타입도 같이 넘겨준다(소문자로) : `java -jar demo.jar executionDate(date)=2020/12/27`
  - 전달한 파라미터는 `BATCH_JOB_EXECUTION_PARAMS` 에 저장됨
  - 식별에 사용하고 싶지 않는 파라미터는 `-`를 붙이면 됨 : `java -jar demo.jar executionDate(date)=2020/12/27 -name=junho`

- 잡 파라미터에 접근하는 방법

  1. `chunkContext`

     ```java
     @Bean
     public Tasklet helloWorldTasklet() {
       return ((contribution, chunkContext) -> {
         String name = (String) chunkContext.getStepContext()
             .getJobParameters()
             .get("name");
         System.out.println(String.format("Hello, %s!", name));
         return RepeatStatus.FINISHED;
       });
     }
     ```

     - `StepContribution contribution` : 아직 커밋되지 않은 현재 트랜잭션에 대한 정보(쓰기수, 읽기수 등)
     - `ChunkContext chunkContext` : 실행 시점의 잡 상태를 제공. 테스크릿 내에서는 처리중인 청크와 관련된 정보도 갖고있음

  2. 늦은 바인딩

     ```java
     @StepScope
     @Bean
     public Tasklet helloWorldTasklet(@Value("#{jobParameters['name']}") String name) {
       return ((contribution, chunkContext) -> {
         System.out.println(String.format("Hello, %s!", name));
         return RepeatStatus.FINISHED;
       });
     }
     ```

     - 스코프 기능을 사용하면 늦은 바인딩을 쉽게 사용할 수 있다
     - 스텝 스코프, 잡 스코프 : 스텝, 잡의 실행범위에 들어갈 때까지 빈 생성을 지연시키는 기능

- 스프링 배치의 파라미터 특화 기능

  1. 파라미터 유효성 검증 기능

     - `JobParametersValidator` 인터페이스를 구현하고 잡 config에 넣어주면 됨
     - 필수 파라미터와 옵션 파라미터에 대한 검증만 하고 싶으면? `DefaultJobParametersValidator`
     - 여러 검증 구현체를 적용하고 싶으면? `CompositeJobParametersValidator`

  2. 파라미터 증가 기능

     ```java
     @Bean
     public Job job() {
       return jobBuilderFactory.get("basicJob")
           .start(step1())
           .validator(validator()) //CompositeJobParametersValidator
           .incrementer(new RunIdIncrementer()) //JobParametersIncrementer
           .build();
     }
     ```

     - `JobParametersIncrementer` : 파라미터를 고유하게 생성할 수 있도록 해줌
     - `RunIdIncrementer`를 추가하면 validator에 `run.id` 를 옵션 파라미터에 추가해야 한다
     - 날짜를 증가시키는 것 같이 커스텀하게 만들고 싶다면 `JobParametersIncrementer` 을 구현하고 잡 config에 넣고 옵션 파라미터에 추가하면 된다

- 잡 리스너

  - 잡 리스너로 잡의 생명주기의 여러 시점에 로직을 추가할 수 있다

  - 잡 리스너 작성 방법

    1. `JobExecutionListener` 인터페이스 구현

       - `beforeJob`과 `afterJob` 메서드가 있다 : 잡 실행 전 초기화, 잡 실행 후 정리, 알림 등등에 이용한다

       - 구현 후 Job config에 넣음

         ```java
         @Bean
         public Job job() {
           return jobBuilderFactory.get("basicJob")
               .start(step1())
               .validator(validator())
               .incrementer(new RunIdIncrementer())
               .listener(new JobLoggerListener()) // <--
               .build();
         }
         ```

    2. `@BeforeJob`, `@AfterJob` 사용

       - `JobExecutionListener` 을 implements할 필요가 없다

       - config가 살짝 다르다

         ```java
         @Bean
         public Job job() {
           return jobBuilderFactory.get("basicJob")
               .start(step1())
               .validator(validator())
               .incrementer(new RunIdIncrementer())
               .listener(JobListenerFactoryBean.getListener(new JobLoggerListener())) // <--
               .build();
         }
         ```

  - 리스너는 잡 리스너 외에도 스텝, 리더, 라이터 등에도 있다

- `ExecutionContext`

  - 잡 상태는 `JobExecution`의 `ExecutionContext`에 저장된다

  - `ExecutionContext`은 기본적으로 잡의 세션이다

  - `ExecutionContext`에 담겨있는 모든 게 `JobRepository`에 저장된다

  - <img src="../images/execution_context.jpeg" alt="execution_context" style="zoom:50%;" />

  - 조작하는 방법

    1. `JobExecution` 또는 `StepExecution`으로부터 가져오기
  
       ```java
       public class HelloWorldTasklet implements Tasklet {
       
         @Override
         public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
           // 잡의 ExecutionContext 사용
           ExecutionContext jobContext = chunkContext.getStepContext()
               .getStepExecution() //getStepExecutionContext()는 변경사항이 반영되지 않음
               .getJobExecution()
               .getExecutionContext();
           jobContext.put(...); // <-- 조작
         }
       }
       ```

       ```java
       public class HelloWorldTasklet implements Tasklet {
       
         @Override
         public RepeatStatus execute(StepContribution contribution, ChunkContext chunkContext) throws Exception {
           // 스텝의 ExecutionContext 사용
           ExecutionContext jobContext = chunkContext.getStepContext()
               .getStepExecution()
               .getExecutionContext();
           jobContext.put(...); // <-- 조작
         }
       }
       ```
  
    2. `StepExecution`의 `ExecutionContext`에 있는 키를 `JobExecution`의 `ExecutionContext`로 승격하기
  
       - 스텝 간에 공유할 데이터가 있지만 첫번째 스텝이 성공했을때만 공유하게 하고 싶을때 유용하다
       - `ExecutionContextPromotionListener` 을 사용한다
  
       ```java
       // 스텝이 성공적으로 완료 상태로 종료된 이후에 스텝의 ExecutionContext에서 "name"을 잡의 ExecutionContext로 복사한다
       @Bean
       public Step step1() {
           return this.stepBuilderFactory.get("step1")
               .tasklet(...)
               .listener(promotionListener())
               .build();
       }
       
       @Bean
       public StepExecutionListener promotionListener() {
         ExecutionContextPromotionListener listener = new ExecutionContextPromotionListener();
         listener.setKeys(new String[]{"name"}); //"name"키가 스텝 ExecutionContext에 있어야 함
         return listener;
       }
       ```
  
    3. `ItemStream` 인터페이스 사용
  
       - 추후 다룸
  
  - 저장하는 법
  
    - 잡이 처리되는 동안 각 청크를 커밋하면서 잡과 스텝의 현재 `ExecutionContext`를 데이터베이스에 저장한다
    - `BATCH_JOB_EXECUTION_CONTEXT` 테이블
      - `JOB_EXECUTION_ID` 컬럼 : 관련된 `JobExecution`의 참조
      - `SHORT_CONTEXT` 컬럼 : `ExecutionContext`의 json 표현. 배치 처리가 진행되면서 갱신됨
      - `SERIALIZED_CONTEXT` 컬럼 : 직렬화된 자바 객체

### 스텝

- 잡이 전체적인 처리를 정의한다면, 스텝은 잡의 구성 요소
- 독립적이고 순차적으로 배치 처리를 수행 -> 스텝을 "배치 프로세서"라고 부름
- 자체적으로 입력을 처리, 자체적으로 처리기를 가짐, 자체적으로 출력을 처리함
- 트랜잭션을 스텝 내에서 이뤄짐
- 스텝에서 테이터를 처리하는 방법 : 태스크릿 처리, 청크 처리
  1. 태스크릿 모델
     - `Tasklet` 인터페이스를 사용. `execute`메서드가 `RepeatStatus.FINISHED`를 반환할때까지 트랜잭션 범위 내에서 반복적으로 실행
  2. 청크 처리
     - `ItemReader`, `ItemProcessor`(필수x), `ItemWriter`로 구성
     - 이 컴포넌트들을 사용해서 레코드를 청크 또는 레코드 그룹 단위로 처리
     - 각 청크는 자체 트랜잭션으로 실행됨. 실패한다면 마지막으로 성공한 트랜잭션 이후부터 다시 시작

### 스텝 config

- 태스크릿 스텝을 만드는 유형

  1. 사용자가 작성한 코드를 마치 태스크릿 스텝처럼 실행하도록 하는 유형

  2. `Tasklet` 인터페이스를 구현하는 유형

     - `execute` 메서드를 구현하고, `RepeatStatus.CONTINUABLE` 또는 `RepeatStatus.FINISHED`를 반환하면 된다
       - `RepeatStatus.CONTINUABLE` : 해당 태스크릿을 다시 실행하겠다는 뜻. 특정 태스크릿을 특정 조건이 만족할때까지 반복하고, 추적하고 싶다면 이 타입을 반환하면 된다
       - `RepeatStatus.FINISHED` : 처리의 성공여부에 관계없이 처리를 완료하고 다음 처리를 하겠다는 뜻

  3. `CallableTaskletAdapter` 구현체 사용

     - `Callable<RepeatStatus>` 의 구현체를 구성할 수 있게 해주는 어댑터.
     - 스텝의 특정 로직을 해당 스텝이 실행되는 스레드가 아닌 다른 스레드에서 실행하고 싶을때 사용함
     - 스텝이 실행되는 스레드와 별개의 스레드에서 태스크릿이 실행되지만 스텝과 병렬로 실행되는 건 아니다
     - `Callable` 객체가 유효한 `RepeatStatus` 객체를 반환하기 전에는 완료된 것으로 간주하지 않는다

     ```java
     @Bean
     public Step callableStep() {
       return stepBuilderFactory.get("callableStep")
           .tasklet(tasklet())
           .build();
     }
     
     @Bean
     public CallableTaskletAdapter tasklet() {
       CallableTaskletAdapter adapter = new CallableTaskletAdapter();
       adapter.setCallable(callableObject());
       return adapter;
     }
     
     @Bean
     public Callable<RepeatStatus> callableObject() {
       return () -> {
         System.out.println("이건 다른 스레드에서 실행됩니다.");
         return RepeatStatus.FINISHED;
       };
     }
     ```

  4. `MethodInvokingTaskletAdapter` 구현체 사용

     - 기존에 존재하던 다른 클래스 내의 메서드를 잡 내의 태스크릿처럼 실행할 수 있다
     - 기존 메서드 호출을 매핑하는 `Tasklet` 인터페이스의 구현체를 만들지 않을 수 있다.

     ```java
     @Bean
     public Step methodInvokingStep() {
       return stepBuilderFactory.get("methodInvokingStep")
           .tasklet(methodInvokingTasklet())
           .build();
     }
     
     @Bean
     public MethodInvokingTaskletAdapter methodInvokingTasklet() {
       MethodInvokingTaskletAdapter adapter = new MethodInvokingTaskletAdapter();
       adapter.setTargetObject(service()); //태스크릿으로 실행하고자 하는 메서드의 클래스
       adapter.setTargetMethod("method"); //메서드 이름
       return adapter;
     }
     ```

     - 정적 파라미터 셋을 구성하려면? 늦은 바인딩 이용

     ```java
     @StepScope
     @Bean
     public MethodInvokingTaskletAdapter methodInvokingTasklet(@Value("#{jobParameters['message']}") String message) {
       MethodInvokingTaskletAdapter adapter = new MethodInvokingTaskletAdapter();
       adapter.setTargetObject(service()); //태스크릿으로 실행하고자 하는 메서드의 클래스
       adapter.setTargetMethod("method"); //메서드 이름
       adapter.setArguments(new String[]{message}) //인자 목록
       return adapter;
     }
     ```

  5. `SystemCommandTasklet` 구현체 사용

     - 시스템 명령을 비동기로 실행할때 사용한다
     - 자세한 사용법은 책 참조

- 청크 기반 스텝

  - 청크는 커밋 간격에 의해 정의된다
    - 커밋 간격이 50이라면? "50개 읽기 -> 50개 처리 -> 50개 기록"을 반복

  ```java
  @Bean
  public Step step1() {
    return stepBuilderFactory.get("step1")
        .<String, String>chunk(10) //커밋 간격=10, 10개 단위로 레코드 처리한 후 커밋된다
        .reader(itemReader(null))
        .writer(itemWriter(null))
        .build();
  }
  
  @Bean
  public FlatFileItemReader<String> itemReader(@Value("#{#jobParameters['inputFile']}") Resource inputFile) {
    //생략
  }
  
  @Bean
  public FlatFileItemWriter<String> itemWriter(@Value("#{#jobParameters['outputFile']}") Resource outputFile) {
    //생략
  }
  ```

  - 청크 크기 config 하는방법

    1. 커밋 개수가 고정적이라면 -> `chunk()` 안에 커밋 개수 넣으면 됨

    2. 청크가 완료되는 시점을 동적으로 정하고 싶다면 -> `CompletionPolicy` 구현체 사용

       ```java
       @Bean
       public Step chunkStep() {
         return stepBuilderFactory.get("chunkStep")
             .<String, String>chunk(completionPolicy())
             .reader(itemReader())
             .writer(itemWriter())
             .build();
       }
       
       @Bean
       public CompletionPolicy completionPolicy() {
         CompositeCompletionPolicy policy = new CompositeCompletionPolicy();
         policy.setPolicies(new CompletionPolicy[]{ //밑에 나열된 조건 중 하나라도 만족하면 안전하게 빠져나옴
             new TimeoutTerminationPolicy(3), //청크 내에서 3ms가 넘으면 안전하게 빠져나옴
             new SimpleCompletionPolicy(1000) //1000개가 처리되면 안전하게 빠져나옴
         }); //"안전하게 빠져나옴?" : 해당 청크가 완료된 것으로 간주하고 모든 트랜잭션 처리가 정상적으로 계속된다는 뜻
         return policy;
       }
       ```

       - 아이템이 100000개, 청크크기가 1000개인데 커밋 개수는 101개(100000 / 1000 + 1)가 아니라 101보다 크다.(`TimeoutTerminationPolicy`가 없다면 101임)
       - 직접 만들수도 있음. 아래 예제는 매 청크마다 20 미만의 수를 랜덤하게 정해서 그 수만큼 아이템이 처리되면 청크를 완료하는 예제.

       ```java
       public class RandomChunkSizePolicy implements CompletionPolicy {
       
         //상태를 가지고 있어야 함
         private int chunkSize;
         private int totalProcessed;
         private Random random = new Random();
       
         @Override
         public boolean isComplete(RepeatContext context, RepeatStatus result) {
           if (RepeatStatus.FINISHED == result) {
             return true;
           } else {
             return isComplete(context);
           }
         }
       
         @Override
         public boolean isComplete(RepeatContext context) {
           return this.totalProcessed >= chunkSize;
         }
       
         @Override
         public RepeatContext start(RepeatContext parent) { //정책 초기화
           this.chunkSize = random.nextInt(20);
           this.totalProcessed = 0;
           System.out.printf("청크 사이즈가 %d로 설정됨.", this.chunkSize);
           return parent;
         }
       
         @Override
         public void update(RepeatContext context) { //각 아이템이 처리될때 처리됨
           this.chunkSize++;
         }
       }
       ```

       ```java
       @Bean
       public Step chunkStep() {
         return stepBuilderFactory.get("chunkStep")
             .<String, String>chunk(completionPolicy()) //새 청크마다 적용됨
             .reader(itemReader())
             .writer(itemWriter())
             .build();
       }
       
       @Bean
       public CompletionPolicy completionPolicy() {
         return new RandomChunkSizePolicy();
       }
       ```

  - 스텝 리스너

    - `StepExecutionListener`, `ChunkListener`로 각각 스텝과 청크의 시작과 끝에 특정 로직을 수행하게 할 수 있다
      - `StepListener`가 아니다. `StepListener`은 마커 인터페이스임
    - 잡 리스너와 유사하게 `after...` `before...` 메서드를 제공하고, `@After...` `@Before...` 어노테이션도 제공한다
    - 로직을 정의하고 step config에 넣으면 된다

    ```java
    @Bean
    public Step chunkStep() {
      return stepBuilderFactory.get("chunkStep")
          .<String, String>chunk(1000)
          .reader(itemReader())
          .writer(itemWriter())
          .listener(new LoggingStepStartStopListener()) // <--
          .build();
    }
    ```

### 스텝 플로우

- `firstStep`이..
  - 정상일때 -> `successStep`으로 이동
  - `ExitStatus.FAILED`을 반환할때 -> `failureStep`으로 이동

```java
@Bean
public Job job(){
  return jobBuilderFactory.get("conditionalJob")
      .start(firstStep())
      .on("FAILED").to(failureStep()) //on: ExitStatus를 평가
      .from(firstStep()).on("*").to(successStep())
      .end()
      .build();
}
```

- `on()`안에 들어가는 건 문자열, 와일드카드 사용 가능
  
  - `*` : 0개 이상의 문자를 일치시킴. 
    - `C*` == C, COMPLETE, CORRECT
  - `?` : 1개의 문자를 일치시킴.
    - `?AT` == CAT, KAT
    - `?AT` != THAT
  
- 다음에 뭘할지 코드로 구현하고 싶다면? -> `JobExecutionDecider` 인터페이스를 구현

  ```java
  public class RandomDecider implements JobExecutionDecider {
  
    private Random random = new Random();
  
    //decide 메서드만 구현하면 됨
    @Override
    public FlowExecutionStatus decide(JobExecution jobExecution, StepExecution stepExecution) {
      if (random.nextBoolean()) {
        return new FlowExecutionStatus(FlowExecutionStatus.COMPLETED.getName());
      } else {
        return new FlowExecutionStatus(FlowExecutionStatus.FAILED.getName());
      }
    }
  }
  ```

  ```java
  @Bean
  public Job job() {
    return jobBuilderFactory.get("conditionalJob")
      .start(firstStep())
      .next(decider())
      .from(decider())
      .on("FAILED").to(failureStep())
      .from(decider())
      .on("*").to(successStep())
      .end()
      .build();
  }
  
  @Bean
  public JobExecutionDecider decider() {
    return new RandomDecider();
  }
  ```
  
- 잡 종료하기

  - 잡 종료의 3가지 상태

    1. Completed

       - 배치 처리가 성공적으로 종료됨. 

       - 이후엔 동일한 파라미터로 다시 실행할 수 없다

       - 잡 빌더의 `end`메서드를 사용하면 됨

         ```java
         @Bean
         public Job job() {
           return jobBuilderFactory.get("conditionalJob")
             .start(firstStep())
             .on("FAILED").end()
             .from(firstStep()).on("*").to(successStep())
             .end()
             .build();
         }
         ```

         - `firstStep`이 `FAILED` 인 `ExitStatus`로 끝난다면 `BATCH_JOB_EXECUTION`에 `COMPLETED`가 저장되며 종료
         - `firstStep`이 `FAILED`이 아닌 `ExitStatus`로 끝난다면 `successStep`을 실행하고 `BATCH_JOB_EXECUTION`에 `COMPLETED`가 저장되며 종료

    2. Failed

       - 배치 처리가 성공적으로 완료되지 않음. 

       - 동일한 파라미터로 다시 실행할 수 있다

       - 잡 빌더의 `fail` 메서드를 사용하면 됨

         ```java
         @Bean
         public Job job() {
           return jobBuilderFactory.get("conditionalJob")
             .start(firstStep())
             .on("FAILED").fail()
             .from(firstStep()).on("*").to(successStep())
             .end()
             .build();
         }
         ```

         - `firstStep`이 `FAILED` 인 `ExitStatus`로 끝난다면 `JobRepository`에 잡 실패로 저장되며 종료 -> 나중에 재실행 가능
         - `firstStep`이 `FAILED`이 아닌 `ExitStatus`로 끝난다면 `successStep`을 실행하고 `BATCH_JOB_EXECUTION`에 `COMPLETED`가 저장되며 종료

    3. Stopped

       - 잡에 오류가 발생하지 않았지만 중단된 위치에서 잡을 다시 시작할 수 있다.

       - 스텝 사이에 사람의 개입이 필요하거나 다른 검사 처리가 필요한 상황에 유용하다

       - 잡 빌더의 `stopAndRestart` 메서드를 사용하면 됨

         ```java
         @Bean
         public Job job() {
           return jobBuilderFactory.get("conditionalJob")
             .start(firstStep())
             .on("FAILED").stopAndRestart(successStep())
             .from(firstStep()).on("*").to(successStep())
             .end()
             .build();
         }
         ```

         - `firstStep`이 `FAILED` 인 `ExitStatus`로 끝난다면 FAILED로 종료, 다음에 실행하면 `successStep`부터 실행 가능
         - `firstStep`이 `FAILED`이 아닌 `ExitStatus`로 끝난다면 `successStep`을 실행하고 `BATCH_JOB_EXECUTION`에 `COMPLETED`가 저장되며 종료

- 스텝의 순서를 외부화하는 3가지 방법

  1. 스텝의 시퀀스를 독자적인 플로우로 만드는 방법

     ```java
     @Bean
     public Job conditionalStepLogicJob() {
       return jobBuilderFactory.get("conditionalStepLogicJob")
         .start(preProcessingFlow())
         .next(runBatch())
         .end()
         .build();
     }
     
     @Bean
     public Flow preProcessingFlow() {
       return new FlowBuilder<Flow>("preProcessingFlow")
         .start(step1())
         .next(step2())
         .next(step3())
         .build();
     }
     
     @Bean
     public Step runBatch() {
       ...
     }
     ```
  
     - `JobRepository` 관점에서는 플로우를 사용하는 것과 잡 내에서 스텝을 직접 구성하는 것에 차이는 없다
  
  2. 플로우 스텝을 사용하는 방법
  
     - 플로우를 스텝으로 래핑하고 잡 빌더로 전달한다
  
     ```java
     @Bean
     public Job conditionalStepLogicJob() {
       return jobBuilderFactory.get("conditionalStepLogicJob")
         .start(initializeBatch())
         .next(runBatch())
         .build();
     }
     
     @Bean
     public Step initializeBatch() {
       return stepBuilderFactory.get("initializeBatch")
         .flow(preProcessingFlow())
         .build();
     }
     
     @Bean
     public Flow preProcessingFlow() {
       return new FlowBuilder<Flow>("preProcessingFlow")
         .start(step1())
         .next(step2())
         .next(step3())
         .build();
     }
     
     @Bean
     public Step runBatch() {
       ...
     }
     ```
  
     - 위 코드처럼 플로우스텝을 사용하면 스프링 배치는 `step1`, `step2`, `step3`를 하나의 스텝처럼 기록한다 -> 개별 스텝을 집계하지 않고도 플로우의 영향을 전체적으로 볼 수 있다
  
  3. 잡 내에서 다른 잡을 호출하는 방법(스텝을 전혀 외부화하지 않는 방법)
  
     - 책 참조
  
- 잡 관리 기능은 단일 답 수준에서 이뤄지기 때문에 잡 스텝 기능을 사용해 잡 전체를 트리로 만들어 관리하면 문제를 일으킬 수 있다.

<br/>

## 5장. `JobRepository`와 메타데이터

### JobRepository란?

- 스프링 배치 내에서 `JobRepository`를 말한 땐 둘 중 하나다
  1. `JobRepository` 인터페이스
  2. `JobRepository` 인터페이스를 구현해 데이터를 저장하는 데 사용되는 데이터 저장소 <- 이 절에선 주로 이걸 가리킨다

- 배치 잡 내부에서 바로 사용할 수 있는 데이터 저장소 2가지

  1. 관계형 데이터베이스

     ![Spring Batch Meta-Data ERD](https://docs.spring.io/spring-batch/docs/4.3.x/reference/html/images/meta-data-erd.png)

     - `BATCH_JOB_INSTANCE` : 잡의 논리적 실행
     - `BATCH_JOB_EXECUTION` : 잡의 실제 실행 기록
     - `BATCH_JOB_EXECUTION_PARAMS` : 잡이 매번 실행될때마다 사용된 잡 파라미터 기록
     - `BATCH_JOB_EXECUTION_CONTEXT` : `JobExecution`의 `ExecutionContext` 기록
     - `BATCH_STEP_EXECUTION` : 스텝의 시작, 완료, 상태에 대한 메타데이터 기록
     - `BATCH_STEP_EXECUTION_CONTEXT` : `StepExecution`의 `ExecutionContext` 기록

  2. 인메모리 저장소

     - 개발 단계나 단위테스트를 수행할 때 사용할 수 있게 `Map`기반 인메모리 데이터베이스를 제공한다. 다음 절에서 다룬다.

### 배치 인프라스트럭쳐 config

`@EnableBatchProcessing`을 사용하면 `JobRepository`를 사용할 수 있다.

`JobRepository`를 비롯한 모든 스프링배치 인프라스트럭쳐를 커스터마이징을 하고 싶다면 `BatchConfigurer` 인터페이스를 사용하면 된다

- `BatchConfigurer` 인터페이스

  - 스프링 배치 인프라스트럭쳐 컴포넌트 구성을 커스터마이징하는데 사용되는 전략 인터페이스이다. (일반적으론 `DefaultBatchConfigurer` 을 상속해서 커스터마이징한다.)
  - `@EnableBatchProcessing`을 사용했을때 빈이 추가되는 과정
    1. `BatchConfigurer` 구현체에서 빈을 생성한다
    2. `SimpleBatchConfiguration`에서 스프링의 `ApplicationContext`에 생성한 빈을 등록한다

- `JobRepository`커스터마이징하기

  - 보통 `ApplicationContext`에 두 개 이상의 데이터소스가 존재할때 커스터마이징한다.
  - 예) 업무 데이터 용도의 데이터소스와 `JobRepository`용 데이터소스가 별도로 존재할때

  ```java
  public class CustomBatchConfigurer extends DefaultBatchConfigurer {
  
    @Autowired
    @Qualifier("repositoryDataSource") //"repositoryDataSource"가 어딘가 있다고 가정.
    private DataSource dataSource;
  
    @Override
    protected JobRepository createJobRepository() throws Exception {
      JobRepositoryFactoryBean factoryBean = new JobRepositoryFactoryBean();
      factoryBean.setDatabaseType(DatabaseType.MYSQL.getProductName());
      // 접두어 "BATCH_" -> "FOO_"
      factoryBean.setTablePrefix("FOO_");
      // 데이터 생성시 트랜잭션 격리레벨 "ISOLATION_SERIALIZED" -> "ISOLATION_REPEATABLE_READ"
      factoryBean.setIsolationLevelForCreate("ISOLATION_REPEATABLE_READ");
      factoryBean.setDataSource(this.dataSource);
      // 보통 아래의 두 메서드는 스프링 컨테이너가 호출해준다. 근데 create...메서드 모두는 스프링 컨테이너에 노출되지 않는다. 그래서 개발자가 직접 호출해줘야 한다.
      factoryBean.afterPropertiesSet();
      return factoryBean.getObject();
    }
  }
  ```

- `TransactionManager`커스터마이징하기

  ```java
  public class CustomBatchConfigurer extends DefaultBatchConfigurer {
  
    @Autowired
    @Qualifier("batchTransactionManager") //"batchTransactionManager"가 어딘가 있다고 가정.
    private PlatformTransactionManager transactionManager;
  
    @Override
    public PlatformTransactionManager getTransactionManager() {
      return this.transactionManager;
    }
  }
  ```

- `JobExplorer`커스터마이징하기

  - 배치 메타데이터를 읽기 전용으로 제공하고 싶을 때

  ```java
  public class CustomBatchConfigurer extends DefaultBatchConfigurer {
  
    @Autowired
    @Qualifier("repositoryDataSource")
    private DataSource dataSource;
  
    //JobExplorer와 JobRepository는 동일한 데이터 저장소를 사용하므로 함께 커스터마이징을 하는 게 좋다
    @Override
    protected JobRepository createJobRepository() throws Exception {
      JobRepositoryFactoryBean factoryBean = new JobRepositoryFactoryBean();
      factoryBean.setDatabaseType(DatabaseType.MYSQL.getProductName());
      factoryBean.setTablePrefix("FOO_");
      factoryBean.setIsolationLevelForCreate("ISOLATION_REPEATABLE_READ");
      factoryBean.setDataSource(this.dataSource);
      factoryBean.afterPropertiesSet();
      return factoryBean.getObject();
    }
    
    @Override
    protected JobExplorer createJobExplorer() throws Exception {
      JobExplorerFactoryBean factoryBean = new JobExplorerFactoryBean();
      factoryBean.setDataSource(this.dataSource);
      factoryBean.setTablePrefix("FOO_");
      factoryBean.afterPropertiesSet();
      return factoryBean.getObject();
    }
  }
  ```

- `JobLauncher`커스터마이징하기

  - 스프링 배치가 기본 제공하는 `SimpleJobLauncher` 외의 방식으로 커스터마이징하고 싶을때 (예 : 컨트롤러를 통해 잡 실행하려 할때)

- 데이터베이스 config

  ```yaml
  spring:
    datasource:
      driverClassName: ...
      url: ...
      username: ...
      password: ...
    batch:
      initialize-schema: ...
  ```

  - `initialize-schema` : 스프링부트가 스프링배치 스키마 스크립트를 실행하도록 지시
    - `always` : 애플리케이션을 실행할때마다 스크립트 실행. 개발 환경일때 사용하기 쉬움
    - `never` : 스크립트를 실행하지 않음
    - `embedded` : 내장 데이터베이스를 사용할때, 각 실행 시마다 데이터가 초기화된 데이터베이스 인스턴스를 사용한다는 가정으로 스크립트를 실행

### 잡 메타데이터 사용하기

어떻게 `JobRepository` 내의 정보를 얻을 수 있을까? 주로 `JobExplorer`을 사용한다.

- `JobExplorer`

  - `JobExplorer`은 `JobRepository`의 데이터에 접근하는 시작점이다.

  - 대부분의 배치 프레임워크 컴포넌트가 `JobRepository`를 사용해 잡 관련 정보에 접근하지만 `JobExplorer`은 데이터베이스에 직접 접근한다.

  - 예시 : 잡의 `JobInstance`가 얼마나 많이 실행됐는지, 각 `JobInstance`당 얼마나 많은 실제 실행이 있었는지 확인하는 config

  - ```java
    public class ExploringTasklet implements Tasklet {
    
      private JobExplorer explorer;
    
      public ExploringTasklet(JobExplorer explorer) {
        this.explorer = explorer;
      }
    
      @Override
      public RepeatStatus execute(StepContribution stepContribution, ChunkContext chunkContext) throws Exception {
        String jobName = chunkContext.getStepContext().getJobName();
        List<JobInstance> instances = explorer.getJobInstances(jobName, 0, Integer.MAX_VALUE);
        System.out.printf("%s 잡에는 %d개의 잡 인스턴스가 존재합니다.", jobName, instances.size());
    
        System.out.println("********************* 결과 *********************");
        for (JobInstance instance : instances) {
          List<JobExecution> jobExecutions = explorer.getJobExecutions(instance);
          System.out.printf("%d 인스턴스에는 %d개의 execution이 존재합니다.",
              instance.getInstanceId(), jobExecutions.size());
          for (JobExecution jobExecution : jobExecutions) {
            System.out.printf("\t%d execution의 ExitStatus 결과는 %s입니다.",
                jobExecution.getId(), jobExecution.getExitStatus());
          }
        }
        return RepeatStatus.FINISHED;
      }
    }
    ```

    ```java
    @Autowired
    private JobExplorer jobExplorer;
    
    @Bean
    public Job explorerJob() {
      return jobBuilderFactory.get("explorerJob")
        .start(explorerStep())
        .build();
    }
    
    @Bean
    public Step explorerStep() {
      return stepBuilderFactory.get("explorerStep")
        .tasklet(explorerTasklet())
        .build();
    }
    
    @Bean
    public Tasklet explorerTasklet() {
      return new ExploringTasklet(jobExplorer);
    }
    ```

<br/>

## 6장. 잡 실행하기

### 스프링 부트로 배치 잡 시작시키기

- 스프링부트는 `CommandLineRunner`와 `ApplicationRunner`라는 두가지 메커니즘을 이용해 실행시 로직을 수행한다

  - 두 인터페이스는 한개의 메서드(`run()` : 애플리케이션이 코드를 실행할 준비가 되면 호출됨)를 가지고있다
  - 스프링부트를 스프링배치와 함께 사용할땐 `JobLauncherCommandLineRunner`가 사용된다
    - 스프링부트가 `ApplicationContext`내에 구성된 모든 `CommandLineRunner`를 실행할 때 클래스패스에 `spring-boot-starter-batch`가 존재한다면 `JobLauncherCommandLineRunner`는 컨텍스트 내에서 찾아낸 모든 잡을 실행한다.
    - 이전 예제는 모두 이런식으로 작동했음

- 애플리케이션 기동 시에 실행할 잡 정의하는 법

  - 애플리케이션이 기동될때 잡이 실행되지 않도록 `spring.batch.job.enabled`를 false로 설정해야 한다 (기본값은 true)

  ```java
  public static void main(String[] args) {
    SpringApplication application = new SpringApplication(BatchApplication.class);
    Properties properties = new Properties();
    properties.put("spring.batch.job.enable", false);
    application.setDefaultProperties(properties);
    application.run(args);
  }
  ```

- 컨텍스트의 여러 잡 중 특정 잡만 실행하는 법

  - `spring.batch.job.names` 프로퍼티 사용

### REST 방식으로 잡 실행하기

- 컨트롤러와 `JobLauncher.run(Job, JobParameters)`을 연결시키면 된다

- 스프링 배치는 기본적으로 `JobLauncher`의 구현체인 `SimpleJobLauncher`을 제공한다

  - `SimpleJobLauncher`은 `JobParameters`에 대한 조작을 제공하지 않으므로 전달되기 전에 조작해야 한다.

- `JobLauncher`가 사용하는 `TaskExecutor`을 구성하여 동기식/비동기식을 선택할 수 있다.

  - `SimpleJobLauncher`은 기본적으로 동기식 (호출자와 동일한 스레드에서 잡이 수행됨)
  - 잡이 오래 걸리는경우 비동기가 적절할 수도 있음 (이럴땐 `JobExecution`의 id만 반환됨)

- 잡 파라미터를 자동으로 증가시키고 싶다면? `JobParametersBuilder.getNextJobParameters` 이용.

  ```java
  // inputJobParameters은 입력받은 잡 파라미터, JobExplorer은 autowired
  JobParameters jobParameters = new JobParametersBuilder(inputJobParameters, jobExplorer)
    .getNextJobParameters(job) //입력받은 job 정보로 찾은 job(incrementer config가 되어 있어야 함)
    .toJobParameters();
  return jobLauncher.run(job, jobParameters).getExitStatus();
  ```

- 쿼츠로 스케줄링하기

  - 쿼츠의 컴포넌트
    - 스케줄러 : 연관된 트리거가 작동할 때 잡을 실행하는 역할
      - `SchedulerFactory`를 통해 가져올 수 있음
      - `JobDetails` 및 트리거의 저장소 기능
    - 트리거 : 작업 실행 시점
      - 트리거가 작동돼 쿼츠에게 잡을 실행하도록 지시하면 잡의 개별 실행을 정의하는 `JobDetails` 객체가 생성됨
    - 잡 : 실행할 작업의 단위
    
  - config

    ```java
    //배치 잡을 기동하는 쿼츠 잡
    //일정 이벤트가 발생할 때 잡을 실행
    public class BatchScheduledJob extends QuartzJobBean {
    
      @Autowired
      private Job job;
    
      @Autowired
      private JobExplorer jobExplorer;
    
      @Autowired
      private JobLauncher jobLauncher;
    
      @Override
      protected void executeInternal(JobExecutionContext context) {
        JobParameters jobParameters = new JobParametersBuilder(this.jobExplorer)
            .getNextJobParameters(this.job)
            .toJobParameters();
    
        try {
          this.jobLauncher.run(this.job, jobParameters);
        } catch (Exception e) {
          e.printStackTrace();
        }
      }
    }
    ```

    ```java
    @Configuration
    public class QuartzConfig {
    
      // Trigger: 스케줄과 JobDetail을 연결함
      @Bean
      public Trigger jobTrigger() {
        SimpleScheduleBuilder scheduleBuilder = SimpleScheduleBuilder.simpleSchedule()
            .withIntervalInSeconds(5).withRepeatCount(4); // 5초마다 실행, 4번 반복 (총 5번 실행됨)
    
        return TriggerBuilder.newTrigger()
            .forJob(quartzJobDetail())
            .withSchedule(scheduleBuilder)
            .build();
      }
    
      // JobDetail: 실행할 쿼츠 잡 수행 시에 사용되는 메타데이터
      @Bean
      public JobDetail quartzJobDetail() {
        return JobBuilder.newJob(BatchScheduledJob.class)
            .storeDurably()
            .build();
      }
    }
    ```

### 잡 중지하기

잡을 종료하는 방법엔 여러가지가 있다

1. 자연스럽게 완료되어 종료

   - 모든 스텝이 `COMPLETED` 상태가 되어 잡도 `COMPLETED` 상태가 됨

2. 프로그래밍적으로 종료

   - 중지 트랜지션으로 종료

     ```java
     @Bean
     public Job job() {
       return this.jobBuilderFactory.get("job")
           .start(step1())
             .on("STOPPED").stopAndRestart(step1()) //재시작시 step1부터 다시시작
           .from(step1())
             .on("*").to(step2())
           .from(step2())
             .next(step3()).end()
           .build();
     }
     
     private Step step1() {
       return this.stepBuilderFactory.get("step1")
           .chunk(100)
           .reader(customReader())
           .writer(customWriter())
           .allowStartIfComplete(true) // 잡이 재시작되면 이 스텝이 다시 실행되도록
           .listener(customReader()) //customReader의 @AfterStep를 붙인 메서드에서 특정 조건일때 STOPPED를 반환
           .build();
     }
     
     private Step step2() {
       ...
     }
     
     private Step step3() {
       ...
     }
     ```

   - `StepExecution.setTermimateOnly()`를 이용해 종료 (위 예보다 더 효율적, config가 더 깔끔해짐)

     ```java
     @Bean
     public Job job() {
       return this.jobBuilderFactory.get("job") //깔끔해짐
           .start(step1())
           .next(step2())
           .next(step3())
           .build();
     }
     
     private Step step1() {
       return this.stepBuilderFactory.get("step1")
           .chunk(100)
           .reader(customReader())
           .writer(customWriter())
           .allowStartIfComplete(true)
           //customReader의 @BeforeStep붙인 메서드에서 StepExecution을 가져와서 필드에 저장하고, 
           //특정 조건일때 this.stepExecution.setTerminateOnly(); 하면 됨.
           .listener(customReader()) 
           .build();
     }
     
     private Step step2() {
       ...
     }
     
     private Step step3() {
       ...
     }
     ```

3. 오류를 던저 종료

   - 스프링 배치는 예외가 발생하면 기본적으로 스텝 및 잡이 실패한 것으로 간주한다
   - `StepExecution`을 사용해 잡을 중지하는 것과 예외를 발생시켜 잡을 중지하는것의 차이 : 잡의 상태
     - 전자는 `ExitStatus.STOPPED` 상태로 스텝이 완료된 후 잡 중지
     - 후자는 스텝이 완료되지 않음. 스텝과 잡에 `ExitStatus.FAILED` 레이블이 지정됨
       - 스텝이 `FAILED`로 식별되면 스텝을 처음부터 다시 실행하는 게 아니라 실패한 지점부터 실행한다
       - `[청크1: 아이템1,2,3], [청크2: 아이템4,5,6], [청크3: 아이템7,8,9]`일때, 아이템5에서 예외가 발생한 경우, 아이템4,5는 롤백된다. 재시작하면 청크1은 건너뛰고 청크2부터 다시 시작된다.

### 재시작 제어하기

스텝1에서 성공적이었다면 스텝2에서 실패하더라도 스텝1을 재시작하고 싶지 않을수도 있다.

- 잡의 재시작 방지하기

  ```java
  @Bean
  public Job job() {
    return this.jobBuilderFactory.get("job")
        .preventRestart() // 잡이 실패하거나 어떤 이유로든 중지된 경우에 다시 실행할 수 없도록 함
        .start(step1())
        .next(step2())
        .next(step3())
        .build();
  }
  ```

  다시 실행하려고 시도하면 `JobRestartException`이 발생함

- 재시작 횟수를 제한하도록 구성하기

  - step1을 두번만 시도하도록 구성

  ```java
  private Step step1() {
    return this.stepBuilderFactory.get("step1")
        .startLimit(2) // 두번까지만 실행 가능
        .chunk(100)
        .reader(customReader())
        .writer(customWriter())
        .allowStartIfComplete(true) // 배치 잡 재실행시 수행할 일 결정
        .listener(customReader()) 
        .build();
  }
  ```

  2번 넘게 실행되면 `StartLimitExceededException` 발생함

- 완료된 스텝 재실행하기

  - 잡은 동일 파라미터로 성공하면 다시 실행 못한다
  - 스텝은 재정의로 이 규칙을 피할 수 있다
  - `StepBuilder.allowStartIfComplete()`를 사용하면 된다

<br/>

## 7장. ItemReader

### ItemReader 인터페이스

```java
public interface ItemReader<T> {
  T read() throws Exception, UnexpectedInputException, ParseException, NonTransientResourceException;
}
```

- `ItemReader` 인터페이스는 전략 인터페이스다
- 스프링 배치는 플랫 파일, 여러 데이터베이스, JMS 리소스 등등 유형의 구현체를 제공한다
- `ItemReader`나 `ItemReader` 하위 인터페이스를 구현해서 커스텀하게 사용할수도 있다

### 파일 입력

#### 플랫 파일

- 가장 많이 사용하는 구현체인 `DefaultLineMapper`는 다음 두 개가 처리를 담당한다
  1. `LineTokenizer` : 파일의 한 줄 -> `FieldSet`
  2. `FieldSetMapper` : `FieldSet` -> 객체

- 고정 너비 파일

  ```java
  @Bean
  @StepScope
  public FlatFileItemReader<Customer> customerItemReader(@Value("#{jobParameters['customerFile']})") Resource inputFile) {
    return new FlatFileItemReaderBuilder<Customer>()
        .name("customerItemReader")
        .resource(inputFile)
        .fixedLength()
        .columns(
            new Range[]{new Range(1, 11), new Range(12, 12), new Range(13, 22), new Range(23, 26),
                new Range(27, 46), new Range(47, 62), new Range(63, 64), new Range(65, 69)}
        )
        .names(
            new String[]{"firstName", "middleInitial", "lastName", "addressNumber", "street",
                "city", "state", "zipCode"}
        )
        .targetType(Customer.class)
        .build();
  }
  ```

- 필드가 구분자로 구분된 파일

  ```java
  @Bean
  @StepScope
  public FlatFileItemReader<Customer> customerItemReader(
    @Value("#{jobParameters['customerFile']})") Resource inputFile) {
    return new FlatFileItemReaderBuilder<Customer>()
        .name("customerItemReader")
        .delimited()
        .names(new String[]{"firstName", "middleInitial", "lastName", "addressNumber", "street",
            "city", "state", "zipCode"})
        .targetType(Customer.class)
        .resource(inputFile)
        .build();
  }
  ```

  매핑을 커스텀하게 하고 싶으면?

  ```java
  @Bean
  @StepScope
  public FlatFileItemReader<Customer> customerItemReader(
    @Value("#{jobParameters['customerFile']})") Resource inputFile) {
    return new FlatFileItemReaderBuilder<Customer>()
        .name("customerItemReader")
        .delimited()
        .names(new String[]{"firstName", "middleInitial", "lastName", "addressNumber", "street",
            "city", "state", "zipCode"})
        .fieldSetMapper(new CustomFieldSetMapper())
        .resource(inputFile)
        .build();
  }
  ```

- `LineTokenizer`직접 구현

  - `LineTokenizer`을 implements하여 `FlatFileItemReader` config에서 설정한다

    ```java
    public interface LineTokenizer {
      FieldSet tokenizer(String line);
    }
    ```

  - 예

    ```java
    @Bean
    @StepScope
    public FlatFileItemReader<Customer> customerItemReader(
      @Value("#{jobParameters['customerFile']})") Resource inputFile) {
      return new FlatFileItemReaderBuilder<Customer>()
          .name("customerItemReader")
          .lineTokenizer(new CustomerFileLineTokenizer()) // <--
          .resource(inputFile)
          .build();
    }
    ```

- 여러 형식이 섞여 있는 경우

  - 예 : 접두사로 고객데이터, 거래데이터가 섞여 있는 경우

    ```
    CUST,Warren,Q,Darrow,8272 4th Street,New York,IL,76091
    TRANS,1165965,2011-01-22 00:13:29,51.43
    CUST,Ann,V,Gates,9247 Infinite Loop Drive,Hollywood,NE,37612
    CUST,Erica,I,Jobs,8875 Farnam Street,Aurora,IL,36314
    TRANS,8116369,2011-01-21 20:40:52,-14.83
    TRANS,8116369,2011-01-21 15:50:17,-45.45
    TRANS,8116369,2011-01-21 16:52:46,-74.6
    TRANS,8116369,2011-01-22 13:51:05,48.55
    TRANS,8116369,2011-01-21 16:51:59,98.53
    ```

  - ```java
    @Bean
    public PatternMatchingCompositeLineMapper lineTokenizer() {
      Map<String, LineTokenizer> lineTokenizers = new HashMap<>(2);
      lineTokenizers.put("CUST*", customerLineTokenizer());
      lineTokenizers.put("TRANS*", transactionLineTokenizer());
    
      Map<String, FieldSetMapper> fieldSetMappers = new HashMap<>(2);
      BeanWrapperFieldSetMapper<Customer> customerFieldSetMapper = new BeanWrapperFieldSetMapper<>();
      customerFieldSetMapper.setTargetType(Customer.class);
      fieldSetMappers.put("CUST*", customerFieldSetMapper);
      fieldSetMappers.put("TRANS*", new TransactionFieldSetMapper());
    
      PatternMatchingCompositeLineMapper lineMappers = new PatternMatchingCompositeLineMapper();
      lineMappers.setTokenizers(lineTokenizers);
      lineMappers.setFieldSetMappers(fieldSetMappers);
      return lineMappers;
    }
    
    @Bean
    public DelimitedLineTokenizer transactionLineTokenizer() {
      DelimitedLineTokenizer lineTokenizer = new DelimitedLineTokenizer();
      lineTokenizer.setNames("prefix", "accountNumber", "transactionDate", "amount");
      return lineTokenizer;
    }
    
    @Bean
    public DelimitedLineTokenizer customerLineTokenizer() {
      DelimitedLineTokenizer lineTokenizer = new DelimitedLineTokenizer();
      lineTokenizer.setNames(
          "firstName", "middleInitial", "lastName", "address", "city", "state", "zipCode"
      );
      lineTokenizer.setIncludedFields(1, 2, 3, 4, 5, 6, 7);
      return lineTokenizer;
    }
    ```

    ```java
    public class TransactionFieldSetMapper implements FieldSetMapper<Transaction> {
      public Transaction mapFieldSet(FieldSet fieldSet) {
        Transaction trans = new Transaction();
        trans.setAccountNumber(fieldSet.readString("accountNumber"));
        trans.setAmount(fieldSet.readDouble("amount"));
        trans.setTransactionDate(fieldSet.readDate("transactionDate", "yyyy-MM-dd HH:mm:ss"));
        return trans;
      }
    }
    ```

- 이후 예제 생략

#### XML

- XML파서로는 DOM파서와 SAX파서를 많이 이용한다
  - DOM파서는 부하가 커서 배치 처리엔 적합하지 않아 SAX파서를 자주 사용한다
  - SAX파서 : 특정 엘리먼트를 만나면 이벤트를 발생시키는 이벤트 기반 파서
  - 스프링 배치에서는  StAX파서를 사용한다
- 해야하는 것들
  - oxm관련 의존성 추가
  - 도메인 객체에 JAXB 애너테이션 추가
    - @XmlRootElement, @XmlElementWrapper, @XmlElement ...
  - 마샬러 설정
  - 아이템리더 설정

### JSON

- JsonItemReader는 3가지 의존성이 필요하다

  1. 배치를 재시작할때 사용하는 배치의 이름
  2. 파싱에 사용할 `JsonObjectReader`
  3. 읽어들일 리소스

  ```java
  @Bean
  @StepScope
  public JsonItemReader<Customer> customerFileReader(
      @Value("#{jobParameters['customerFile']}") Resource inputFile) {
  
    ObjectMapper objectMapper = new ObjectMapper();
    ObjectMapper.setDateFormat(new SimpleDateFormat("yyyy-MM-dd hh:mm:ss"));
  
    JacksonJsonObjectReader<Customer> jsonObjectReader = new JacksonJsonObjectReader<>(Customer.class);
    jsonObjectReader.setMapper(objectMapper);
  
    return new JsonItemReaderBuilder<Customer>()
        .name("customerFileReader") // <-- 1
        .jsonObjectReader(jsonObjectReader) // <-- 2
        .resource(inputFile) // <-- 3
        .build();
  }
  ```

### 데이터베이스 입력

- 데이터베이스가 배치 처리에서 훌륭한 입력 소스인 이유
  1. 데이터베이스는 내장된 트랜잭션 기능을 제공한다
     - 이는 대체로 성능이 우수하고 파일보다 훨씬 확장성이 좋다
  2. 다른 입력 포맷보다 훨씬 뛰어난 복구 기능을 기본적으로 제공한다

#### JDBC

- 레코드가 수백만건이 있을때 이를 모두 메모리에 적재하는 건 위험하므로 한 번에 처리할 만큼의 레코드만 로딩하는 방법을 제공한다.

  1. 커서
     - `ResultSet`으로 구현된다
     - `next()` 메서드를 호출할때마다 데이터베이스에서 레코드를 가져와 반환한다
  2. 페이징
     - 커서 방식과는 달리 여러개의 레코드를 한꺼번에 가져올 수 있다

- JDBC 커서 처리

  ```java
  public class CustomerRowMapper implements RowMapper<Customer> {
  
    @Override
    public Customer mapRow(ResultSet rs, int rowNum) throws SQLException {
      // ResultSet으로부터 값을 뽑아서 Customer 객체 생성 후 return
    }
  }
  ```

  ```java
  @Bean
  public JdbcCursorItemReader<Customer> customerItemReader(DataSource dataSource) {
    return new JdbcCursorItemReaderBuilder<Customer>()
        .name("customerItemReader")
        .dataSource(dataSource)
        .sql("select * from customer where city = ?")
        .rowMapper(new CustomerRowMapper())
        .preparedStatementSetter(citySetter(null))
        .build();
  }
  
  @Bean
  @StepScope
  public PreparedStatementSetter citySetter(@Value("#{jobParameters['city']}") String city) {
    return new ArgumentPreparedStatementSetter(new Object[]{city});
  }
  ```

  - 스프링 배치가 `JdbcCursorItemReader.read()` 메서드를 호출하면 로우 하나 읽어서 도메인 객체로 매핑함
  - 단점
    - 백만 단위의 레코드를 처리한다면 요청할때마다 네트워크 오버헤드가 추가됨
    - `ResultSet`은 쓰레드 안전이 보장되지 않음

- JDBC 페이징 처리

  - 이후 생략

#### 하이버네이트

- 배치 처리에서 하이버네이트를 사용하는 건 웹 애플리케이션에서 하이버네이트를 사용하는 것만큼 직관적이지 않다

  - 웹 애플리케이션에서 : 요청이 서버에서 오면 세션을 연다 -> 모든 처리를 동일한 세션에서 처리 -> 뷰를 클라이언트에게 반환하면서 세션을 닫음
  - 배치 처리에서 : 있는 그대로 사용하면 stateful 세션구현체를 사용하게 된다 -> 백만건을 처리한다면 아이템을 캐시에 쌓으면서 `OutOfMemoryException` 이 발생함 -> 하이버네이트 기반 `ItemReader`는 이런 문제를 해결함

- 커서 처리

  - `spring-boot-starter-data-jpa` 의존성 추가 (데이터 접근용x 매핑용o)

    - 해당 의존성을 추가하면 하이버네이터 전용 의존성도 가져올 수 있다

  - 엔티티 매핑

    - `@Entity`, `@Table`, `@Id` 등으로 매핑

  - 배치 잡에서 사용할 `TransactionManager` 커스텀

    - 스프링 배치는 기본적으로 `DataSourceTransactionManager`를 제공하지만 예제에선 일반적인 `DataSource` 커넥션과 하이버네이트 세션을 아우르는 `TransactionManager`가 필요하다 

    ```java
    @Component
    public class HibernateBatchConfigurer extends DefaultBatchConfigurer {
    
      private DataSource dataSource;
      private SessionFactory sessionFactory;
      private PlatformTransactionManager transactionManager;
    
      public HibernateBatchConfigurer(
          DataSource dataSource, EntityManagerFactory entityManagerFactory
      ) {
        super(dataSource);
        this.dataSource = dataSource;
        this.sessionFactory = entityManagerFactory.unwrap(SessionFactory.class);
        this.transactionManager = new HibernateTransactionManager(this.sessionFactory);
      }
    
      // 이제 스프링 배치는 이 메서드가 반환하는 트랜잭션 매니저를 사용한다
      @Override
      public PlatformTransactionManager getTransactionManager() {
        return this.transactionManager;
      }
    }
    ```

  - `HibernateCusorItemReader` config

    ```java
    @Bean
    @StepScope
    public HibernateCursorItemReader<Customer> customerItemReader(
        EntityManagerFactory entityManagerFactory, @Value("#{jobParameters['city']}") String city
    ) {
      return new HibernateCursorItemReaderBuilder<Customer>()
          .name("customerItemReader")
          .sessionFactory(entityManagerFactory.unwrap(SessionFactory.class))
          .queryString("from Customer where city = :city")
          .parameterValues(Collections.singletonMap("city", city))
          .build();
    }
    ```

- 페이징 기법으로 데이터베이스 접근

  - 커서기법과의 차이점은 `HibernateCursorItemReader`대신 `HibernatePagingItemReader` 을 구성해야 한다는 것과 페이지 크기를 지정하는것이다

  ```java
  @Bean
  @StepScope
  public HibernatePagingItemReader<Customer> customerItemReader(
      EntityManagerFactory entityManagerFactory, @Value("#{jobParameters['city']}") String city
  ) {
    return new HibernatePagingItemReaderBuilder<Customer>()
        .name("customerItemReader")
        .sessionFactory(entityManagerFactory.unwrap(SessionFactory.class))
        .queryString("from Customer where city = :city")
        .parameterValues(Collections.singletonMap("city", city))
        .pageSize(10)
        .build();
  }
  ```

#### JPA

- JPA는 커서기법은 제공하지 않지만 페이지기법은 제공한다

- `JpaPagingItemReader`가 필요한 4가지 의존성

  1. `ExecutionContext`내 엔트리의 접두어로 사용되는 이름
  2. 스프링부트가 제공하는 `entityManager`
  3. 실행할 쿼리
  4. 파라미터

  ```java
  @StepScope
  @Bean
  public JpaPagingItemReader<Customer> jpaPagingItemReader(
      EntityManagerFactory entityManagerFactory, @Value("#{jobParameters['city']}") String city
  ) {
    return new JpaPagingItemReaderBuilder<Customer>()
        .name("jpaPagingItemReader")
        .entityManagerFactory(entityManagerFactory)
        .queryString("select c from Customer c where c.city = :city")
        .parameterValues(Collections.singletonMap("city", city))
        .build();
  }
  ```

  `AbstractJpaQueryProvider`을 이용해서 설정할수도 있다

  ```java
  @StepScope
  @Bean
  public JpaPagingItemReader<Customer> jpaPagingItemReader(
      EntityManagerFactory entityManagerFactory, @Value("#{jobParameters['city']}") String city
  ) {
    CustomerByCityQueryProvider queryProvider = new CustomerByCityQueryProvider();
    queryProvider.setCityName(city);
  
    return new JpaPagingItemReaderBuilder<Customer>()
        .name("jpaPagingItemReader")
        .entityManagerFactory(entityManagerFactory)
        .queryProvider(queryProvider)
        .build();
  }
  ```

  ```java
  @Setter
  public class CustomerByCityQueryProvider extends AbstractJpaQueryProvider {
  
    private String cityName;
  
    @Override
    public Query createQuery() {
      EntityManager manager = getEntityManager();
      Query query = manager.createQuery("select c from Customer c where c.city = :city");
      query.setParameter("city", cityName);
      return query;
    }
  
    @Override
    public void afterPropertiesSet() throws Exception {
      Assert.notNull(cityName, "City name is required");
    }
  }
  ```

#### 저장 프로시저

- 저장 프로시저?

  - 데이터베이스 전용 코드의 집합
  - 스프링배치는 저장 프로시저에서 데이터를 조회하는 용도로 `StoredProcedureItemReader`을 제공한다

  ```java
  @Bean
  @StepScope
  public StoredProcedureItemReader<Customer> customerItemReader(
      DataSource dataSource, @Value("#{jobParameters['city']}") String city
  ) {
    return new StoredProcedureItemReaderBuilder<Customer>()
        .name("StoredProcedureItemReader")
        .dataSource(dataSource)
        .procedureName("customer_list")
        .parameters(new SqlParameter[]{new SqlParameter("cityOption", Types.VARCHAR)})
        .preparedStatementSetter(new ArgumentPreparedStatementSetter(new Object[]{city}))
        .rowMapper(new CustomerRowMapper())
        .build();
  }
  ```

  ```sql
  -- schema-mysql.sql
  
  DELIMITER //
  
  CREATE PROCEDURE customer_list(IN cityOption CHAR(16))
    BEGIN
      SELECT * FROM CUSTOMER
      WHERE city = cityOption;
    END //
  
  DELIMITER ;
  ```

  ```java
  public class CustomerRowMapper implements RowMapper<Customer> {
  
    @Override
    public Customer mapRow(ResultSet rs, int rowNum) throws SQLException {
      ...
    }
  }
  ```

  ```yaml
  spring
  	datasource
  		schema: schema-mysql.sql
  ```

#### 스프링 데이터

- 몽고DB

  - 몽고DB의 특징

    - 

  - config

    1. 의존성 추가

       `implementation 'org.springframework.boot:spring-boot-starter-data-mongodb'`

    2. 잡 정의

       ```java
         @Bean
         public Step mongoDbStep() {
           return this.stepBuilderFactory.get("mongoDbStep")
               .<Map, Map>chunk(10)
               .reader(tweetsItemReader(null, null))
               .writer(itemWriter())
               .build();
         }
       
         @Bean
         @StepScope
         public ItemReader<? extends Map> tweetsItemReader(
             MongoOperations mongoTemplate, @Value("#{jobParameters['hashTag']}") String hashtag
         ) {
           return new MongoItemReaderBuilder<Map>()
               .name("tweetsItemReader")
               .targetType(Map.class)
               .jsonQuery("{ \"entities.hashtags.text\": {$eq: ?0 }}")
               .collection("tweets_collection")
               .parameterValues(Collections.singletonList(hashtag))
               .pageSize(10)
               .sorts(Collections.singletonMap("created_at", Direction.ASC))
               .template(mongoTemplate)
               .build();
         }
       ```

    3. 프로퍼티 추가

       `spring.data.mongodb.database: tweets` 추가

  

- 스프링 데이터 레포지터리

  - 스프링 데이터가 제공하는 인터페이스 중 하나를 상속하는 인터페이스를 정의하기만 하면 기본적인 CRUD작업을 할 수 있다
  - 스프링 배치가 스프링 데이터의 `PagingAndSortingRepository`를 사용하기 때문에 스프링 데이터와 호환이 좋다
  - `RepositoryItemReader`를 사용하면 스프링 데이터 레포지터리를 지원하는 어떤 데이터 저장소건 상관없이 질의를 할 수 있다

  ```java
  public interface CustomerRepository extends JpaRepository<Customer, Long> {
    Page<Customer> findByCity(String city, Pageable pageRequest);
  }
  ```

  ```java
  @Bean
  @StepScope
  public RepositoryItemReader<Customer> customerItemReader(
      CustomerRepository repository, @Value("#{jobParameters['city']}") String city
  ) {
    return new RepositoryItemReaderBuilder<Customer>()
        .name("customerItemReader")
        .arguments(Collections.singletonList(city))
        .methodName("findByCity")
        .repository(repository)
        .sorts(Collections.singletonMap("lastName", Sort.Direction.ASC))
        .build();
  }
  ```

### 기존 서비스

### 커스텀 입력

### 에러 처리

- 레코드 건너뛰기

  - 특정 예외가 발생했을 때 건너뛰는 기능을 제공한다
  - 건너뛸지 결정할때 고려사항
    1. 어떤 조건에서 건너뛸 것인가? (어떤 예외를 무시할 것인가?)
    2. 건너뛰는 걸 얼마나 허용할 것인가?
       - `skipLimit(10)` 이면 10번을 넘어가면 실패로 기록됨

  ````java
  @Bean
  public Step step() {
    return this.stepBuilderFactory.get("step")
      .<Customer, Customer>chunk(10)
      .reader(...)
      .writer(...)
      .faultTolerant() // 재시도 기능 활성화
      .skip(Exception.class)
      .noSkip(ParseException.class) // ParseException을 제외한 모든 예외 skip
      .skipLimit(10) // skip이 10번을 넘어가면 실패로 기록
      .build();
  }
  ````
  - 예외마다 skipLimit을 다르게 지정할 수도 있다. ( `SkipPolicy`인터페이스를 구현)

  ```java
  public CustomSkipper implements SkipPolicy {
    
    public boolean shouldSkip(Throwable exception, int skipCount) throws SkipLimitExceedException {
      if (exception instanceof FileNotFoundException) { //FileNotFoundException은 안 건너뜀
        return false
      } else if (exception instanceof ParseException && skipCount <= 10) { //ParseException은 10번까지 건너뜀
        return true;
      } else {
        return false;
      }
    }
  }
  ```

- 로그 남기기

  - `@OnReadError` 로 어떤 메시지를 로그로 남길지 정의하고 `listener`로 등록하면 된다

  ```java
  @Bean
  public Step step() {
    return this.stepBuilderFactory.get("step")
      .<Customer, Customer>chunk(10)
      .reader(...)
      .writer(...)
      .faultTolerant()
      .skipLimit(100)
      .skip(Exception.class)
      .listener(new CustomListener()) // <--
      .build();
  }
  ```

  ```java
  @Slf4j
  public class CustomListener {
    @OnReadError
    public void onReadError(Exception e) {
      if (e instanceof FlatFileParseException) {
        // 데이터베이스를 이용하는 처리를 할 땐 스프링 배치가 담당할 예외 처리가 많지 않으므로 충분한 정보를 담아야 한다
        log.error(...); 
      } else {
        log.error(...);
      }
    }
  }
  ```

- 레코드를 읽었는데 결과가 없는 경우

  - 레코드가 없어도 스프링배치는 완료된 것으로 처리한다 (null이 반환되어도 평상시 null을 받았을 때와 동일하게 처리하기 때문)
  - `@AfterStep`에서 조회한 레코드 수를 확인한 후 레코드가 없다면 실패처리를 한다

  ```java
  @Slf4j
  public class CustomListener {
    // 읽은 레코드 수가 0이라면 실패 처리
    @AfterStep
    public ExitStatus afterStep(StepExecution execution) {
      if (execution.getReadCount() > 0) {
        return execution.getExitStatus();
      } else {
        return ExitStatus.FAILED;
      }
    }
  }
  ```

<br/>

## 8장. ItemProcessor

### ItemProcessor 소개

```java
public interface ItemProcessor<I, O> {
  O process(I item) throws Exception;
}
```

- `ItemProcessor`가 반환하는 타입(`O`)는 `ItemWriter`의 입력 타입
- `process()`가 `null`을 반환하면 해당 아이템의 이후 모든 처리가 중지된다
  - 스텝 내에서 해당 아이템의 이후 `ItemProcessor`들과 `ItemWriter`는 호출되지 않는다

### 스프링 배치의 ItemProcessor 사용하기

- `ValidatingItemProcessor` : 입력 데이터의 유효성 검증에 사용
  - 
- `ItemProcessorAdapter`
- `ScriptItemProcessor`
- `CompositeItemProcessor`

### ItemProcessor 직접 만들기

<br/>

## 9장. ItemWriter

### ItemWriter 소개

### 파일 기반 ItemWriter

### 데이터베이스 기반 ItemWriter

### 스프링 데이터의 ItemWriter

### 그밖의 출력 방식을 위한 ItemWriter

### 여러 자원을 사용하는 ItemWriter

<br/>

