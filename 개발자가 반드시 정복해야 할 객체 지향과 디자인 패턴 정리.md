# :book: 개발자가 반드시 정복해야 할 객체 지향과 디자인 패턴

</br>

## 객체 지향

객체지향을 잘 하려면 이와 대조되는 절차지향이 뭔지 알아야 한다. 

절차지향적으로 코드를 작성하는 습관을 버림으로써 객체지향에 다가갈 수 있다.

</br>

### 절차 지향과 객체 지향

#### 절차지향 프로그래밍 : 프로시저로 프로그램을 구성하는 기법

절차지향(Procedual Oriented) 프로그래밍은 사실 절차지향 프로그램이라는 이름보다는 프로시저 지향 프로그램이라고 부르는 것이 더 의미에 맞다.

절차지향 프로그래밍은 수많은 프로시저들이 데이터를 공유하는 방식으로 만들어지기 때문에 자연스레 데이터 중심으로 구현하게 된다.

절차 지향적으로 코드를 구현하는 건 쉽다. 하지만 프로그램 규모가 커지면 다음과 같은 문제가 발생한다.

- 한 곳에서의 수정이 다른 곳의 수정을 연쇄적으로 유발할 수 있으므로 코드의 수정을 어렵게 한다.
- 같은 데이터를 프로시저들이 서로 다른 의미로 사용하게 되는 경우가 발생한다.

</br>

#### 객체지향 프로그래밍 : 데이터 및 프로시저를 객체라 불리는 단위로 구성하는 기법

각 객체는 자신만의 프로시저와 데이터를 갖는다.

각 객체의 프로시저는 자신이 속한 객체의 데이터에만 접근 가능하고, 다른 객체의 데이터엔 접근할 수 없다.

</br>

객체 지향의 장점

- 한 객체의 변경이 해당 객체로만 변화가 집중되고 다른 객체에 영향을 주지 않는다. (쉽게 수정할 수 있는 유연함)

</br>

### 객체

객체의 핵심은 기능을 제공하는 기능이다. 객체가 내부적으로 어떤 데이터를 갖고 있는 지로는 정의되지 않는다.

오퍼레이션 : 객체가 제공하는 기능

시그너처 : 오퍼레이션의 사용법 (기능식별 이름, 파라미터 및 파라미터 타입, 기능실행 결과값으로 이루어짐)

인터페이스 : 객체가 제공하는 모든 오퍼레이션 집합, 객체를 사용하기 위한 일종의 규칙, 한 객체의 책임 (자바의 interface타입과는 다른개념)

클래스 : 객체의 구현을 정의

메시지를 보낸다 : 오퍼레이션 실행을 요청하는 것

</br>

### 객체의 책임과 크기

객체가 갖는 책임은 어떻게 결정될까? 이 결정을 하는 것이 객체 지향 설계의 출발점이다.

먼저 필요한 기능 목록을 정리하여 적절한 객체에 기능을 할당한다.

객체가 갖는 책임의 크기는 작을수록 좋다. (Single Responsibility Principle; SRP)

왜냐하면 한 객체에 기능이 많아지면 절차 지향적인 구조가 만들어지기 때문이다.

</br>

### 의존

```java
public class FlowController {
    /* fileName 필드 초기화 코드 생략 */
    
    public void process() {
        FileDataReader reader = new FileDataReader(fileName);
        
        /* 생략 */
    }
}
```

한 객체가 다른 객체를 생성하거나 다른 객체의 메서드를 호출할때, 이를 그 객체에 의존한다고 표현한다.

(위 코드에선 `FlowController`가 `FileDataReader`에 의존한다고 표현할 수 있다.)

</br>

A클래스, B클래스, C클래스가 있고, 

C클래스가 B클래스에, B클래스가 A클래스에 의존한다고 상상해보자.

그럼 A클래스의 변경은 B클래스의 변경을 초래할 가능성이 있고, 이는 또 C클래스의 변경을 초래할 수 있다.

게다가 만약 A클래스가 C클래스에 의존하게 된다면 순환의존이 발생하여 

A클래스의 변경이 여파가 A클래스에 되돌아올 수 있다.

순환의존이 발생하지 않도록 하는 원칙 중의 하나로 의존 역전 원칙 (Dependency Inversion Principle; DIP)이 있다.

</br>

### 캡슐화

캡슐화란 객체가 내부적으로 기능을 어떻게 구현하는지를 감추는 것이다.

캡슐화를 통해 한 곳의 변화가 다른 곳에 미치는 영향을 최소화한다.

</br>

캡슐화를 사용하지 않고 절차 지향적으로 코드를 짠다면?

1. 변경 사항에 대해서 이와 관련 코드를 일일히 찾아가 수정해줘야 한다.
2. 미처 다 변경하지 않는 실수를 한다면 버그로 직결된다.

</br>

캡슐화를 위한 두 개의 규칙

1. Tell, Don't Ask

   데이터를 물어보지 않고 기능을 실행해 달라고 말하는 규칙.

   다른 객체의 데이터에 직접 접근해서 처리하려 하지 말고, 다른 객체에게 처리해달라고 부탁하라는 뜻이다.

2. 데미테르의 법칙 (Law of Demeter)

   데미테르의 법칙은 다음의 규칙들로 이루어진다.

   - 메서드에서 생성한 객체의 메서드만 호출
   - 파라미터로 받은 객체의 메서드만 호출
   - 필드로 참조하는 객체의 메서드만 호출

   즉, 데미테르 법칙을 어기면 `member.getData().getTime()`같이 getter을 연달아서 쓰는 코드가 나온다.

</br>

### 객체 지향 설계 과정

객체 지향 설계 과정은 다음의 작업을 반복하는 과정이다.

1. 제공해야 할 기능을 찾고 또는 세분화하고, 그 기능을 알맞은 객체에 할당한다.

   A. 기능을 구현하는데 필요한 데이터를 객체에 추가한다. 객체에 데이터를 먼저 추가하고 그 데이터를 이용하는 기능을 넣을 수도 있다

   B. 기능은 최대한 캡슐화해서 구현한다.

2. 객체 간에 어떻게 메시지를 주고받을 지 결정한다.

3. 과정1과 과정2를 개발하는 동안 지속적으로 반복한다.

객체의 크기는 한 번에 완성되기 보다는 구현을 진행하는 과정이나 테스트를 하는 과정에서 점진적으로 명확해진다.

</br>

## 다형성과 추상타입

### 다형성과 상속

다형성이란 한 객체가 여러 타입을 가질 수 있다는 것을 의미한다.

</br>

```java
public class Plane {
    public void fly() {
        /* 비행 */
    }
}

public interface Turbo {
    public void boost();
}

public class TurboPlane extends Plane implements Turbo {
    public void boost() {
        /* 가속 */
    }
}
```

```java
TurboPlane tp = new TurboPlane();

tp.fly(); //Plane으로부터 상속받기 때문에 Plane의 fly()를 실행할 수 있다
tp.boost(); //Turbo에서 정의되고 TurboPlane에서 구현된 메서드 실행
```

```java
TurboPlane tp = new TurboPlane();

Plane p = tp; //TurboPlane객체는 Plane타입도 된다.
p.fly();

Turbo t = tp; //TurboPlane객체는 Turbo타입 된다.
t.boost();
```

즉, `TurboPlane`타입의 객체는 `Plane`타입도 되고 `Turbo`타입도 될 수 있다. (다형성)

</br>

타입 상속은 크게 인터페이스 상속과 구현 상속으로 구분할 수 있다.

1. 인터페이스 상속

   순전히 타입 정의만을 상속받는 것이다.

   만약 A클래스가 B인터페이스와 C인터페이스를 상속받고 있다면 A클래스의 객체는 B타입도 되고, C타입도 된다.

2. 구현 상속

   보통 상위 클래스에 정의된 기능을 재사용하기 위한 목적이다.

   ```java
   public class Plane {
       public void fly() {
           /* Plane의 fly() 구현 */
       }
   }
   
   public class TurboPlane extends Plane {
       public void fly() {
           /* TurboPlane의 fly() 구현 */
       }
   }
   ```

   ```java
   Plane p = new TurboPlane();
   p.fly() //p가 가리키는 객체의 실제 타입은 TurboPlane클래스이기 때문에 
           //TurboPlane.fly()가 실행된다.
   ```

   </br>

### 추상 타입과 유연함

추상화 : 데이터나 프로세스 등을 의미가 비슷한 개념이나 표현으로 정의하는 과정

</br>

A인터페이스를 B, C, D 콘크리트 클래스(구상클래스)가 상속받고,

A인터페이스엔 run() 추상메서드가 있을 때,

```java
A a = someMethod();
a.run(); //someMethod()의 반환타입이 뭐냐에 따라 어느 클래스의 run()이 실행될 지 결정된다.
```

</br>

그럼 아래 코드처럼 사용하고자 하는 콘크리트 클래스를 직접 사용해도 되지 않은가?

```java
B b = new B();
b.run(); //B클래스의 run()을 사용하고 싶어 B의 객체를 직접 생성했다.
```

처음에는 문제가 발생하지 않으나, 새로운 요구사항이 생긴다면 문제가 생긴다.

아래 코드는 파일로부터 데이터를 읽어와서 암호화를 한 후에 파일에 쓰는 과정이다.

이 코드를 수정하는 과정에서 추상화의 장점을 느껴보자.

```java
public class FlowController {
    public void process() {
        FileDataReader reader = new FileDataReader();
        byte[] data = reader.read(); //파일로부터 데이터를 읽어옴
        
        Encryptor encryptor = new Encryptor();
        byte[] encryptedData = encryptor.encrypt(data); //읽어온 데이터로 암호화
        
        FileDataWriter writer = new FileDataWriter();
        writer.write(encryptedData); //암호화를 한 데이터를 파일에 쓴다
    }
}
```

그런데 만약에 파일 뿐만 아니라 소켓을 통해서도 데이터를 읽을 수도 있어야 한다고 하면 아래처럼 바꿔야 하는가?

```java
public class FlowController {
    private boolean useFile; //파일인지 소켓인지 구분하기 위한 boolean값
    
    public FlowController(boolean useFile) { //useFile필드를 설정하기 위한 생성자
        this.useFile = useFile;
    }
    
    public void process() {
        bype[] data = null;
        if (useFile) {
            FileDataReader fileReader = new FileDataReader();
            data = fileReader.read(); //파일로부터 데이터를 읽어옴
        }
        else {
            SocketDataReader socketReader = new SocketDataReader();
            data = socketReader.read(); //소켓으로부터 데이터를 읽어옴
        }
        
        Encryptor encryptor = new Encryptor(); //이 이후로는 앞의 코드와 동일
        byte[] encryptedData = encryptor.encrypt(data);
        
        FileDataWriter writer = new FileDataWriter();
        writer.write(encryptedData);
    }
}
```

그런데 이렇게 바꾸면 나중에 또 HTTP로 데이터를 읽어와야 한다면 어떻게 될까?

if-else블록이 또 생기고 useFile필드도 수정해주어야 한다. 생성자도 수정되어야 한다.

(...작성중...)





## 재사용: 상속보단 조립



## 설계 원칙: SOLID



## DI(Dependency Injection)와 서비스 로케이터



## 주요 디자인 패턴



