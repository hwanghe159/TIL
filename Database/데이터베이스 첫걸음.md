# 데이터베이스 첫걸음

## 1장. 데이터베이스란 - 용도와 역할

### 우리와 데이터베이스의 관계

- 데이터베이스는 어디에나 있다
- 모든 것은 데이터베이스로 모인다
- 데이터베이스는 주소록에서 시작되었다

### 데이터베이스의 기본 기능

1. 데이터의 검색과 갱신
   - 검색 : 원하는 데이터를 빠르게 찾을 수 있어야 한다
   - 갱신 : 데이터를 등록, 수정, 제거를 할 수 있어야 한다
   - 고유성 : 데이터를 어떤 포멧(형식)으로 관리하는가
   - 데이터가 방대할 때 처리 성능에 유의해야 한다
2. 동시성 제어
   - 동시의 복수의 사용자로부터 검색이나 갱신 처리를 받을때 무결성을 어느 정도로 보장하는가?가 문제가 됨
   - 트레이드오프
3. 장애 대응
   - 좀처럼 부서지기 어렵고, 부서졌다 하더라도 복원할 수 있어야 한다
   - 데이터가 소실되면 매우 큰 사회문제가 될 수도 있고 큰 손실을 일으킬 수 있다
   - 데이터 소실 문제의 대책
     1. 데이터 다중화 : 데이터를 복수의 장소에 분산해서 유지. 예방책
     2. 백업 : 복사본을 저장. 사후대책
   - 데이터 소실 사건이 끊이지 않는 이유? 서비스 레벨과 비용이란 트레이드오프의 딜레마로 고민하기 때문.
4. 보안
   - 데이터베이스를 사용자에게 보이지 않게 설계하는 이유
     1. 사용자는 서버를 의식할 필요가 없다
        - 사용자에게 가까운 기술이란 대다수가 클라이언트 기술 중심이라 서버의 기술은 그다지 의식되지 않기 때문
        - 서버는 사용자에게서 물리적으로 떨어진 장소에 설치되어 있음
        - 사용자가 데이터베이스를 직접 조작하는 일이 생긴다면 보안 구멍이라는 시스템의 결함이다
     2. 데이터베이스는 기밀성이 높다
        - 데이터베이스에는 일반인에게 공개할 수 없는 내용이 상당수 포함되어 있음
          - 계좌변호, 주소, 신용카드 번호 등등
        - 보안의 강도와 사용자 편의성은 트레이드오프 관계

### 데이터베이스의 종류

- 계층형 데이터베이스
  - 데이터를 계층 구조로 관리하는 데이터베이스 (조직도, 구조도와 비슷)
  - 현대적인 데이터베이스 역사상 최초로 등록
- 관계형 데이터베이스
  - 2차원 표 형식으로 데이터를 관리하는 데이터베이스
  - 가장 주류
- 객체지향 데이터베이스, XML 데이터베이스
  - 각각 객체와 XML이라는 형식으로 데이터를 관리하는 데이터베이스
  - 접할 기회 적음
- NoSQL 데이터베이스
  - NoSQL은 Not Only SQL(SQL뿐만 아니라 다른게 있다)이라는 뜻
  - 관계형 데이터베이스에 있는 기능 일부를 버려서 성능(처리속도)를 높임
  - 다량의 데이터를 고속으로 처리해야 하는 웹 서비스와 잘 맞아서 최근 자주 이용됨

</br>

## 2장. 관계형 데이터베이스란 - 가장 대표적인 데이터베이스

### 관계형 데이터베이스란

- 관계(Relational)?
  - 인간관계나 국제관계에서의 관계와는 의미가 다름
  - 2차원 표를 표기할때 사용하는 단어임
- 관계형 데이터베이스가 그렇게 혁신적인가?
  1. 지금이야 당연해 보이지만 관계형 데이터베이스는 2차원 표를 소프트웨어를 사용해 능숙히 표현한 최초의 소프트웨어였다
  2. 기능적으로 획기적이다.
     - 프로그래밍 언어를 사용하지 않아도 데이터 조작을 할 수 있다

### SQL 기초 지식

- SQL?
  - Structured Query Language
  - 관계형 데이터베이스가 데이터를 조작하기 위해 준비한 언어
  - 영어 문장과 매우 닮았음
  - 4가지 기본 조작 : SELECT, INSERT, UPDATE, DELETE
- 테이블
  - 관계형 데이터베이스에서 2차원 표
  - "어떤 테이블에 어떤 데이터를 포함하는가?"는 시스템의 기능을 좌우하는 중요한 질문이다.
    - 1개의 테이블에 많은 정보를 채우면 정보의 정합성을 유지 관리하기 어려워짐
    - 데이터를 너무 엄격하게 분산시키면 성능이 나빠짐
    - 테이블을 어떻게 설계하느냐는 기본적인 이론이 있지만 기계적으로 판단할 수 있는 건 아니다

### 관계형 데이터베이스를 다루기 위한 사전 지식

- 관계형 데이터베이스의 소프트웨어

  - Oracle, MySQL, SQL Server등등이 있음
  - MySQL, PostgreSQL등은 일정 요건 안에서는 무료로 사용 가능한 오픈소스임. 인기있음

- DBMS vs 데이터베이스

  - DBMS : 데이터베이스의 기능을 제공하는 소프트웨어
  - 데이터베이스는 추상적인 개념, DBMS는 구체적인 소프트웨어
    - MySQL은 DBMS의 한가지다. (바른 표현)
    - MySQL은 데이터베이스의 한가지다. (어색한 표현)

- 소프트웨어와 데이터베이스의 관계

  - 시스템은 소프트웨어의 조합인데, 소프트웨어는 크게 운영체제, 미들웨어, 애플리케이션으로 구분할 수 있다

  - 이 3가지는 계층성이 있으며, 운영체제는 하위 레이어, 미들웨어는 중간 레이어, 애플리케이션은 상위 레이어.

  - 한 레이어가 동작하지 않으면 상위 레이어도 동작하지 않는다

  - DBMS은 미들웨어에 속함.

  - 각 레이어에 대한 설명

    - 운영체제
      - Operating System, OS
      - 시스템을 동작하게 하기 위한 일종의 토대가 되는 기능을 제공하는 소프트웨어
        - 예 : Windows, Linux, UNIX, OS X, iOS, Android...
      - Linux, UNIX는 카테고리 이름 
        - Linux의 구현물은 Red Hat, Debian, Ubuntu...
        - UNIX의 구현물은 IBM의 AIX, HP의 HP-UX, Oracle의 Solaris...

    - 미들웨어

      - 중간 소프트웨어
      - OS에 설치하여 동작 (OS에서 동작)
      - OS + 데이터베이스 조합, 어떤게 좋을까?
        - 예산, 제품 기능, 개발자와 운영자의 기술 조합 등을 고려하여 선택한다
        - 조합은 어느정도 자유도가 높음. OS나 DBMS가 기능에 대한 표준 규격을 따르기 때문에 
        - 그래서 조합을 바꾸는 마이그레이션이 드물지 않음.
          1. OS만 변경 : DBMS의 수정은 적다
          2. DBMS만 변경 : DBMS의 수정이 많다
          3. OS, DBMS 둘다 변경 : 수정도 많고 가장 위험하다

    - 애플리케이션

      - 업무용 기능을 가진 프로그램된 소프트웨어

      - 사용자가 가장 빈번하게 조작하는 소프트웨어

      - 애플리케이션을 실현하는 수단은 크게 2가지가 있음 : 스크래치, 패키지

        1. 스크래치
           - 직접 프로그램을 처음부터 작성하는 방법
           - 직접 만들기 때문에 업무의 세세한 부분까지 시스템에서 대응할 수 있어 꼼꼼한 서비스를 할 수 있다
           - 개발 비용이 커진다

        2. 패키지
           - 기존에 있던 애플리케이션 소프트웨어를 사는 방법
           - 개발 비용을 줄일 수 있다
           - 패키지의 기능이 부족하여 커스터마이징에 의한 추가 개발때문에 오히려 개발 비용이 높아질수도 있다
           - 간단하게 기능을 추가할 수 없을수도 있다

      - 애플리케이션이 사용자와 데이터베이스 사이를 비집고 들어가 있다

        - 사용자가 데이터를 직접 조작하는게 아니라 애플리케이션을 매개로 데이터베이스에 접근한다
          - why? 보안을 높이기 위해, 업무 로직을 애플리케이션에 집중시켜 개발이나 수정에 걸리는 비용을 낮추기 위해

</br>

## 3장. 데이터베이스에 얽힌 돈 이야기 - 초기비용과 운영비용

### 왜 우리는 시스템에 돈을 내는가

- 왜 우리는 시스템에 돈을 내는가? 
  -> 데이터베이스는 무엇을 위해 도입하는가? 
  -> 시스템이란 무엇을 위해 도입하는가? 
  -> 편리한 기능을 세상에 제공하고, 대가로 이익을 얻기 때문 (돈벌이)

### 데이터베이스의 초기비용

- 초기비용 : 최초에 지급되는 돈

- 운영비용 : 서비스를 이용하는 기간에 계속해서 지급하는 돈

- 데이터베이스의 초기비용 (라이선스 요금)

- 가격과 소프트웨어 라이센스료의 차이

  1. 판매단위가 특수하다

     - 라이센스료의 판매단위

       1. 프로세서 라이선스 : 하드웨어의 CPU 성능에 따라 가격이 결정
       2. 사용자 라이선스 : 사용자 수에 따라 가격이 결정

       - 규모가 커질수록 라이선스료도 올라간다

       - 어느정도 규모를 가진 상용 시스템에선 사용자수를 파악하기 어려워 프로세서 라이선스를 사용하는 경우가 대부분이다
       - ex ) SQL Server 2014, DB2 v10.5

  2. 운영비용을 지급하지 않으면 현실적으로 사용할 수 없다

### 초기비용을 늘리는 범인

- 에디션과 옵션의 선택을 잘 이해해야 필요하지 않는 기능까지 구매하게 되는 일을 막을 수 있다
- 에디션은 대부분 다음 2가지에서 파생되었다
  1. 스탠다드 에디션
     - 중소규모 시스템용
  2. 엔터프라이즈 에디션
     - 대규모 시스템용
     - 스탠다드 에디션엔 없는 신뢰성, 성능, 보안관련 기능을 제공함

### 데이터베이스의 운영비용

- 기술지원 비용

  - 기술지원 없는 소프트웨어는 위험하다.

  - 사고가 일어났을 때 자신의 조직이 책임져야 한다. 일종의 보험

  - 기술지원이 종료되는 타이밍(EOSL)을 고려해야 한다

    | 구분 | 신버전                                                       | 구버전                                                       |
    | ---- | ------------------------------------------------------------ | ------------------------------------------------------------ |
    | 장점 | - 기술 지원이 길다<br />- 구버전과 비교해서 상위 기능이 많다 | - 동작이 안정되어 있다<br />- 정보가 많고 엔지니어도 사용법에 익숙하다 |
    | 단점 | - 버그가 많아서 동작이 불안정하다                            | - 기술지원 기간이 짧다<br />- 신버전과 비교하면 기능이 적다  |

  - 트레이드오프는 항상 고민거리
  - 같은 제품의 버전이나 아키텍쳐의 선행사례가 있는지 살펴보는 것이 도움이 된다

### 초기비용과 운영비용의 조합

- 초기비용 X + 운영비용 X
  - 상용 시스템에 사용하는 수준의 품질을 요구하는 데이터베이스에서는 현실적으로 존재하지 않음
- 초기비용 O + 운영비용 O
  - 상용 시스템용에서 가장 일반적
- 초기비용 O + 운영비용 X
  - 기술지원 없음. 현실적인 선택지 아님
- 초기비용 X + 운영비용 O
  1. 오픈소스를 이용
     - 서브스크립션(임대) 형식
       - 라이선스료는 무료고 기술지원료만 유상
       - ex) Red Hat, MySQL
       - 장점
         1. 처음에 일정 금액을 가지고 있지 않아도 이용할 수 있음
         2. 시작도 간단하고 그만두는것도 간단
         3. 타 데이터베이스로 마이그레이션이 쉬움
       - 단점
         1. 이용기간이 길면 전체비용이 구매 비용보다 높아질 가능성이 있음
         2. 임대를 제공하는 서비스가 정지되면 이용할 수 없게 될 위험이 있음
         3. 장기적으로 요금 인상 등의 비용 변경 요소가 있음

### 초기비용의 트릭

- 전체 비용이 같더라도 초기 비용이 낮으면 더 매력적으로 느낀다고 함
- 전체 비용을 확실하게 계산하자

</br>

## 4장. 데이터베이스와 아키텍쳐 구성 - 견고하고 고속의 시스템을 구축하기 위해

다중화(고가용성)이란?

- 예) DB 서버가 2대 있을때 1대가 고장난다 하더라도 나머지 1대가 동작하여 서비스의 정지를 막는 것

### 아키텍쳐란

- 아키텍쳐? 
  - 시스템을 만들기 위한 물리 레벨의 조합
  - 어떤 기능을 가진 서버를 준비하고 어떠한 저장소나 네트워크 기기와 조합해서 시스템 전체를 만들 것인가?
  - 하드웨어와 미들웨어의 구성
  - 이 구성을 시스템이 완수해야 할 목적과 비교하면서 결정해 가는 것이 아키텍쳐 설계다.
  - 아키텍쳐는 시스템의 목적과 기능을 나타낸다

### 데이터베이스의 아키텍쳐 1. 역사와 개요

아키텍쳐의 역사는 다음 3단계로 나눌 수 있다

1. Stand-alone(~1980년대)
   - 데이터베이스만으로 시스템이 성립하는 가장 간단한 방법
   - 데이터베이스가 동작하는 머신(DB서버)이 LAN이나 인터넷 등의 네트워크에 접속하지 않고 독립되어 동작하는 구성
   - 단점
     1. 물리적으로 떨어진 장소에서 접근할 수 없다
        - 네트워크에 연결되어 있지 않기 때문
     2. 복수 사용자가 동시에 작업을 수 없다
        - 네트워크에 연결되어 있지 않기 때문
     3. 가용성이 낮다
        - 서버가 1개뿐이니 1대에 장애가 발생하면 서비스가 정지한다
        - 고성능의 부품으로 교체하기 위해선 시스템을 정지해야 한다
     4. 확장성이 부족하다
        - 성능이 나쁠 때 개선수단이 매우 부족하다
   - 장점
     1. 구축이 매우 간단해서 소규모 작업이나 테스트를 빨리할 수 있다
     2. 보안이 매우 높다
        - 네트워크를 매개로 침입할 위험이 없음
2. 클라이언트/서버(1990년대~2000년)
   - 클라이언트와 서버로 계층을 분리하여 상호 간에 네트워크로 접속
   - 데이터베이스 서버 1대에 복수의 사용자의 단말이 접속하는 구성
   - 단점
     1. 보안 위험
        - 인터넷에서 직접 데이터베이스에 접속할 수도 있음
     2. 관리비용이 많이 듦
        - 개인이 이용하는 PC에 네이티브 앱을 설치해 동작하게 했기 때문에 각종 환경에 대응해야 했다
        - 그래서 비즈니스 로직을 실행하는 애플리케이션을 서버에서 관리해 비용을 절감하자는 요구가 나옴 (이게 Web 3계층)
3. Web 3계층(2000년~현재)
   - 시스템을 웹 서버 계층, 애플리케이션 계층, 데이터베이스 계층의 조합으로 생각하는 모델
   - 웹 서버 계층
     - 클라이언트로부터 접속 요청을 직접 받아서 그 처리를 뒷단의 애플리케이션 계층에 넘기고 그 결과를 클라이언트에 반환
     - 애플리케이션 서버와 클라이언트 웹 브라우저와의 가교 역할
     - 직접적인 접속 요청을 받는 역할을 웹 서버 계층에 한정하여 보안을 높일 수 있음
     - ex) 아파치, IIS
   - 애플리케이션 계층
     - 비즈니스 로직을 구현한 애플리케이션이 동작하는 층
     - 웹 서버로부터 인계된 요청을 처리하고 필요하면 데이터베이스 계층에 접속하여 데이터를 추출하고 이를 가공한 결과를 웹 서버로 반환
     - 비즈니스 로직을 집중하여 애플리케이션 관리 비용을 낮출 수 있음
     - ex) 톰캣, 웹로직, 웹스피어

### 데이터베이스의 아키텍쳐 2. 가용성과 확장성의 확보

- Web 3계층은 Stand-alone 구성의 단점 중 2가지 문제만 해결했다
  1. ~~물리적으로 떨어진 장소에서 접근할 수 없다 (해결)~~
  2. ~~복수 사용자가 동시에 작업을 수 없다 (해결)~~
  3. 가용성이 낮다
  4. 확장성이 부족하다
- 가용성을 높이는 전략
  1. 심장전략
     - 고품질-소수전략
     - 시스템을 구성하는 각 컴포넌트의 신뢰성을 높여 장애 발생률을 낮게 억제해서 가용성을 높인다
     - 소수정예 노선
  2. 신장전략
     - 사물은 언젠간 망가진다란 체념을 전제로 여분을 준비해둔다 (컴포넌트를 병렬화)
     - 물량작전
     - 현재는 심장전략이 더 우세
- 클러스터
  - 클러스터링 : 신장전략처럼 컴포넌트를 병렬화하는것
  - 클러스터 구성으로 시스템의 가동률을 높이는 것 = '여유도를 확보한다', '다중화'
  - 서버 대수가 늘어날수록 시스템 가동률은 높아진다. 단 100%는 불가능
- 단일 장애점
  - SPOF : Single Point Of Failure
  - 다중화 되어 있지 않아서 시스템 전체 서비스의 계속성에 영향을 주는 컴포넌트
  - 단일 장애점의 신뢰성이 시스템 전체의 가용성을 결정한다

### DB 서버의 다중화 - 클러스터링

- DB서버는 영속 계층이기 때문에 클러스터링이 어렵고 고민해야 할 부분이 많다
- 데이터는 항상 갱신되기 때문에 다중화를 유지하는 중에 데이터 정합성도 중요하게 의식해야 함
- 가장 기본적인 다중화
  - DB 서버만 다중화하고 저장소는 하나
  - 저장소가 1개라서 정합성을 신경쓸 필요가 없음
  - DB서버 2대가 동시에 동작하는 것을 허락할지에 따라 Active-Active, Active-Standby로 나뉨
    - Active-Active
      - 클러스터를 구성하는 컴포넌트를 동시에 가동
      - Oracle, DB2만 가능
      - 장점
        1. 시스템 다운 시간이 짧음 : 한 대가 동작불능이 되어도 남은 서버가 처리함
        2. 성능이 좋음 : 가동하는 CPU나 메모리도 증가하기 때문. 단 저장소가 병목될 수 있음
    - Active-Standby
      - 실제 가동하는 것은 Active, 남은 것은 Standby
      - Standby상태의 DB서버는 사용되지 않다가 Active DB서버에서 장애가 일어날 때만 사용됨
      - 전환될 때의 시차에 다운 상태가 됨
      - Cold-Standby와 Hot-Standby가 있음
        - Cold-Standby
          - 평소에는 Standby DB가 작동하지 않다가 Active DB가 다운된 시점에 작동
        - Hot-Standby
          - 평소에도 Standby DB가 작동
          - 전환시간은 짧지만 라이선스료가 높음
    - 비싼 순, 사용성/성능 좋은 순
      1. Active-Active
      2. Active-Standby(Hot-Standby)
      3. Active-Standby(Cold-Standby)

### DB 서버와 데이터의 다중화 - 리플리케이션

- 리플리케이션
  - DB서버와 저장소 세트를 복수로 준비하는 것
  - DB서버 뿐만 아니라 데이터도 다중화한다
  - 데이터베이스 서버와 저장소가 동시에 불능일때(지진, 태풍 등) 다른 세트가 멀리 있다면 계속 서비스 가능 -> 가용성이 매우 높다
  - 주의할 점
    - Active측 저장소의 데이터를 Standby측 데이터에 갱신을 최신화(동기화) 하지 않으면 데이터 정합성을 유지할 수 없다
      - ex) 동기화를 1일 1회 한다면, 저장소가 망가진 경우 최대 1일치의 데이터 갱신이 소실된다
    - Standby측의 갱신 주기를 얼마로 할 것인가? 동기화가 성공하는 것을 확인할 것인가?도 트레이드 오프
      - 데이터 보호 vs 성능
    - 손자나 증손자 세트를 만듦으로써 피라미드형 구성을 할 수도 있음
      - 부모에 걸리는 부하를 분산할 수 있음
      - 손자나 증손자의 데이터는 오래된 데이터(오래된 데이터라도 상관없다면 ok)
      - 비용, 시스템 구성 노력 증가됨

### 성능을 추구하기 위한 다중화 - Shared Nothing

- Shared Disk
  - 복수의 서버가 1대의 디스크를 사용하는 구성
  - DB서버를 늘려도 처리율이 무한으로 향상되지 않는다.
    - 저장소가 공유 자원이라서 쉽게 늘리기 어렵기 때문
    - DB서버 대수가 증가할수록 DB서버간의 정보공유를 위한 오버헤드가 크기 때문
  - 이 단점을 극복하기 위해 고안된 아키텍쳐 : Shared Nothing
- Shared Nothing
  - 네트워크 이외의 자원을 모두 분리하는(아무것도 공유하지 않는) 방식
  - 구글이 개발한 Shared Nothing 구조를 샤딩(Sharding)라고 함
  - 장점
    - 서버와 저장소의 세트를 늘리면 병렬처리 때문에 선형적으로 성능이 향상된다
  - 단점
    - 각각의 DB서버가 동일한 1개의 데이터에 액세스 할 수 없다
      - 이 단점에 대처하려면 커버링 구성을 고려해야 함
      - 커버링? DB서버 하나가 다운되었을 때 다른 DB서버가 이를 이어받아 계속 처리할 수 있게 함

### 적합한 아키텍쳐를 설계하기 위해

- 아키텍쳐는 요건에 따라 결정되기 때문에 요건을 결정하지 않으면 아키텍쳐도 결정할 수 없다
- 아키텍쳐는 한 번 구축하면 이후에 변경하는것이 어렵다

</br>

## 5장. DBMS를 조작할 때 필요한 기본지식 - 조작하기 전에 알아두어야 할 것

</br>

## 6장. SQL 문의 기본 - SELECT 문의 이해

</br>

## 7장. 트랜잭션과 동시성 제어 - 복수의 쿼리 통합

</br>

## 8장. 테이블 설계의 기초 - 테이블의 개념과 정규형

</br>

## 9장. 백업과 복구 - 장애에 대비하는 구조

</br>

## 10장. 부록_성능을 생각하자 - 성능 향상을 위해

</br>