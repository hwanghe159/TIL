# 친절한 SQL 튜닝

## 1장. SQL 처리 과정과 I/O

### 1.1 SQL 파싱과 최적화

- SQL (Structured Query Language)
  - 구조적, 집합적, 선언적 질의 언어
- 전체적인 과정
  - 사용자 --SQL--> 옵티마이저 --실행계획--> 프로시저
- SQL 최적화
  - DBMS 내부에서 프로시저를 작성하고 컴파일해서 실행 가능한 상태로 만드는 전 과정
- SQL이 실행되는 과정
  1. SQL 파싱
     - 파싱 트리 생성 (SQL 개별 구성요소를 분석해서 파싱 트리 생성)
     - Syntax 체크 (문법 오류 확인)
     - Semantic 체크 (의미상 오류 확인. 없는 테이블인지, 없는 컬럼인지, 권한은 있는지 등)
  2. SQL 최적화
     - 옵티마이저가 다양한 실행 경로 중 하나를 선택한다
  3. 로우 소스 생성
     - 옵티마이저가 선택한 실행 경로를 실제 실행 가능한 코드 또는 프로시저로 포맷팅
     - 로우 소스 생성기가 수행함
- SQL 옵티마이저
  - 최적의 데이터 액세스 경로를 선택해주는 DBMS의 핵심 엔진
  - 단계 : 후보 실행계획을 찾음 -> 각 실행계획의 예상비용 산정(데이터 딕셔너리에 미리 수집해둔 통계 및 시스템 통계 정보 이용) -> 최저비용 선택
- 옵티마이저 힌트
  - 옵티마이저가 항상 최적의 실행계획을 찾는 건 아니다. SQL이 복잡할수록 실수할 가능성이 크다
  - 직접 사용할 인덱스를 결정해줄 수 있다
  - 일부만 지정해주고 나머지는 옵티마이저가 알아서 선택하도록 해줄수도 있다

### 1.2 SQL 공유 및 재사용

- 소프트 파싱 vs 하드 파싱

  - DBMS가 SQL을 파싱한 후 해당 SQL이 라이브러리 캐시에 존재하는지 확인하여 
    - 있으면? 곧바로 실행 (소프트 파싱)
    - 없으면? 최적화 -> 로우소스 생성 -> 실행 (하드 파싱)

- SQL 최적화를 할때 옵티마이저가 사용하는 정보

  - 테이블, 컬럼, 인덱스 구조
  - 오브젝트 통계 (테이블 통계, 인덱스 통계, 컬럼 통계)
  - 시스템 통계 (CPU속도, Single Block I/O 속도, Multiblock I/O 속도)
  - 옵티마이저 관련 파라미터 등등

- 이렇게 많은 정보를 사용하여 무거운 연산을 통해 도출한 내부 프로시저를 한 번만 사용한다면 비효율적이다. 그래서 라이브러리 캐시가 필요하다

- 바인드변수를 잘 활용해야 한다

  - 예를 들어 다음과 같이 라이브러리 캐시가 남으면 안되고,

    ```sql
    SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'hwang'
    SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'kim'
    SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'lee'
    SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'park'
    ...
    ```

  - 다음과 같이 남아야 한다

    ```sql
    SELECT * FROM CUSTOMER WHERE LOGIN_ID = :1
    ```

### 1.3 데이터 저장 구조 및 I/O 메커니즘

- SQL이 느린 이유는 거의 I/O 때문

- 데이터베이스 저장 구조

  - <img src="../images/table_space.jpeg" alt="table_space" style="zoom:30%;" />
  - 데이터 파일 : 디스크 상의 물리적인 OS 파일
  - 테이블 스페이스 : 세그먼트를 담는 컨테이너
  - 세그먼트 : 데이터 저장공간이 필요한 오브젝트
  - 익스텐트 : 공간을 확장하는 단위
  - 블록 : 데이터를 읽고 쓰는 단위

- 테이블 또는 인덱스 블록을 읽는 방식

  - <img src="../images/access.jpeg" alt="access" style="zoom:30%;" />

  1. 시퀀셜 엑세스 : 차례로 블록을 읽는 방식
  2. 랜덤 액세스 : 레코드 하나를 읽기 위해 한 블록씩 접근하는 방식

- 논리적 I/O vs 물리적 I/O

  - 논리적 I/O
    - SQL문을 처리하는 과정에 메모리 버퍼캐시에서 발생한 총 블록 I/O
  - 물리적 I/O
    - 디스크에서 발생한 총 블록 I/O를 말한다

- 버퍼캐시 히트율(BCHR) = ( 1- ( 물리적I/O / 논리적I/O ) ) * 100

  - 물리적I/O는 통제불가, 논리적I/O는 통제가능
  - 논리적I/O를 줄임으로써 물리적I/O를 줄이는 것이 SQL 튜닝이다
  - BCHR이 높다고 해서 효율적인 SQL라는 뜻은 아니다 (같은 블록을 비효율적으로 반복하면 BCHR은 높아진다)

- Single Block I/O vs Multiblock I/O

  - I/O call할때
    - 한번에 한 블록씩 요청해서 메모리에 적재하면 Single Block I/O
    - 한번에 여러 블록씩 요청해서 메모리에 적재하면 Multiblock I/O
  - 인덱스를 사용할때는 기본적으로 Single Block I/O를 사용한다 (소량을 읽을때 주로 사용하므로)
  - 많은 데이터 블록을 읽을땐 Multiblock I/O가 효율적이다 (같은 익스텐트에 속한 블록을 모두 가져온다)

- Table Full Scan vs Index Range Scan

  - Table Full Scan : 테이블 전체를 스캔해서 읽는 방식
    - 시퀀셜 엑세스와 Multiblock I/O 방식으로 디스크 블록을 읽는다
    - 한 블록에 속한 모든 레코드를 한번에 읽어들이고 캐시에서 못찾으면 한번의 수면을 통해 많은 블록을 한꺼번에 I/O하는 매커니즘
  - Index Range Scan : 인덱스를 이용하여 읽는 방식
    - 랜덤 액세스와 Single Block I/O 방식으로 디스크 블록을 읽는다
    - 캐시에서 블록을 못찾으면 레코드 하나를 읽기 위해 매번 잠을 자는 I/O매커니즘
    - 많은 데이터를 읽을때는 오히려 성능이 떨어질 수 있다

- 캐시 탐색 매커니즘

  - 다음의 경우 버퍼캐시 탐색 과정을 거친다
    - 인덱스 루트 블록을 읽을때
    - 인덱스 루트 블록에서 얻은 주소 정보로 브랜치 블록을 읽을때
    - 인덱스 브랜치 블록에서 얻은 주소 정보로 리프 블록을 읽을때
    - 인덱스 리프 블록에서 얻은 주소 정보로 테이블 블록을 읽을때
    - 테이블 블록을 Full Scan할때
  - 버퍼 캐시에서는 블록 번호를 해시함수로 관리한다
  - 래치
    - 버퍼 블록을 여러 프로세스가 동시에 접근하면 안된다. 그래서 직렬화(줄세우기)가 필요하다. 직렬화가 가능하도록 지원하는 매커니즘을 래치라고 한다
    - 버퍼캐시에는 캐시버퍼 체인래치, 캐시버퍼 LRU 체인래치 등이 작동한다
    - 버퍼블록 자체에서 직렬화 매커니즘이 존재한다 (버퍼 락)

<br/>

## 2장. 인덱스 기본

### 2.1 인덱스 구조 및 탐색

- 인덱스 탐색 과정은 수직적 탐색과 수평적 탐색, 단 두 단계로 이루어진다

  - 수직적 탐색 : 인덱스 스캔 시작지점을 찾는 과정
    - 주의! 수직적 탐색은 '조건을 만족하는 레코드를 찾는 과정'이 아니라 '조건을 만족하는 첫번째 레코드를 찾는 과정'이다.
  - 수평적 탐색 : 데이터를 찾는 과정
    - 수평적 탐색을 하는 이유는 조건절을 만족하는 데이터를 빠뜨리지 않고 모두 찾기 위해, ROWID를 얻기 위해

- 인덱스 튜닝의 두 가지 핵심요소

  1. 인덱스 스캔 과정에서 발생하는 비효율을 줄이는 것 : 인덱스 스캔 효율화 튜닝
  2. 테이블 액세스 수를 줄이는 것 : 랜덤 액세스 최소화 튜닝

  둘 다 중요하지만 랜덤 액세스 최소화 튜닝이 성능에 미치는 영향이 더 크기 때문에 더 중요하다 -> SQL튜닝은 랜덤I/O와의 전쟁이다!

- 인덱스를 이루는 컬럼을 어떤 순서로 놓든 읽는 인덱스 블록 개수는 똑같다. 왜냐하면 B-Tree이기 때문에 루트와 리프간의 거리는 같기 때문에.

### 2.2 인덱스 기본 사용법

- '인덱스를 사용한다' = '리프 블록에서 스캔 지점을 찾아 거기서부터 스캔하다가 중간에 멈추는 것'
- 인덱스 컬럼을 가공하면 인덱스를 정상적으로 사용할 수 없다
  - 인덱스 스캔 시작지점을 찾을 수 없기 때문
  - Range scan하지 못하는 예
    - 생년월일(yyyymmdd)이 인덱스 컬럼일때 5월생 조회
    - 주문수량이 인덱스 컬럼일때 주문수량이 null이면 0으로 치환한 값을 기준으로 100보다 작은 레코드 조회
    - 업체명이 인덱스 컬럼일때 '대한'을 포함하는 업체 조회
    - 전화번호와 고객명이 인덱스 컬럼일때 전화번호가 01012345678 또는 고객명이 '홍길동'인 고객 조회
      - (옵티마이저가 OR Expansion을 통해 인덱스가 작동하도록 하는 경우도 있음)
    - 전화번호가 인덱스 컬럼일때 IN절로 조회
      - (옵티마이저가 IN-List Iterator 방식으로 인덱스가 작동하도록 하는 경우도 있음)
- 인덱스를 Range Scan 하기 위한 첫번째 조건은 인덱스 선두 컬럼이 (가공하지 않은 상태로) 조건절에 있어야 한다.
- 인덱스를 사용하면 이미 정렬되어 있기 때문에 order by 연산을 생략할 수 있다 (리프 블록은 양방향 연결리스트니까 desc도 마찬가지)

### 2.3 인덱스 확장기능 사용법

<br/>

## 3장. 인덱스 튜닝

### 3.1 테이블 액세스 최소화

### 3.2 부분범위 처리 활용

### 3.3 인덱스 스캔 효율화

### 3.4 인덱스 설계

<br/>

## 4장. 조인 튜닝

### 4.1 NL 조인

### 4.2 소트 머지 조인

### 4.3 해시 조인

### 4.4 서브쿼리 조인

<br/>

## 5장. 소트 튜닝

<br/>

## 6장. DML 튜닝

<br/>

## 7장. SQL 옵티마이저

<br/>
