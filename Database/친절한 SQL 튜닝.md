# 친절한 SQL 튜닝

## 1장. SQL 처리 과정과 I/O

### 1.1 SQL 파싱과 최적화

- SQL (Structured Query Language)
  - 구조적, 집합적, 선언적 질의 언어
- 전체적인 과정
  - 사용자 --SQL--> 옵티마이저 --실행계획--> 프로시저
- SQL 최적화
  - DBMS 내부에서 프로시저를 작성하고 컴파일해서 실행 가능한 상태로 만드는 전 과정
- SQL이 실행되는 과정
  1. SQL 파싱
     - 파싱 트리 생성 (SQL 개별 구성요소를 분석해서 파싱 트리 생성)
     - Syntax 체크 (문법 오류 확인)
     - Semantic 체크 (의미상 오류 확인. 없는 테이블인지, 없는 컬럼인지, 권한은 있는지 등)
  2. SQL 최적화
     - 옵티마이저가 다양한 실행 경로 중 하나를 선택한다
  3. 로우 소스 생성
     - 옵티마이저가 선택한 실행 경로를 실제 실행 가능한 코드 또는 프로시저로 포맷팅
     - 로우 소스 생성기가 수행함
- SQL 옵티마이저
  - 최적의 데이터 액세스 경로를 선택해주는 DBMS의 핵심 엔진
  - 단계 : 후보 실행계획을 찾음 -> 각 실행계획의 예상비용 산정(데이터 딕셔너리에 미리 수집해둔 통계 및 시스템 통계 정보 이용) -> 최저비용 선택
- 옵티마이저 힌트
  - 옵티마이저가 항상 최적의 실행계획을 찾는 건 아니다. SQL이 복잡할수록 실수할 가능성이 크다
  - 직접 사용할 인덱스를 결정해줄 수 있다
  - 일부만 지정해주고 나머지는 옵티마이저가 알아서 선택하도록 해줄수도 있다

### 1.2 SQL 공유 및 재사용

- 소프트 파싱 vs 하드 파싱

  - DBMS가 SQL을 파싱한 후 해당 SQL이 라이브러리 캐시에 존재하는지 확인하여 
    - 있으면? 곧바로 실행 (소프트 파싱)
    - 없으면? 최적화 -> 로우소스 생성 -> 실행 (하드 파싱)

- SQL 최적화를 할때 옵티마이저가 사용하는 정보

  - 테이블, 컬럼, 인덱스 구조
  - 오브젝트 통계 (테이블 통계, 인덱스 통계, 컬럼 통계)
  - 시스템 통계 (CPU속도, Single Block I/O 속도, Multiblock I/O 속도)
  - 옵티마이저 관련 파라미터 등등

- 이렇게 많은 정보를 사용하여 무거운 연산을 통해 도출한 내부 프로시저를 한 번만 사용한다면 비효율적이다. 그래서 라이브러리 캐시가 필요하다

- 바인드변수를 잘 활용해야 한다

  - 예를 들어 다음과 같이 라이브러리 캐시가 남으면 안되고,

    ```sql
    SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'hwang'
    SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'kim'
    SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'lee'
    SELECT * FROM CUSTOMER WHERE LOGIN_ID = 'park'
    ...
    ```

  - 다음과 같이 남아야 한다

    ```sql
    SELECT * FROM CUSTOMER WHERE LOGIN_ID = :1
    ```

### 1.3 데이터 저장 구조 및 I/O 메커니즘

<br/>

## 2장. 인덱스 기본

### 2.1 인덱스 구조 및 탐색

### 2.2 인덱스 기본 사용법

### 2.3 인덱스 확장기능 사용법

<br/>

## 3장. 인덱스 튜닝

<br/>

## 4장. 조인 튜닝

<br/>

## 5장. 소트 튜닝

<br/>

## 6장. DML 튜닝

<br/>

## 7장. SQL 옵티마이저

<br/>
