# 03. 아키텍쳐
## 3.2 InnoDB 스토리지 엔진 아키텍쳐

- MySQL의 스토리지 엔진들 중 거의 유일하게 레코드 기반 잠금 제공 -> 높은 동시성 처리
- InnoDB의 특징
	- PK 기준으로 클러스터링되어 저장됨 (PK 순서대로 디스크에 저장됨)
	- MVCC 기술을 사용해서 락 걸지 않고 읽는다 (SERIALIZABLE 제외)
	- 현업에서 잘 쓰진 않지만 FK 지원한다
	- 자동으로 데드락을 감지하고 데드락 발생 시 비용이 더 적은 트랜잭션을 자동으로 종료시킨다
	- 손실이나 장애로부터 데이터를 보호하기 위한 여러 매커니즘이 있다

![[inno-db-architecture.jpeg]]
- InnoDB 버퍼 풀
	- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간. 아직 디스크에 기록되지 않은 변경된 데이터를 가지고 있다.
	- 일괄작업 되도록 버퍼 역할도 한다. 
- 언두 로그
	- 변경(UPDATE, DELETE) 전의 데이터를 보관하는 곳
	- 용도1. 트랜잭션 롤백 대비용
	- 용도2. 트랜잭션의 격리수준을 유지하면서 높은 동시성을 제공
- 인서트 버퍼
	- INSERT, UPDATE 될때는 데이터 파일 뿐 아니라 인덱스 업데이트도 필요하다.
	- 인덱스가 많다면 많은 자원을 소모하므로 임시 공간(인서트 버퍼)에 저장해두고 사용자에게 바로 반환한다
- 리두 로그
	- 변경된 내용을 순차적으로 기록
	- 리두 로그 덕분에 변경된 내용을 한꺼번에 처리할 수 있다
- 로그 버퍼
	- 리두 로그 버퍼링에 사용되는 공간
- MVCC (Multi Version Concurrency Control) 예시
	- 가정 : 격리 수준은 READ_COMMITTED, 엔진 : InnoDB
	- `UPDATE member SET area = '경기' WHERE id = 12;` 으로 area 값을 서울 -> 경기로 바꿨다면?
	- 커밋 여부와 관계 없이 버퍼 풀엔 `경기` 언두 로그엔 이전 값(`서울`), 디스크엔 모름(일반적으론 `경기`)
	- 커밋 전에 다른 트랜잭션에서 `SELECT * FROM member WHERE id = 12;` 를 하면 언두로그에 있는 이전 값을 읽는다.
	- 롤백되야 한다면 언두 영역의 데이터를 버퍼 풀로 복구하고 언두로그를 삭제한다
- 잠금 없는 일관된 읽기
	- SERIALIZABLE 외의 격리수준에선 SELECT할때 다른 트랜잭션과 관계없이 잠금을 대기하지 않고 바로 읽는다
# 04. 트랜잭션과 잠금
## 4.1 트랜잭션
- MyISAM은 트랜잭션을 지원하지 않는다
- 트랜잭션 범위는 최소화하여 커넥션 점유 시간을 줄이는 것이 좋다
## 4.2 MySQL 엔진의 잠금
- MySQL의 잠금은 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나뉜다
	- MySQL 엔진(MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분) 레벨 잠금 : 모든 스토리지 엔진에 영향을 미침
		- 테이블 락, 유저 락, 네임 락
	- 스토리지 엔진 레벨 잠금 : 엔진 간 영향 없음
- 글로벌 락
	- `FLUSH TABLES WITH READ LOCK` 으로만 획득 가능
	- 락 중 범위가 가장 큼
	- 다른 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 쿼리가 대기한다
- 테이블 락
	- `LOCK TABLES table_name [READ|WRITE]` 으로 명시적으로 획득하거나 묵시적으로 획득 가능
	- `UNLOCK TABLES` 로 락 반납
	- InnoDB에선 레코드 기반의 락을 제공하기 때문에 묵시적인 테이블 락이 설정되지 않는다
- 유저 락
	- 사용자가 지정한 문자열에 대해 획득하고 반납하는 락
	- 자주 쓰이진 않지만 여러 클라이언트가 상호 동기화를 처리해야 할때나 배치같이 한꺼번에 많이 변경하는 프로그램에서의 데드락 문제를 해결할때 사용할 수 있다
- 네임 락
	- 테이블이나 뷰의 이름을 변경할때(`RENAME TABLE tab_a TO tab_b`) 자동으로 획득하는 락
## 4.4 InnoDB 스토리지 엔진의 잠금
- 레코드 기반 잠금 방식을 탑재하고 있어 MyISAM보다는 훨씬 뛰어난 동시성 처리를 제공한다
- InnoDB는 비관적 락 방식 채택
	- 비관적 락 : 현재 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경하는 방식
	- 낙관적 락 : 우선 변경하고 충돌이 있다면 롤백처리하는 방식
- InnoDB의 락 종류
	![[innodb_lock.jpeg]]
	- 레코드 락
		- 레코드 자체만 잠그는 락.
		- pk또는 unique 인덱스에 의한 변경작업은 레코드락만 건다
		- InnoDB는 레코드 자체가 아니라 인덱스의 레코드를 잠근다.
	- 갭 락
		- 레코드와 레코드 사이에 새로운 레코드가 INSERT되는 것을 제어
		- 넥스트 키 락의 일부로써 사용된다
	- 넥스트 키 락
		- 레코드락 + 갭락
		- 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될때 마스터에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적
	- 자동 증가 락
		- 채번할때 사용.
		- 테이블에 단 하나만 존재하고, INSERT될때 아주 짧은 시간동안 락이 걸렸다가 즉시 해제된다
- InnoDB의 락은 "레코드를 잠그는 것이 아니라 인덱스를 잠근다"
	- 예 : employees 테이블에 first_name, last_name, hire_date 컬럼이 있고, first_name에만 인덱스가 걸려있을때
	- `UPDATE employees SET hire_date = NOW() WHERE first_name = 'Georgi' AND last_name = 'Klassen';` 을 실행하면 대상 레코드가 1건이라도 first_name 인덱스에 걸리는 레코드 모두 잠긴다.
	- 왜? 넥스트 키 락 때문.
	- 인덱스가 만약 없으면? 테이블 풀스캔하면서 UPDATE 작업을 하는데, 이때 모든 레코드를 잠근다
	- 그래서 인덱스 설계가 중요하다
- 잠금 확인 및 해제 예 (MySQL 5.1 이상)
	- 커넥션1
		- `BIGIN; UPDATE employees SET column_1 = 'a' WHERE id = 1;`
	- 커넥션2
		- `UPDATE employees SET column_2 = 'b' WHERE id = 1;`
	- 커넥션3
		- `UPDATE employees SET column_1 = 'a' AND column_2 = 'b' WHERE id = 1;`
	- 아래 명령어로 기다리는 트랜잭션과 기다리게 하는 트랜잭션을 알 수 있다
```sql
SELECT
	-- 기다리는 tx
	r.trx_id waiting_trx_id,
	r.trx_mysql_thread_id waiting_thread,
	r.trx_query waiting_query,
	
	-- 기다리게 하는 tx
	b.trx_id blocking_trx_id,
	b.trx_mysql_thread_id blocking_thread,
	b.trx_query blocking_query
FROM information_schema.innodb_lock_awaits w
INNER JOIN information_schema.innodb_trx b ON b.trx_id = w.blocking_trx_id
INNER JOIN information_schema.innodb_trx r ON r.trx_id = w.requesting_trx_id;
```
	- 커넥션2는 커넥션1을 기다린다.
	- 커넥션3은 커넥션 1과 2 둘다 기다린다.
## 4.5 MySQL의 격리 수준

|                           | 더티 리드<br>(다른 트랜잭션이 완료 안되었어도 볼 수 있는 현상) | 논 리피터블 리드<br>(한 트랜잭션 내에서 똑같은 select 시 다른 결과가 나올 수 있는 현상) | 팬텀 리드<br>(락 걸고 조회 시 다른 결과가 나올 수 있는 현상) |
| ------------------------- | -------------------------------------- | -------------------------------------------------------- | -------------------------------------- |
| READ UNCOMMITTED          | O                                      | O                                                        | O                                      |
| READ COMMITTED            | X                                      | O                                                        | O                                      |
| (default) REPEATABLE READ | X                                      | X                                                        | O (InnoDB는 X)                          |
| SERIALIZABLE              | X                                      | X                                                        | X                                      |
- READ UNCOMMITTED
	- 다른 트랜잭션의 commit, rollback 여부에 관계 없이 즉시 읽을 수 있다 (더티 리드)
	- 언두로그를 보지 않는다
- READ COMMITTED
	- 커밋된 데이터만 볼 수 있다
	- 같은 select 문 사이에서 다른 트랜잭션에서 commit한다면 결과가 다를 수 있다 (논 리피터블 리드)
	- 언두로그를 보되, 가장 마지막 값만 본다
- REPEATABLE READ
	- 커밋되었고, 트랜잭션 시작시점 이전 데이터만 볼 수 있다.
	- 언두로그를 보고, 현재 트랜잭션id와 언두로그의 id를 고려한다.
	- `SELECT .. FOR UPDATE`, `SELECT .. LOCK IN SHARE MODE` 를 여러번 할 때 결과가 다를 수 있다 (팬텀 리드)
		- 왜? 언두 레코드엔 락을 걸 수 없기 때문에 현재 레코드 값을 가져오기 때문
	- InnoDB에선 팬텀리드 발생하지 않는다
- SERIALIZABLE
	- 읽기 작업도 잠금을 건다
- READ COMMITTED 와 REPEATABLE READ 의 성능차이는 크지 않다

# 05. 인덱스
- 디스크 읽기 방식
	- HDD보다는 SSD가 DBMS용 스토리지에 적합하다.
		- 랜덤 IO가 훨씬 빠르다. (물리적으로 디스크를 회전시킬 필요가 없으므로)
		- DB 서버에선 순차IO보단 랜덤IO의 비중이 훨씬 크다
- 인덱스
	- 데이터 파일은 저장되는 순서대로 유지, 인덱스는 항상 정렬된 상태 유지
	- 장점 : 조회는 매우 빠르다
	- 단점 : 인덱스가 많을수록 저장하는 처리가 느려진다
	- 인덱스를 역할별로 구분하면 pk와 보조키로 구분할 수 있다
		- pk : 식별 기준값. non null, unique
		- 보조키(Secondary key) : pk를 제외한 나머지 모든 인덱스
	- 인덱스 알고리즘 종류
		- B-Tree 알고리즘
		- Hash 알고리즘
		- Fractal-Tree 알고리즘
- B-Tree(Balanced Tree) 인덱스
	- 인덱싱 알고리즘 가운데 가장 일반적으로 사용됨
	- M차 B-Tree는 자식 노드의 수가 최대 M개
	- 모든 leaf 노트의 depth가 일정하게 유지되고 탐색 시간복잡도는 평균/최대 O(logN)
	- 인덱스 키 추가
		- 리프 노드에 추가하고, 꽉차는 경우 분리되어야 한다. 상위 노드까지 처리 범위가 넓어지기 때문에 쓰기 비용이 많이 든다. 
		- InnoDB에서는 상황에 따라 적절하게 인덱스 키 추가 작업을 지연시킨다
		- `innodb_change_buffering` 설정값으로 추가/삭제 작업 중 어느것을 지연 처리할지 설정해야 한다 (MySQL 5.5이상)
	- 인덱스 키 삭제
		- 해당 키 값이 저장된 리프 노드를 찾아 삭제 마크만 한다
	- 인덱스 키 변경
		- 삭제 후 추가된다
	- 인덱스 키 검색
		- 100% 일치 또는 앞부분만 일치하는 경우에 사용할 수 있다
		- 함수나 연산을 수행한 결과로 정렬한다거나 검색하는 작업은 B-Tree의 장점을 이용할 수 없다 (변형된 값은 인덱스에 존재하는 값이 아니므로)
	- B-Tree 인덱스 사용에 영향을 미치는 요소
		- 인덱스 키 값의 크기
			- B-Tree의 차수(자식 노드의 최대 개수)는 인덱스 페이지의 크기와 키 값의 크기에 따라 결정된다
			- 하나의 인덱스 페이지는 16KB 고정이다. 인덱스 키 값이 커짐에 따라 하나의 인덱스 페이지에 저장할 수 있는 키 개수는 줄어든다 -> 최대 자식 노드가 줄어든다 -> depth가 늘어난다 -> 디스크로부터 읽어야 하는 횟수가 늘어난다 -> 성능저하
		- depth
			- 인덱스 키값의 크기가 커질수록 depth가 깊어져 성능이 저하된다
			- 4~5이상으로 깊어지는 경우는 거의 발생하지 않는다
		- 선택도(기수성)
			- 전체 인덱스 키값은 100개, 유니크한 값의 수는 10개라면 기수성(카디널리티)은 10
			- 인덱스는 카티널리티가 높을수록 검색대상이 줄어들기 때문에 빠르게 처리된다
		- 읽어야 하는 레코드 건수
			- 어림잡아서 읽어야 할 레코드 수가 전체 레코드의 20~25%를 넘어서면 인덱스를 사용하지 않고 직접 읽는것이 효율적이다
	- B-Tree 인덱스를 통한 데이터 읽기
		- 인덱스 레인지 스캔
			- 가장 일반적이고 빠른 방법
			- 검색해야 할 인덱스의 범위가 결정됐을때 사용하는 방식
			- 인덱스를 구성하는 컬럼의 정순 또는 역순으로 정렬된 상태로 레코드를 가져온다
		- 인덱스 풀스캔
			- 인덱스를 사용하지만 레인지 스캔과는 달리 인덱스의 처음부터 끝까지 모두 읽는 방식 (비효울적임)
			- 대표적으로 쿼리의 조건절에 사용된 컬럼이 인덱스의 첫번째 컬럼이 아닌 경우
		- 루스 인덱스 스캔
			- 말그대로 느슨하게, 듬성듬성하게 인덱스를 읽는 것. 위의 두 경우는 타이트 인덱스 스캔으로 분류된다
			- 인덱스 레인지 스캔과 비슷하지만 필요치 않은 키값은 무시하고 다음으로 넘어간다.
			- 주로 GROUP BY 또는 MIN(), MAX() 함수에 대해 최적화를 하는 경우 사용된다
	- B-Tree 인덱스의 정렬 및 스캔 방향
		- 인덱스를 생성할때 쿼리로 ASC, DESC를 명시할 순 있지만 MySQL은 ASC로만 저장한다. (MySQL 8.0부터는 DESC 인덱스 지원)
		- A, B 컬럼으로 인덱스가 있는 테이블에서 A ASC, B DESC로 조회하고 싶으면?
			- 조회는 할 수 있지만 MySQL에서 레코드를 직접 정렬하기 때문에 비효율적이다. 효율적으로 하고 싶다면 B의 음수값을 저장하는 것이 현재로서는 유일한 방법이다.
		- 스캔을 정순으로 할지, 역순으로 할지 쿼리에 따라 옵티마이저가 판단한다.