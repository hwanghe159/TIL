# 03. 아키텍쳐
## 3.2 InnoDB 스토리지 엔진 아키텍쳐

- MySQL의 스토리지 엔진들 중 거의 유일하게 레코드 기반 잠금 제공 -> 높은 동시성 처리
- InnoDB의 특징
	- PK 기준으로 클러스터링되어 저장됨 (PK 순서대로 디스크에 저장됨)
	- MVCC 기술을 사용해서 락 걸지 않고 읽는다 (SERIALIZABLE 제외)
	- 현업에서 잘 쓰진 않지만 FK 지원한다
	- 자동으로 데드락을 감지하고 데드락 발생 시 비용이 더 적은 트랜잭션을 자동으로 종료시킨다
	- 손실이나 장애로부터 데이터를 보호하기 위한 여러 매커니즘이 있다

![[inno-db-architecture.jpeg]]
- InnoDB 버퍼 풀
	- 디스크의 데이터 파일이나 인덱스 정보를 메모리에 캐시해 두는 공간. 아직 디스크에 기록되지 않은 변경된 데이터를 가지고 있다.
	- 일괄작업 되도록 버퍼 역할도 한다. 
- 언두 로그
	- 변경(UPDATE, DELETE) 전의 데이터를 보관하는 곳
	- 용도1. 트랜잭션 롤백 대비용
	- 용도2. 트랜잭션의 격리수준을 유지하면서 높은 동시성을 제공
- 인서트 버퍼
	- INSERT, UPDATE 될때는 데이터 파일 뿐 아니라 인덱스 업데이트도 필요하다.
	- 인덱스가 많다면 많은 자원을 소모하므로 임시 공간(인서트 버퍼)에 저장해두고 사용자에게 바로 반환한다
- 리두 로그
	- 변경된 내용을 순차적으로 기록
	- 리두 로그 덕분에 변경된 내용을 한꺼번에 처리할 수 있다
- 로그 버퍼
	- 리두 로그 버퍼링에 사용되는 공간
- MVCC (Multi Version Concurrency Control) 예시
	- 가정 : 격리 수준은 READ_COMMITTED, 엔진 : InnoDB
	- `UPDATE member SET area = '경기' WHERE id = 12;` 으로 area 값을 서울 -> 경기로 바꿨다면?
	- 커밋 여부와 관계 없이 버퍼 풀엔 `경기` 언두 로그엔 이전 값(`서울`), 디스크엔 모름(일반적으론 `경기`)
	- 커밋 전에 다른 트랜잭션에서 `SELECT * FROM member WHERE id = 12;` 를 하면 언두로그에 있는 이전 값을 읽는다.
	- 롤백되야 한다면 언두 영역의 데이터를 버퍼 풀로 복구하고 언두로그를 삭제한다
- 잠금 없는 일관된 읽기
	- SERIALIZABLE 외의 격리수준에선 SELECT할때 다른 트랜잭션과 관계없이 잠금을 대기하지 않고 바로 읽는다
# 04. 트랜잭션과 잠금
## 4.1 트랜잭션
- MyISAM은 트랜잭션을 지원하지 않는다
- 트랜잭션 범위는 최소화하여 커넥션 점유 시간을 줄이는 것이 좋다
## 4.2 MySQL 엔진의 잠금
- MySQL의 잠금은 스토리지 엔진 레벨과 MySQL 엔진 레벨로 나뉜다
	- MySQL 엔진(MySQL 서버에서 스토리지 엔진을 제외한 나머지 부분) 레벨 잠금 : 모든 스토리지 엔진에 영향을 미침
		- 테이블 락, 유저 락, 네임 락
	- 스토리지 엔진 레벨 잠금 : 엔진 간 영향 없음
- 글로벌 락
	- `FLUSH TABLES WITH READ LOCK` 으로만 획득 가능
	- 락 중 범위가 가장 큼
	- 다른 세션에서 글로벌 락을 획득하면 다른 세션에서 SELECT를 제외한 대부분의 쿼리가 대기한다
- 테이블 락
	- `LOCK TABLES table_name [READ|WRITE]` 으로 명시적으로 획득하거나 묵시적으로 획득 가능
	- `UNLOCK TABLES` 로 락 반납
	- InnoDB에선 레코드 기반의 락을 제공하기 때문에 묵시적인 테이블 락이 설정되지 않는다
- 유저 락
	- 사용자가 지정한 문자열에 대해 획득하고 반납하는 락
	- 자주 쓰이진 않지만 여러 클라이언트가 상호 동기화를 처리해야 할때나 배치같이 한꺼번에 많이 변경하는 프로그램에서의 데드락 문제를 해결할때 사용할 수 있다
- 네임 락
	- 테이블이나 뷰의 이름을 변경할때(`RENAME TABLE tab_a TO tab_b`) 자동으로 획득하는 락
## 4.4 InnoDB 스토리지 엔진의 잠금
- 레코드 기반 잠금 방식을 탑재하고 있어 MyISAM보다는 훨씬 뛰어난 동시성 처리를 제공한다
- InnoDB는 비관적 락 방식 채택
	- 비관적 락 : 현재 트랜잭션에서 변경하고자 하는 레코드에 대해 잠금을 획득하고 변경하는 방식
	- 낙관적 락 : 우선 변경하고 충돌이 있다면 롤백처리하는 방식
- InnoDB의 락 종류
	- 레코드 락
		- 레코드 자체만 잠그는 락.
		- InnoDB는 레코드 자체가 아니라 인덱스의 레코드를 잠근다.
	- 갭 락
		- 레코드와 레코드 사이에 새로운 레코드가 INSERT되는 것을 제어
		- 넥스트 키 락의 일부로써 사용된다
	- 넥스트 키 락
		- 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될때 마스터에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주 목적
	- 자동 증가 락
		- 채번할때 사용.
		- 테이블에 단 하나만 존재하고, INSERT될때 아주 짧은 시간동안 락이 걸렸다가 즉시 해제된다
- InnoDB의 락은 "레코드를 잠그는 것이 아니라 인덱스를 잠근다"
	- 예 : employees 테이블에 first_name, last_name, hire_date 컬럼이 있고, first_name에만 인덱스가 걸려있을때
	- `UPDATE employees SET hire_date = NOW() WHERE first_name = 'Georgi' AND last_name = 'Klassen';` 을 실행하면 대상 레코드가 1건이라도 first_name 인덱스에 걸리는 레코드 모두 잠긴다.
	- 인덱스가 만약 없으면? 테이블 풀스캔하면서 UPDATE 작업을 하는데, 이때 모든 레코드를 잠근다
	- 그래서 인덱스 설계가 중요하다
## 4.5 MySQL의 격리 수준

# 05. 인덱스
