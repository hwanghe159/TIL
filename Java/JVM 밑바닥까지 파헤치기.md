# 2부 자동 메모리 관리  
## 2장 자바 메모리 영역과 메모리 오버플로  
- 런타임 데이터 영역 ![[JVM_런타임_데이터_영역.jpeg]]
	- 프로그램 카운터 레지스터
		- '바이트코드 줄 번호 표시기'라고 생각하면 쉽다
		- 각 스레드별로 독립적이다 (스레드 프라이빗 메모리에 저장된다)
		- 저장되는 값
			- 스레드가 자바 메서드를 실행중일땐 -> 바이트코드의 명령어 주소
			- 네이티브 메서드를 실행중일 땐 -> Undefined
	- 가상 머신 스택
		- 메서드가 호출될때 스택 프레임을 만들어 push하고, 끝나면 pop한다
		- 스택 프레임엔 지역변수 테이블, 피연산자 스택, 동적 링크, 메서드 반환값 등의 정보를 저장한다
		- 지역변수 테이블?
			- 컴파일 타임에 알 수 있는 기본 데이터 타입, 객체 참조, 반환주소 타입을 저장한다
		- 스택 깊이가 허용 깊이보다 깊다면 `StackOverflowError`를 던진다
	- 네이티브 메서드 스택
		- 가상 머신 스택과 유사하나 네이티브 메서드를 실행할 때 사용한다
		- JVM 명세에는 이에 대해 아무것도 명시하지 않아, JVM 구현자가 자유롭게 표현할 수 있다. 핫스팟 가상머신은 가상머신 스택과 네이티브 메서드 스택을 합쳐놓았다.
	- 힙
		- 가장 큰 영역이고, 모든 스레드가 공유한다
		- 가상 머신이 구동될 때 만들어진다
		- '거의' 모든 객체 인스턴스가 이 영역에 할당된다
		- JVM 명세엔 힙 내부 구현에 대한 이야기가 없어 구현체마다 자유지만, 보통은 세대별 컬렉션 이론(new, old, eden, survivor ...)을 기초로 설계된다
		- 객체 할당 효율을 높이기 위해 힙은 스레드 로컬 할당 버퍼 여러개로 나뉜다
		- `-Xmx` `-Xms`로 크기를 고정/확장 할 수 있고, 힙 공간이 부족해지면 `OutOfMemoryError`을 던진다
	- 메서드 영역
		- 모든 스레드가 공유한다
		- 가상 머신이 읽어들인 타입 정보, 상수, 정적 변수, JIT 컴파일러가 컴파일한 코드 캐시 등을 저장한다
		- 메서드 영역 != 힙의 영구 세대
			- JDK 7 까지는 핫스팟VM 개발자들이 메서드 영역을 영구 세대에 구현했었다
			- JDK 8 부터는 영구세대라는 개념을 없앴다
	- 런타임 상수 풀
		- 메서드 영역 내에 있다.
		- 클래스파일에 포함된 설명정보와 컴파일타임에 생성된 다양한 리터럴과 심벌 참조가 저장된다
- 핫스팟VM에서의 객체
	- 
## 3장 가비지 컬렉터와 메모리 할당 전략  

## 4장 가상 머신 성능 모니터링과 문제 해결 도구  

## 5장 최적화 사례 분석 및 실전  

# 3부 자동 메모리 관리  
## 6장 클래스 파일 구조  

## 7장 클래스 로딩 메커니즘  

## 8장 바이트코드 실행 엔진  

## 9장 클래스 로딩과 실행 서브시스템, 사례와 실전  

# 4부 컴파일과 최적화  
## 10장 프런트엔드 컴파일과 최적화  

## 11장 백엔드 컴파일과 최적화  

# 5부 효율적인 동시성
## 12장 자바 메모리 모델과 스레드  

## 13장 스레드 안전성과 락 최적화  
