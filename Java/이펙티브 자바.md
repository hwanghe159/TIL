# 이펙티브 자바

### 아이템5. 자원을 직접 명시하지 말고 의존 객체 주입을 사용하라

맞춤법 검사기를 구현한다 했을때, 아래와 같이 정적 유틸리티 클래스나 싱글톤으로 구현하는 경우가 많다. 

- 정적 유틸리티 클래스 방식

  ```java
  public class SpellChecker {
  
      private static final Lexicon DICTIONARY = ...; //직접생성
  
      private SpellChecker() { //객체 생성 방지
      }
  
      public static boolean isValid(String word) {...}
      public static List<String> suggestions(String typo) {...}
  }
  ```

- 싱글톤 방식

  ```java
  public class SpellChecker {
  
      private final Lexicon dictionary = ...; //직접생성
  
      private SpellChecker(...) {...}
      public static SpellChecker INSTANCE = new SpellChecker(...);
  
      public boolean isValid(String word) {...}
      public List<String> suggestions(String typo) {...}
  }
  ```

하지만, 위 두 방식은 유연하지 않고 테스트하기 어렵다. 왜냐하면

- 사용할 사전이 단 한가지라고 가정하고 있다.
- 의존하는 객체를 직접 생성하고 있다.

그럼, `SpellChecker`가 여러 사전을 바꿔가며 사용할 수 있도록 setter를 추가해보자.

```java
public class SpellChecker {

    private Lexicon dictionary = ...; //final 제거

    public SpellChecker() {
    }
    
    public void setDictionary(Lexicon dictionary) { //사전 변경 메서드
        this.dictionary = dictionary;
    }

    public boolean isValid(String word) {...}
    public List<String> suggestions(String typo) {...}
}
```

하지만 위의 방법에도 문제가 있다.

- 어색하고 오류를 내기 쉽다
- 멀티쓰레드 환경에서는 쓸 수 없다

이 문제들을 한방에 해결하려면 의존 객체 주입 패턴을 사용하자.

```java
public class SpellChecker {

    private final Lexicon dictionary; //final로 불변을 보장하자

    public SpellChecker(Lexicon dictionary) { //생성자에 필요한 자원을 넘겨준다
        this.dictionary = Objects.requireNonNull(dictionary);
    }
    
    public boolean isValid(String word) {...}
    public List<String> suggestions(String typo) {...}
}
```

```java
//클라이언트
Lexicon lexicon = ...; //Lexicon객체 생성
SpellChecker spellChecker = new SpellChecker(lexicon); //주입
spellChecker.isValid("마춤뻡"); //false
```

의존 객체 주입 패턴의 장점

- 자원이 몇개든 의존관계가 어떻든 상관없이 잘 동작한다
- 유연하고 테스트가 쉽다

또한, 의존 객체가 불변이라면, 여러 클라이언트가 의존 객체들을 공유할 수 있다

의존 객체 주입 패턴의 쓸만한 변형으로는 생성자에 자원 팩터리를 넘겨주는 방식이 있다.

- 팩터리 : 호출할 때마다 특정 타입의 인스턴스를 반복해서 만들어주는 객체 (아래 예에선 `Supplier<? extends Tile>`)

```java
Mosaic flowerMosaic = mosaicCreator.create(() -> new Tile("꽃무늬"));
Mosaic checkMosaic = mosaicCreator.create(() -> new Tile("체크무늬"));
```

```java
//MosaicCreator.java
public Mosaic create(Supplier<? extends Tile> tileFactory) {
    Tile tile1 = tileFactory.get();
    Tile tile2 = tileFactory.get();
    Tile tile3 = tileFactory.get();
    Tile tile4 = tileFactory.get();
    return new Mosaic(Arrays.asList(tile1, tile2, tile3, tile4));
}
```

[여기](https://github.com/hwanghe159/lab/tree/master/functionalinterface/src)에서 전체 코드를 볼 수 있습니다.

의존 객체 주입은 유연성과 테스트 용이성을 개선해주지만, 의존성이 많은 경우 코드를 어지럽게 할 수 있다.

-> 의존 객체 주입 프레임워크(대거, 주스, 스프링 등)를 사용하면 해소할 수 있다

#### 결론

- 클래스가 자원에 의존하고 있고, 자원이 클래스 동작에 영향을 준다면 정적 유틸리티 클래스나 싱글턴을 이용하지 않는 게 좋다
- 자원들을 클래스가 직접 만들게 해서도 안된다
- 필요한 자원(또는 그 자원을 만들어주는 팩터리)을 생성자(또는 정적 팩터리나 빌더)에 넘겨주면 클래스의 유연함, 재사용성, 테스트 용이성을 개선해준다

<br/>

### 아이템9. try-finally보다는 try-with-resources를 사용하라

`close()`를 통해서 직접 닫아줘야 하는 자원이 많이 있다. (`InputStream`, `OutputStream`, `java.sql.Connection` 등)

자원을 제대로 닫기 위해서 아래와 같이 try-finally 방식으로 구현해왔다.

```java
static void copy(String src, String dst) throws IOException {
    InputStream in = new FileInputStream(src);
    try {
        OutputStream out = new FileOutputStream(dst);
        try {
            byte[] buf = new byte[BUFFER_SIZE];
            int n;
            while ((n = in.read(buf)) >= 0)
                out.write(buf, 0, n);
        } finally {
            out.close();
        }
    } finally {
        in.close();
    }
}
```

다음은 위 코드를 자바7에 등장한 try-with-resources방식으로 바꾼 코드다.

```java
static void copy(String src, String dst) throws IOException {
    try (InputStream in = new FileInputStream(src);
         OutputStream out = new FileOutputStream(dst)) {
        byte[] buf = new byte[BUFFER_SIZE];
        int n;
        while ((n = in.read(buf)) >= 0)
            out.write(buf, 0, n);
    }
}
```

단, 이 구조를 사용하려면 해당 자원이 `AutoClosable` 인터페이스를 구현해야 한다.

try-with-resources방식의 장점은

1. 가독성이 좋다

   - try-finally방식은 자원이 2개 이상인 경우 try문을 중첩으로 사용하지만, try-with-resources방식은 그렇지 않다

2. try-finally방식보다 문제를 진단하기에 좋다

   - 예를 들어 아래의 코드의 try-finally방식을 보면, 물리적인 문제 때문에 `br.readLine()` `br.close()` 두 곳에서 예외가 발생했을때

   - ```java
     //try-finally방식
     static String firstLineOfFile(String path) throws IOException {
         BufferedReader br = new BufferedReader(new FileReader(path));
         try {
             return br.readLine();//실패
         } finally {
             br.close();//실패
         }
     }
     
     //try-with-resources방식
     static String firstLineOfFile(String path) throws IOException {
         try (BufferedReader br = new BufferedReader(new FileReader(path))) {
             return br.readLine();
         }
     }
     ```

   -  try-finally방식은 `br.readLine()`에 대한 스택 추적 내역은 남지 않고 `br.close()`의 스택 추적 내역만 남는다 (집어삼킨다. 왜 집어삼킬까??)

   - try-with-resources방식은 `br.readLine()`은 기록되고, `br.close()`는 '숨겨졌다'는 꼬리표를 달고 출력된다.

#### 결론

회수해야 하는 자원을 다룰 때는 예외없이 try-finally 보다는 try-with-resources를 쓰자. 가독성도 좋아지고 만들어지는 예외 정보도 훨씬 유용하다.

<br/>